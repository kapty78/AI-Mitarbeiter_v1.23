"use client"

import React from 'react'
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs"
import { useEffect, useRef, useState, useMemo } from "react"
import { useSearchParams } from "next/navigation"
import Link from "next/link"
import { ChevronLeft, Menu, Plus, Send, ChevronDown, Copy, RotateCcw, Edit, Paperclip, Image, Search, MoreVertical, Trash, X, FlaskConical, MoreHorizontal, Mic, Loader, FileText, FileDown, BookOpen, User, Settings, Home, ChevronRight, MessageCircle, Sparkles } from "lucide-react" // Added Icons
import ReactMarkdown from "react-markdown"
import remarkGfm from 'remark-gfm'
import { v4 as uuidv4 } from 'uuid'
import { TypewriterEffect } from "../components/typewriter"
import { useRouter } from "next/navigation"
import { cn } from "@/lib/utils"
import Joyride, { Step, CallBackProps, STATUS } from 'react-joyride'; // Import Joyride
import dynamic from 'next/dynamic'; // Import dynamic
import { performSerpApiSearch, formatSearchResults, formatSearchResultsForAI } from "../utils/serpApi";
import { downloadChatAsPdf } from '../utils/pdfExport';
import { generateChatSummary } from '../utils/chatSummary';
import ExportModal from '../components/ExportModal';
import SummaryModal from '../components/SummaryModal';
// Drag-and-Drop-Bibliotheken
import { DndContext, useDraggable, useDroppable, useSensors, useSensor, PointerSensor } from '@dnd-kit/core';
import { LoadingIndicator } from '@/components/LoadingIndicator'; // Corrected import path
import SettingsModal from '@/app/components/SettingsModal'; // Import the SettingsModal component

// Dynamically import Joyride with SSR disabled
const DynamicJoyride = dynamic(() => import('react-joyride'), { ssr: false });

// Define a simpler interface for CodeProps
interface CodeProps {
  node?: any
  inline?: boolean
  className?: string
  children?: React.ReactNode
}

interface Message {
  id: string
  role: 'user' | 'assistant' | 'system'
  content: string
  timestamp: Date
  isTypewriting?: boolean
  user_id?: string // Add user_id to track message sender
  sentfrom?: string // Add sentfrom to store user name directly
}

interface ChatSession {
  id: string
  name: string
  created_at: string
  description?: string
  project_id?: string | null
  last_message_timestamp?: string
  user_id?: string
}

interface Task {
  id: string
  title: string
  description: string
  system_prompt: string
  ai_model: string
  created_at?: string
  updated_at?: string
  user_id?: string
  workspace_id?: string | null
  project_id?: string | null
}

interface Project {
  id: string
  name: string
  description?: string
  user_id: string
  workspace_id?: string | null
  chats?: ChatSession[] // Chats, die zu diesem Projekt gehören
}

// Define structure for info items (used for buttons, tour content can be different)
interface InfoItem {
  title: string
  // We'll define tour steps separately now
}

// Keep infoItems simple for the buttons
const infoItems: InfoItem[] = [
  { title: "Tasks nutzen" },
  { title: "KI-Modell wechseln" },
  { title: "Nachrichten bearbeiten & neu generieren" },
  { title: "Chats verwalten" }
]

const initialMessages: Message[] = []

// Define Tour Steps (Adjust step 3)
const tourSteps: Step[] = [
  {
    target: '#task-select-button',
    content: (
      <>
        <p className="mb-2">Mit Tasks können Sie der KI spezifische Anweisungen oder eine bestimmte Rolle für den gesamten Chat zuweisen.</p>
        <p>Klicken Sie hier, um einen vorhandenen Task zu wählen oder einen neuen zu erstellen. Tasks überschreiben die manuelle Modellauswahl.</p>
      </>
    ),
    placement: 'bottom-end',
    title: "Tasks nutzen",
  },
  {
    target: '#model-select-button',
    content: (
      <>
        <p className="mb-2 text-sm">Wählen Sie hier das KI-Modell, wenn kein Task aktiv ist:</p>
        <ul className="mb-2 ml-4 list-inside list-disc space-y-1 text-sm">
          <li><strong>Basic (GPT-4o):</strong> Ausgewogen.</li>
          <li><strong>Fast (GPT-4o mini):</strong> Schnell & Günstig.</li>
          <li><strong>Reason (GPT-4 Vision):</strong> Leistungsstark.</li>
        </ul>
      </>
    ),
    placement: 'bottom-end',
    title: "KI-Modell wechseln",
  },
  {
    target: '#chat-sidebar',
    content: 'Hier verwalten Sie Ihre Chats: Neuen Chat erstellen (+), Chat auswählen, umbenennen oder löschen (über die drei Punkte).',
    placement: 'right',
    title: "Chats verwalten",
  },
  {
    target: '#new-chat-button',
    content: 'Klicken Sie hier, um einen neuen, leeren Chat zu beginnen.',
    placement: 'left',
    title: "Neuer Chat",
    disableScrolling: true,
    disableOverlayClose: true,
    spotlightPadding: 5
  },
   {
    target: '#chat-input-textarea',
    content: 'Geben Sie hier Ihre Nachricht ein und drücken Sie Enter oder klicken Sie auf den Senden-Button.',
    placement: 'top',
    title: "Nachricht senden",
  }
];

// Helper function to fix the columns handling consistently
const getColumnNames = (columns: any[] | null): string[] => {
  return columns ? columns.map((col: { column_name: string }) => col.column_name) : [];
};

export default function Chat() {
  const searchParams = useSearchParams()
  const rawWorkspaceId = searchParams.get("workspace")
  const taskId = searchParams.get("task")
  
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [user, setUser] = useState<any>(null)
  const [workspace, setWorkspace] = useState<any>(null)
  const [userFullName, setUserFullName] = useState<string>("Du")
  const [messages, setMessages] = useState<Message[]>(initialMessages)
  const [inputValue, setInputValue] = useState('')
  const [isTyping, setIsTyping] = useState(false)
  const [showIceBreakers, setShowIceBreakers] = useState(false)
  const [showModelDropdown, setShowModelDropdown] = useState(false)
  const [selectedModel, setSelectedModel] = useState('gpt-4o')
  const [chatSessions, setChatSessions] = useState<ChatSession[]>([])
  const [currentChatId, setCurrentChatId] = useState<string | null>(null)
  const [tasks, setTasks] = useState<Task[]>([])
  const [selectedTask, setSelectedTask] = useState<Task | null>(null)
  const [showTaskDropdown, setShowTaskDropdown] = useState(false)
  const [showTaskModal, setShowTaskModal] = useState(false)
  const [newTask, setNewTask] = useState<Task>({
    id: '',
    title: '',
    description: '',
    system_prompt: '',
    ai_model: ''
  })
  const [newTaskName, setNewTaskName] = useState('')
  const [newTaskDescription, setNewTaskDescription] = useState('')
  const [newTaskSystemPrompt, setNewTaskSystemPrompt] = useState('')
  const [newTaskModel, setNewTaskModel] = useState('gpt-4o')
  const [showSidebar, setShowSidebar] = useState(true)
  const [typingMessageId, setTypingMessageId] = useState<string | null>(null)
  const [personalWorkspaceId, setPersonalWorkspaceId] = useState<string | null>(null)
  const [previousSelectedTask, setPreviousSelectedTask] = useState<Task | null>(null)
  const [previousSelectedModel, setPreviousSelectedModel] = useState<string | null>(null)
  const [messageUpdatePending, setMessageUpdatePending] = useState(false)
  const [isTaskSwitching, setIsTaskSwitching] = useState(false)
  const [lastMessageUpdate, setLastMessageUpdate] = useState(Date.now())
  
  // State für Projekte
  const [projects, setProjects] = useState<Project[]>([])
  const [selectedProject, setSelectedProject] = useState<Project | null>(null)
  const [showProjectDropdown, setShowProjectDropdown] = useState(false)
  const [showProjectModal, setShowProjectModal] = useState(false)
  const [newProjectName, setNewProjectName] = useState('')
  const [newProjectDescription, setNewProjectDescription] = useState('')
  const [projectMenuOpen, setProjectMenuOpen] = useState<string | null>(null)
  const [projectToRename, setProjectToRename] = useState<Project | null>(null)
  
  // State für Drag & Drop
  const [draggedChatId, setDraggedChatId] = useState<string | null>(null)
  const [activeDropTarget, setActiveDropTarget] = useState<string | null>(null)
  
  // State für aufgeklappte Projekte
  const [expandedProjects, setExpandedProjects] = useState<Record<string, boolean>>({})
  
  // State for editing messages
  const [editingMessageId, setEditingMessageId] = useState<string | null>(null)
  const [editingContent, setEditingContent] = useState('')
  
  // Add searchDebounceTimeout ref
  const searchDebounceTimeout = useRef<any>(null);
  
  const chatBodyRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLTextAreaElement>(null)
  const modelDropdownRef = useRef<HTMLDivElement>(null)
  const taskDropdownRef = useRef<HTMLDivElement>(null)
  const projectDropdownRef = useRef<HTMLDivElement>(null)
  
  const supabase = createClientComponentClient()
  
  // Add state for chat menu and rename functionality
  const [chatMenuOpen, setChatMenuOpen] = useState<string | null>(null)
  const [renameModalOpen, setRenameModalOpen] = useState(false)
  const [chatToRename, setChatToRename] = useState<ChatSession | null>(null)
  const [newChatName, setNewChatName] = useState('')
  // Neuer State für inline edit
  const [editingChatId, setEditingChatId] = useState<string | null>(null)
  
  const router = useRouter()
  
  // Add state and refs for the input action menu
  const [showInputMenu, setShowInputMenu] = useState(false);
  const inputMenuRef = useRef<HTMLDivElement>(null);
  const moreOptionsButtonRef = useRef<HTMLButtonElement>(null);
  
  // Füge einen Ref für die Edit-Box hinzu
  const editBoxRef = useRef<HTMLDivElement>(null);
  
  // Add state for the new info modal
  // const [showInfoModal, setShowInfoModal] = useState(false)
  // const [modalContent, setModalContent] = useState<InfoItem | null>(null)
  
  // Add state for React Joyride
  const [runTour, setRunTour] = useState(false);
  const [stepIndex, setStepIndex] = useState(0);
  
  // State to control showing fake messages during the tour
  const [showFakeMessagesForTour, setShowFakeMessagesForTour] = useState(false);
  
  // Define fake messages for the tour demonstration
  const fakeTourMessages: Message[] = [
    {
      id: 'fake-user-1',
      role: 'user',
      content: 'Das ist eine Beispiel-Nachricht des Benutzers.',
      timestamp: new Date(Date.now() - 120000) // 2 minutes ago
    },
    {
      id: 'fake-ai-message',
      role: 'assistant',
      content: 'Und hier ist eine Beispiel-Antwort der KI. Wenn Sie den Mauszeiger über diese Nachricht bewegen, werden Aktionsbuttons angezeigt.',
      timestamp: new Date(Date.now() - 60000) // 1 minute ago
    }
  ];
  
  // Add loading state specifically for search
  const [isSearching, setIsSearching] = useState(false);
  // Add chat message search state
  const [searchOpen, setSearchOpen] = useState(false);
  const [messageSearchQuery, setMessageSearchQuery] = useState("");
  const [messageSearchResults, setMessageSearchResults] = useState<any[]>([]);
  
  // New state variables for the export and summary modals
  const [showExportModal, setShowExportModal] = useState(false);
  const [showSummaryModal, setShowSummaryModal] = useState(false);
  const [chatSummary, setChatSummary] = useState('');
  const [isSummarizing, setIsSummarizing] = useState(false);
  
  // State for showing the message actions dialog
  const [showMessageActionsDialog, setShowMessageActionsDialog] = useState(false);
  const [isImprovingPrompt, setIsImprovingPrompt] = useState(false)
  
  // Add the state for showing settings modal
  const [showSettingsModal, setShowSettingsModal] = useState(false); // Add state for settings modal
  
  // Add state for storing user names
  const [userNamesMap, setUserNamesMap] = useState<{[key: string]: string}>({});
  
  useEffect(() => {
    if (selectedTask && selectedTask.ai_model) {
      setSelectedModel(selectedTask.ai_model);
    }
  }, [selectedTask]);
  
  useEffect(() => {
    const fetchPersonalWorkspace = async () => {
      if (user) {
        console.log("Fetching personal workspace for user:", user.id);
        const { data, error } = await supabase
          .from('workspaces')
          .select('id')
          .eq('user_id', user.id)
          .eq('is_home', true)
          .single(); // Annahme: Es gibt nur EINEN persönlichen Workspace

        if (error && error.code !== 'PGRST116') { // Ignore ' esattamente uma linha esperada'
          console.error("Error fetching personal workspace:", error);
        } else if (data) {
          console.log("Personal workspace found:", data.id);
          setPersonalWorkspaceId(data.id);
        } else {
          console.warn("Personal workspace not found for user:", user.id);
          // Hier könnte man optional den Workspace erstellen, falls er fehlt
          // oder eine Fehlermeldung anzeigen.
        }
      }
    };
    if (user && !rawWorkspaceId) { // Nur laden, wenn kein Workspace in URL und User bekannt
       fetchPersonalWorkspace();
    }
  }, [user, supabase, rawWorkspaceId]); // Abhängigkeiten
  
  // Optimierte Kontextauswahl mit Caching, besserer Priorisierung und Ausschluss aktueller Nachrichten
  // Cache für Chat-Sessions um redundante Ladevorgänge zu vermeiden
  const chatSessionsCache = {
    sessions: null,
    timestamp: 0,
    maxAge: 5000, // Cache ist für 5 Sekunden gültig
  };

  // Cache für Projektberechnungen
  const projectsCache = {
    projectChats: null,
    timestamp: 0,
    maxAge: 10000, // Cache ist für 10 Sekunden gültig
  };

  // Optimierte Funktion zum Laden von Chat-Sessions mit Caching
  const loadChatSessionsWithCache = async (userId, workspaceId) => {
    const now = Date.now();
    
    // Prüfen, ob der Cache gültig ist
    if (chatSessionsCache.sessions && (now - chatSessionsCache.timestamp) < chatSessionsCache.maxAge) {
      console.log('📦 Verwende gecachte Chat-Sessions');
      return chatSessionsCache.sessions;
    }
    
    console.log(`🔄 Loading chat sessions - userId: ${userId} workspaceId: ${workspaceId}`);
    
    // Lade Daten wie zuvor
    const { data, error } = await supabase
      .from('chats')
      .select('*')
      .eq('user_id', userId)
      .eq('workspace_id', workspaceId)
      .order('updated_at', { ascending: false });
    
    if (error) {
      console.error('❌ Fehler beim Laden der Chat-Sessions:', error);
      return [];
    }
    
    console.log(`✅ Loaded ${data.length} chat sessions`);
    
    // Verarbeite Daten und speichere sie im Cache
    const formattedSessions = data.map((chat: any) => ({
      id: chat.id,
      name: chat.name || 'Neuer Chat',
      timestamp: chat.updated_at,
      message_count: chat.message_count || 0,
      project: chat.project || null,
      temperature: chat.temperature,
      model: chat.model || null,
    }));
    
    // Cache aktualisieren
    chatSessionsCache.sessions = formattedSessions;
    chatSessionsCache.timestamp = now;
    
    return formattedSessions;
  };

  // Optimierte Funktion zur Projektberechnung mit Caching
  const recalculateProjectsWithCache = (chats) => {
    const now = Date.now();
    
    // Prüfen, ob der Cache gültig ist
    if (projectsCache.projectChats && (now - projectsCache.timestamp) < projectsCache.maxAge) {
      return projectsCache.projectChats;
    }
    
    console.log(`🔢 Berechne Projekte neu aus ${chats.length} verfügbaren Chats`);
    
    const projectChats = new Map();
    
    // Projekte berechnen wie zuvor
    const availableProjects = [...new Set(chats.filter(c => c.project).map(c => c.project))];
    
    availableProjects.forEach(project => {
      const chatsInProject = chats.filter(c => c.project === project);
      projectChats.set(project, chatsInProject);
      console.log(`🗂️ Projekt ${project} hat ${chatsInProject.length} Chats`);
    });
    
    // Cache aktualisieren
    projectsCache.projectChats = projectChats;
    projectsCache.timestamp = now;
    
    return projectChats;
  };

  // Hauptfunktion für die Kontext-Suche, verbessert mit Ausschluss der aktuellen Nachricht
  const findSimilarMessagesOptimized = async (userId: string, query: string, currentMessageId: string | null = null) => {
    console.log(`🔍 Suche nach ähnlichen Nachrichten für User ${userId}`);
    console.log(`📝 Suchanfrage: "${query}"`);
    
    try {
      // Erstelle Embedding für die Anfrage
      console.log(`🧠 Generiere Embedding für Suchanfrage...`);
      const embedding = await createEmbedding({ content: query, id: 'query', role: 'user', timestamp: new Date() }, "", null);
      
      if (!embedding) {
        console.error('❌ Fehler beim Generieren des Embeddings für die Suche');
        return [];
      }
      
      console.log(`✅ Embedding für Abfrage erfolgreich generiert`);
      console.log(`📊 Query-Embedding-Dimensionen: ${embedding.length}`);
      console.log(`🔍 Query-Embedding-Vorschau (erste 5 Werte): ${JSON.stringify(embedding.slice(0, 5))}`);
      
      // RPC für die Ähnlichkeitssuche aufrufen
      console.log(`📞 Rufe search_similar_messages RPC für User ${userId} auf (Schwellwert: 0.7, Max Ergebnisse: 15)`);
      
      const { data: results, error } = await supabase.rpc('search_similar_messages', {
        p_user_id: userId,
        query_embedding: embedding,
        similarity_threshold: 0.7,
        max_results: 15  // Erhöht, um mehr Kandidaten zu haben
      });
      
      if (error) {
        console.error('❌ Fehler bei der RPC-Suche nach ähnlichen Nachrichten:', error);
        return [];
      }
      
      console.log(`🔎 RPC Ergebnis: ${results?.length || 0} Nachrichten gefunden`);
      console.log(`📋 Erste Ergebnisse (Rohdaten): ${JSON.stringify(results?.slice(0, 2) || [])}`);
      
      // Filtere die aktuelle Nachricht, falls vorhanden
      let filteredResults = results || [];
      if (currentMessageId) {
        const originalLength = filteredResults.length;
        filteredResults = filteredResults.filter((msg: any) => msg.id !== currentMessageId);
        if (originalLength !== filteredResults.length) {
          console.log(`🧹 Aktuelle Nachricht mit ID ${currentMessageId} aus Ergebnissen ausgeschlossen`);
        }
      }
      
      console.log(`🧹 Nach Filterung: ${filteredResults.length} Nachrichten übrig`);
      
      // Verarbeite die Nachrichten wie zuvor, um Datumsinformationen zu extrahieren...
      console.log(`🔄 Verarbeite Nachrichten, um Datumsinformationen zu extrahieren...`);
      
      for (const msg of filteredResults) {
        // Extrahiere Datum aus dem Nachrichteninhalt
        const dateMatch = msg.content_with_date?.match(/\[Datum: ([^\]]+)\]/);
        if (dateMatch && dateMatch[1]) {
          msg.dateInfo = dateMatch[1];
          console.log(`📅 Datum gefunden in Nachricht ${msg.id}: ${msg.dateInfo}`);
        } else {
          console.log(`⚠️ Kein Datum gefunden in Nachricht ${msg.id}`);
        }
        
        // Generiere eine anzeigbare Version des Inhalts ohne Datum
        msg.displayContent = msg.content_with_date?.replace(/\[Datum: [^\]]+\]\n/, '') || msg.content;
      }
      
      console.log(`✅ ${filteredResults.length} ähnliche Nachrichten nach Filterung gefunden`);
      
      return filteredResults;
    } catch (error) {
      console.error('❌ Fehler bei der Suche nach ähnlichen Nachrichten:', error);
      return [];
    }
  };

  // Verbesserte Kontext-Auswahlfunktion mit optimierter Bewertung für neueste/älteste Nachrichten
  if (similarMessages.length > 0) {
    // Gruppiere Nachrichten nach Chat-ID
    const chatGroups = new Map<string, any[]>();
    
    // Schritt 1: Gruppiere Nachrichten nach Chats
    similarMessages.forEach((msg: any) => {
      if (!chatGroups.has(msg.chat_id)) {
        chatGroups.set(msg.chat_id, []);
      }
      chatGroups.get(msg.chat_id)?.push(msg);
    });
    
    // Sortiere Nachrichten innerhalb der Gruppen nach Erstellungszeit
    chatGroups.forEach((messages, _) => {
      messages.sort((a, b) => 
        new Date(a.created_at || 0).getTime() - new Date(b.created_at || 0).getTime()
      );
    });
    
    // Schritt 2: Berechne Relevanz-Score für jede Gruppe mit verbesserter Priorisierung
    const scoredGroups = Array.from(chatGroups.entries()).map(([chatId, messages]) => {
      // Basisähnlichkeit: Die durchschnittliche Ähnlichkeit der Top-2 Nachrichten
      const topSimilarities = messages
        .filter(msg => !msg.isContext) // Nur primäre Treffer, keine Kontext-Nachrichten
        .map(msg => msg.similarity || 0)
        .sort((a, b) => b - a)
        .slice(0, 2);
      
      const avgTopSimilarity = topSimilarities.length > 0 
        ? topSimilarities.reduce((sum, sim) => sum + sim, 0) / topSimilarities.length
        : 0;
      
      // Qualität der Konversation: Bewerte Gespräche mit Rollenwechseln höher
      let conversationQuality = 0;
      let roleChanges = 0;
      
      for (let i = 1; i < messages.length; i++) {
        if (messages[i].role !== messages[i-1].role) {
          roleChanges++;
        }
      }
      
      // Normalisiere auf einen Wert zwischen 0 und 0.15
      conversationQuality = Math.min(0.15, roleChanges * 0.05);
      
      // Zeitliche Relevanz: Älteste und neueste Nachrichten bevorzugen
      // Bestimme den Zeitbereich der Nachrichten
      const datesWithInfo = messages
        .filter(msg => msg.dateInfo)
        .map(msg => new Date(msg.dateInfo).getTime());
      
      let timeRelevanceBonus = 0;
      
      if (datesWithInfo.length > 0) {
        const sortedDates = [...datesWithInfo].sort((a, b) => a - b);
        const oldestDate = sortedDates[0];
        const newestDate = sortedDates[sortedDates.length - 1];
        const now = new Date().getTime();
        
        // Bestimme, ob diese Gruppe die älteste oder neueste Information enthält
        const isOldestInfo = messages.some(msg => 
          msg.dateInfo && new Date(msg.dateInfo).getTime() === oldestDate
        );
        
        const isNewestInfo = messages.some(msg => 
          msg.dateInfo && new Date(msg.dateInfo).getTime() === newestDate
        );
        
        // Neueste Information erhält einen starken Bonus
        if (isNewestInfo) {
          const daysDiff = Math.floor((now - newestDate) / (1000 * 3600 * 24));
          timeRelevanceBonus += 0.3 * Math.max(0, 1 - (daysDiff / 14)); // Neuere Nachrichten innerhalb von 14 Tagen bekommen bis zu +0.3
        }
        
        // Älteste Information erhält auch einen Bonus
        if (isOldestInfo) {
          timeRelevanceBonus += 0.2; // Feste +0.2 für die erste Erwähnung eines Themas
        }
      }
      
      // Kombiniere alle Faktoren zum Gesamt-Score
      const score = avgTopSimilarity + conversationQuality + timeRelevanceBonus;
      
      return { chatId, messages, score, hasNewest: timeRelevanceBonus > 0.2, hasOldest: timeRelevanceBonus >= 0.2 };
    });
    
    // Sortiere Gruppen nach Score absteigend
    scoredGroups.sort((a, b) => b.score - a.score);
    
    // Wähle die Top-3 relevantesten Gruppen
    const topGroups = scoredGroups.slice(0, 3);
    
    console.log(`🧠 Ausgewählte Chat-Gruppen für Kontext: ${topGroups.length}`);
    topGroups.forEach(group => {
      const topSimilarityMsg = group.messages
        .filter(msg => !msg.isContext)
        .reduce((max, msg) => msg.similarity > (max?.similarity || 0) ? msg : max, null);
      
      console.log(`  • Chat ${group.chatId.substring(0, 6)}... (Score: ${group.score.toFixed(2)}) mit ${group.messages.length} Nachrichten`);
      if (topSimilarityMsg) {
        console.log(`    Beste Übereinstimmung: "${(topSimilarityMsg.displayContent || '').substring(0, 40)}..." (${topSimilarityMsg.similarity.toFixed(2)})`);
      }
      
      // Log für neueste/älteste Informationen
      if (group.hasNewest) {
        console.log(`    ⭐ Diese Gruppe enthält die NEUESTEN Informationen zu diesem Thema`);
      }
      if (group.hasOldest) {
        console.log(`    📜 Diese Gruppe enthält die ÄLTESTEN Informationen zu diesem Thema`);
      }
    });
    
    // Formatiere Nachrichten für den Kontext
    let contextContent = '';
    
    topGroups.forEach(group => {
      const chatMessages = group.messages;
      
      // Extrahiere den Chat-Namen wenn möglich
      const chatName = chatSessions.find(c => c.id === group.chatId)?.name || `Chat ${group.chatId.substring(0, 6)}...`;
      
      // Spezielle Hervorhebung für neueste/älteste Information
      let chatHeader = `Aus "${chatName}"`;
      if (group.hasNewest) {
        chatHeader += " (neueste Information)";
      }
      if (group.hasOldest && !group.hasNewest) {
        chatHeader += " (erste Erwähnung)";
      }
      
      // Beginne mit Chat-Header
      contextContent += `${chatHeader}:\n`;
      
      // Füge formatierte Nachrichten hinzu
      const formattedMessages = chatMessages.map(msg => {
        const dateInfo = msg.dateInfo ? `[${msg.dateInfo}] ` : '';
        const role = msg.role === 'user' ? 'Benutzer' : 'KI';
        return `${dateInfo}${role}: ${msg.displayContent || msg.content}`;
      }).join('\n');
      
      contextContent += formattedMessages + '\n\n';
    });
    
    // Füge den Kontext zur API-Anfrage hinzu
    apiMessages.push({
      role: 'system',
      content: `Relevanter Kontext aus früheren Gesprächen:\n\n${contextContent}\n\nDies sind Ausschnitte aus vorherigen Konversationen, die für die aktuelle Frage relevant sein könnten. Die mit "neueste Information" markierten Abschnitte enthalten den aktuellsten Stand zu diesem Thema, während "erste Erwähnung" historischen Kontext bietet. Nutze diese Informationen, um eine informierte Antwort zu geben, besonders wenn der Benutzer sich auf bereits besprochene Themen bezieht.`
    });
  }
  const loadChatSessions = async (userId: string, workspaceId: string | null = null) => {
    try {
      console.log('🔄 Loading chat sessions - userId:', userId, 'workspaceId:', workspaceId);
      
      // Verwende personalWorkspaceId als Fallback, wenn keine workspaceId übergeben wird
      const targetWorkspaceId = workspaceId || personalWorkspaceId;
      
      // Build the query
      let query = supabase
        .from('chats')
        .select('id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id');
      
      // Properly handle null workspace IDs
      if (targetWorkspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Chats in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq('workspace_id', targetWorkspaceId);
      } else {
        // Nur im persönlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is('workspace_id', null).eq('user_id', userId);
      }
      
      const { data, error } = await query
        .order('last_message_timestamp', { ascending: false });
      
      if (error) {
        console.error('❌ Error loading chat sessions:', error);
        setError(`Fehler beim Laden der Chats: ${error.message}`);
        throw error;
      }
      
      if (data) {
        console.log('✅ Loaded', data.length, 'chat sessions');
        console.log('Chat data:', data); // Debug: Zeige die Chat-Daten
        
        const formattedSessions = data.map((chat: any) => ({
          id: chat.id || '', 
          name: chat.name || 'Unnamed Chat',
          created_at: chat.created_at || new Date().toISOString(),
          last_message_timestamp: chat.last_message_timestamp,
          user_id: chat.user_id, // Behalte user_id um den Ersteller anzuzeigen
          ...(chat.description && { description: chat.description }),
          project_id: chat.project_id
        }));
        
        console.log('Formatted sessions:', formattedSessions); // Debug: Zeige die formatierten Sessions
        setChatSessions(formattedSessions);
      } else {
        console.log('ℹ️ No chat sessions found');
        setChatSessions([]);
      }
    } catch (err) {
      console.error('❌ Error in loadChatSessions:', err);
      setChatSessions([]);
    }
  }
  
  const createNewChat = async () => {
    try {
      if (!user) {
        setError("Sie müssen angemeldet sein, um einen Chat zu erstellen.");
        return null;
      }
      
      // Determine the workspace ID to use - simplify this logic
      const workspaceId = rawWorkspaceId || personalWorkspaceId;

      if (!workspaceId) {
        setError("Konnte keinen gültigen Arbeitsbereich zum Erstellen des Chats finden.");
        return null;
      }

      console.log(`Creating new chat in workspace: ${workspaceId}`);
      
      // Create a new chat with a temporary name - we'll update it later
      const newChatId = uuidv4();
      const initialTitle = "Neuer Chat";
      
      // Create with retry to ensure it succeeds
      const { data: newChat, error } = await supabase
        .from("chats")
        .insert({
          id: newChatId,
          user_id: user.id,
          name: initialTitle,
          workspace_id: workspaceId,
          created_at: new Date().toISOString(),
          last_message_timestamp: new Date().toISOString()
        })
        .select()
        .single();
      
      if (error) {
        console.error(`❌ Error creating new chat: ${error.message}`);
        setError(`Fehler beim Erstellen des Chats: ${error.message}`);
        return null;
      }
      
      if (!newChat) {
        console.error('❌ No chat data returned after creation');
        setError("Fehler beim Erstellen des Chats: Keine Daten zurückgegeben");
        return null;
      }
      
      console.log(`✅ Successfully created new chat with ID: ${newChatId}`);
      
      // Set the current chat ID immediately
      setCurrentChatId(newChatId);
      
      // Wait for the database to properly register the new chat
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Reload chat sessions to update UI
      if (user) {
        await loadChatSessions(user.id, workspaceId);
      }
      
      return newChatId;
    } catch (err) {
      console.error('Error in createNewChat:', err);
      setError(`Fehler beim Erstellen des Chats: ${err instanceof Error ? err.message : 'Unbekannter Fehler'}`);
      return null;
    }
  };
  
  const loadChat = async (chatId: string) => {
    try {
      setCurrentChatId(chatId);
      
      // Try to get chat details first to confirm it exists
      const { data: chatData, error: chatError } = await supabase
        .from('chats')
        .select('id, name')
        .eq('id', chatId)
        .single();
        
      if (chatError) {
        console.error('Error fetching chat details:', chatError);
        return;
      }
      
      // Get chat messages - now only using chat_id
      const { data: messagesData, error: messagesError } = await supabase
        .from('chat_messages')
        .select('*')
        .eq('chat_id', chatId)
        .order('created_at', { ascending: true });
        
      if (messagesError) {
        console.error('Error fetching chat messages:', messagesError);
        setMessages([]);
        return;
      }
      
      if (messagesData && messagesData.length > 0) {
        // Transform to our Message format
        const transformedMessages = messagesData.map((msg: any) => ({
          id: uuidv4(),
          role: msg.role as 'user' | 'assistant' | 'system',
          content: msg.content,
          timestamp: new Date(msg.created_at),
          user_id: msg.user_id, // Store user_id from database
          sentfrom: msg.sentfrom // Store sentfrom from database
        }));
        
        setMessages(transformedMessages);
        console.log(`Loaded ${transformedMessages.length} messages for chat ${chatId}`);
        
        // Fetch usernames for all unique user_ids in messages
        const userIds = [...new Set(transformedMessages
          .filter(msg => msg.role === 'user' && msg.user_id)
          .map(msg => msg.user_id))];
          
        if (userIds.length > 0) {
          const { data: profilesData, error: profilesError } = await supabase
            .from('profiles')
            .select('id, full_name')
            .in('id', userIds);
            
          if (profilesError) {
            console.error('Error fetching user profiles:', profilesError);
          } else if (profilesData) {
            // Create a map of user_id to full_name
            const userNames: {[key: string]: string} = {};
            profilesData.forEach(profile => {
              userNames[profile.id] = profile.full_name;
            });
            setUserNamesMap(userNames);
          }
        }
      } else {
        console.log(`No messages found for chat ${chatId}`);
        setMessages([]);
      }
    } catch (err) {
      console.error('Error loading chat:', err);
      setMessages([]);
    }
  };
  
  const loadTasks = async (userId: string, workspaceId: string | null = null) => {
    try {
      let query = supabase
        .from('tasks')
        .select('*');
      
      // Workspace-Filter
      if (workspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Tasks in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq('workspace_id', workspaceId);
      } else {
        // Nur im persönlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is('workspace_id', null).eq('user_id', userId);
      }
      
      const { data, error } = await query;
      
      if (error) throw error;
      
      if (data) {
        const formattedTasks = data.map(task => ({
          ...task,
          title: task.title || task.name,
          ai_model: task.ai_model || task.preferred_model || 'gpt-4o'
        }));
        setTasks(formattedTasks);
      }
    } catch (err) {
      console.error('Error loading tasks:', err);
    }
  }
  
  const loadProjects = async (userId: string, workspaceId: string | null = null) => {
    try {
      let query = supabase
        .from('projects')
        .select('*');
      
      // Workspace-Filter
      if (workspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Projekte in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq('workspace_id', workspaceId);
      } else {
        // Nur im persönlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is('workspace_id', null).eq('user_id', userId);
      }
      
      const { data, error } = await query;
      
      if (error) throw error;
      
      if (data) {
        const formattedProjects = data.map(project => ({
          ...project,
          name: project.name || project.title,
          workspace_id: project.workspace_id || project.preferred_workspace_id || 'gpt-4o'
        }));
        setProjects(formattedProjects);
      }
    } catch (err) {
      console.error('Error loading projects:', err);
    }
  }
  
  useEffect(() => {
    const checkSession = async () => {
      try {
        setLoading(true)
        
        const { data: { session }, error: sessionError } = await supabase.auth.getSession()
        
        if (sessionError) throw new Error(`Session-Fehler: ${sessionError.message}`)
        
        if (!session) {
          setError("Keine aktive Session gefunden. Bitte melden Sie sich an.")
          return
        }
        
        setUser(session.user)
        
        // Fetch user's full name from profile
        try {
          const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .select('full_name')
            .eq('id', session.user.id)
            .single()
            
          if (profileError) {
            console.error('Error fetching user profile:', profileError)
          } else if (profileData?.full_name) {
            setUserFullName(profileData.full_name)
          }
        } catch (profileErr) {
          console.error('Error fetching user profile:', profileErr)
        }
        
        if (rawWorkspaceId) {
          localStorage.setItem("workspaceId", rawWorkspaceId);
          
          try {
            const { data: workspaceData, error: workspaceError } = await supabase
              .from("workspaces")
              .select("*")
              .eq("id", rawWorkspaceId)
              .single();
              
            if (workspaceError) {
              console.error("Error fetching workspace:", workspaceError);
            } else {
              setWorkspace(workspaceData);
            }
          } catch (err) {
            console.error("Error fetching workspace data:", err);
          }
        } else {
          localStorage.removeItem("workspaceId");
        }
        
        // Ersten vollständigen Ladevorgang durchführen - alle Chats im Workspace laden
        console.log("🔄 Initial loading ALL chats in workspace");
        if (rawWorkspaceId) {
          await loadChatSessions(session.user.id, rawWorkspaceId);
        } else {
          await loadChatSessions(session.user.id);
        }
        
        // Wichtig: Merken, dass wir die Chats bereits geladen haben
        const initialChatsLoaded = true;
        
        console.log("Loaded chat sessions:", chatSessions);
        
        // Auch Tasks laden
        try {
          if (rawWorkspaceId) {
            await loadTasks(session.user.id, rawWorkspaceId);
          } else {
            await loadTasks(session.user.id);
          }
        } catch (err) {
          console.error("Error loading tasks:", err);
        }
        
        // Lade Projekte für den aktuellen Workspace
        try {
          if (rawWorkspaceId) {
            await loadProjects(session.user.id, rawWorkspaceId);
          } else {
            await loadProjects(session.user.id);
          }
        } catch (err) {
          console.error("Error loading projects:", err);
        }
        
        if (taskId) {
            const { data: taskData, error: taskError } = await supabase
              .from('tasks')
              .select('*')
              .eq('id', taskId)
              .single();
              
            if (taskError) {
            console.error("Error fetching task:", taskError);
          } else if (taskData) {
              setSelectedTask(taskData);
            setSelectedModel(taskData.ai_model || 'gpt-4o');
            
            if (messages.length === 0) {
              const systemMessage: Message = {
                  id: uuidv4(),
                  role: 'system',
                content: taskData.system_prompt,
                timestamp: new Date()
              };
              setMessages([systemMessage]);
            }
          }
        }
        
        // WICHTIG: Wir überspringen den zweiten Ladevorgang, da wir bereits alle Chats geladen haben
        // Das verhindert, dass bereits geladene Chats durch einen gefilterten Satz ersetzt werden
        if (chatSessions.length === 0) {
          console.log("⚠️ No chats loaded yet, checking database directly");
          
          // Nur wenn keine Chats geladen wurden, direkten DB-Zugriff versuchen
          let latestChatsQuery = supabase
            .from('chats')
            .select('id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id');

          // Handle workspace filtering properly to avoid null UUID errors
          const targetWorkspaceId = rawWorkspaceId || personalWorkspaceId;
          if (targetWorkspaceId) {
            // Bei Workspace-Auswahl KEINE user_id-Filterung, um alle Workspace-Chats zu sehen
            latestChatsQuery = latestChatsQuery.eq('workspace_id', targetWorkspaceId);
          } else {
            // Nur für persönliche Chats nach user_id filtern
            latestChatsQuery = latestChatsQuery.is('workspace_id', null).eq('user_id', session.user.id);
          }

          const { data: latestChatData, error: latestChatError } = await latestChatsQuery
            .order('last_message_timestamp', { ascending: false });
            
          if (latestChatError) {
            console.error('Error fetching latest chats:', latestChatError);
          } else if (latestChatData && latestChatData.length > 0) {
            console.log("Setting chats from direct query:", latestChatData.length, "chats found");
            const formattedSessions = latestChatData.map((chat: any) => ({
              id: chat.id || '', 
              name: chat.name || 'Unnamed Chat',
              created_at: chat.created_at || new Date().toISOString(),
              project_id: chat.project_id,
              user_id: chat.user_id,
              last_message_timestamp: chat.last_message_timestamp,
              ...(chat.description && { description: chat.description })
            }));
            
            // Set state with the new value
            setChatSessions(formattedSessions);
              
            if (!currentChatId) {
              console.log("Setting current chat ID to:", latestChatData[0].id);
              setCurrentChatId(latestChatData[0].id);
              await loadChat(latestChatData[0].id);
            }
          }
        } else {
          console.log("✅ Using already loaded chats, count:", chatSessions.length);
          
          // Setze den aktuellen Chat, wenn noch keiner ausgewählt ist
          if (!currentChatId && chatSessions.length > 0) {
            console.log("Setting current chat to first available:", chatSessions[0].id);
            setCurrentChatId(chatSessions[0].id);
            await loadChat(chatSessions[0].id);
          }
        }
      } catch (err: any) {
        console.error("Chat init error:", err)
        setError(err.message)
      } finally {
        setLoading(false)
      }
    }
    
    checkSession()
  }, [])
  
  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])
  
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (modelDropdownRef.current && !modelDropdownRef.current.contains(event.target as Node)) {
        setShowModelDropdown(false)
      }
      
      if (taskDropdownRef.current && !taskDropdownRef.current.contains(event.target as Node)) {
        setShowTaskDropdown(false)
      }
      
      // Schließe Chat-Menü bei Klick außerhalb
      const chatMenuTarget = (event.target as Element)?.closest('[data-chat-menu]');
      if (chatMenuOpen && !chatMenuTarget) {
        setChatMenuOpen(null);
      }
      
      // Schließe Projekt-Menü bei Klick außerhalb
      const projectMenuTarget = (event.target as Element)?.closest('[data-project-menu]');
      if (projectMenuOpen && !projectMenuTarget) {
        setProjectMenuOpen(null);
      }
    }
    
    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [chatMenuOpen, projectMenuOpen])
  
  // Haupt-Funktion zum Senden einer Nachricht an die API
  const sendMessageToAPI = async (messages: Message[], model: string, chatId: string) => {
    console.log(`🔄 sendMessageToAPI aufgerufen mit Chat-ID: ${chatId}`);
    
    // Der aktuelle User sollte existieren, da wir authentifiziert sind
    const userId = user?.id;
    
    if (!userId) {
      console.error("❌ User ID fehlt beim Senden an API. Authentifizierungsproblem?");
      throw new Error("User ID ist erforderlich");
    }
    
    // Suche nach relevanten Nachrichten in der Vektordatenbank
    const lastUserMessage = [...messages].reverse().find(m => m.role === 'user');
    
    if (lastUserMessage) {
      console.log(`🔍 Suche nach User-weiten Kontext für User ${userId}, basierend auf: ${lastUserMessage.content}`);
      // Verwende die optimierte Funktion und übergebe die aktuelle Nachricht-ID zum Ausschließen
      const currentMessageId = lastUserMessage.id || null;
      const similarMessages = await findSimilarMessagesOptimized(userId, lastUserMessage.content, currentMessageId);
      
      // Verarbeite die gefundenen ähnlichen Nachrichten
        if (similarMessages && similarMessages.length > 0) {
        // Gruppiere Nachrichten nach Chat-ID für besseren Kontext
        const messagesByChat = new Map<string, any[]>();
        
        similarMessages.forEach(msg => {
          if (!messagesByChat.has(msg.chat_id)) {
            messagesByChat.set(msg.chat_id, []);
          }
          messagesByChat.get(msg.chat_id)?.push(msg);
        });
        
        // Sortiere Nachrichten innerhalb jedes Chats nach Erstellungsdatum
        messagesByChat.forEach((msgs, chatId) => {
          msgs.sort((a, b) => 
            new Date(a.created_at || 0).getTime() - new Date(b.created_at || 0).getTime()
          );
        });
          
          console.log(`✅ ${similarMessages.length} ähnliche Nachrichten als User-Kontext hinzugefügt`);
        
        // Log für Debugging
        Array.from(messagesByChat.entries()).forEach(([chatId, msgs]) => {
          msgs.forEach((msg: any) => {
            const datePrefix = msg.dateInfo ? `(vom ${msg.dateInfo}) ` : '';
            const contextPrefix = msg.isContext ? '[Kontext] ' : '';
            console.log(`   - [Chat ${chatId.substring(0, 4)}...] ${contextPrefix}${datePrefix}${msg.displayContent.substring(0, 50)}... (Ähnlichkeit: ${msg.similarity.toFixed(2)})`);
          });
        });
        
        // Build the context for the API call
        const apiMessages = [];
        
        // Add system message
        apiMessages.push({
          role: 'system',
          content: 'Du bist ein digitaler AI-Mitarbeiter von EcomTask. Du unterstützt den User professionell und freundlich bei der Arbeit an individuellen Aufgaben und Projekten.'
        });
        
        // Add task-specific system prompt if available
        if (selectedTask?.system_prompt) {
          apiMessages.push({
            role: 'system',
            content: selectedTask.system_prompt
          });
        }
        
        // Add context from similar messages, preserving conversation flow
        if (similarMessages.length > 0) {
          // Gruppiere Nachrichten nach Chat-ID
          const chatGroups = new Map<string, any[]>();
          
          // Schritt 1: Gruppiere Nachrichten nach Chats
          similarMessages.forEach((msg: any) => {
            if (!chatGroups.has(msg.chat_id)) {
              chatGroups.set(msg.chat_id, []);
            }
            chatGroups.get(msg.chat_id)?.push(msg);
          });
          
          // Sortiere Nachrichten innerhalb der Gruppen nach Erstellungszeit
          chatGroups.forEach((messages, _) => {
            messages.sort((a, b) => 
              new Date(a.created_at || 0).getTime() - new Date(b.created_at || 0).getTime()
            );
          });
          
          // Schritt 2: Berechne Relevanz-Score für jede Gruppe
          const scoredGroups = Array.from(chatGroups.entries()).map(([chatId, messages]) => {
            // Basisähnlichkeit: Die durchschnittliche Ähnlichkeit der Top-2 Nachrichten
            const topSimilarities = messages
              .filter(msg => !msg.isContext) // Nur primäre Treffer, keine Kontext-Nachrichten
              .map(msg => msg.similarity || 0)
              .sort((a, b) => b - a)
              .slice(0, 2);
            
            const avgTopSimilarity = topSimilarities.length > 0 
              ? topSimilarities.reduce((sum, sim) => sum + sim, 0) / topSimilarities.length
              : 0;
            
            // Qualität der Konversation: Bewerte Gespräche mit Rollenwechseln höher
            let conversationQuality = 0;
            let roleChanges = 0;
            
            for (let i = 1; i < messages.length; i++) {
              if (messages[i].role !== messages[i-1].role) {
                roleChanges++;
              }
            }
            
            // Normalisiere auf einen Wert zwischen 0 und 0.15
            conversationQuality = Math.min(0.15, roleChanges * 0.05);
            
            // Zeitliche Relevanz: Älteste und neueste Nachrichten bevorzugen
            // Bestimme den Zeitbereich der Nachrichten
            const datesWithInfo = messages
              .filter(msg => msg.dateInfo)
              .map(msg => new Date(msg.dateInfo).getTime());
            
            let timeRelevanceBonus = 0;
            
            if (datesWithInfo.length > 0) {
              const sortedDates = [...datesWithInfo].sort((a, b) => a - b);
              const oldestDate = sortedDates[0];
              const newestDate = sortedDates[sortedDates.length - 1];
              const now = new Date().getTime();
              
              // Bestimme, ob diese Gruppe die älteste oder neueste Information enthält
              const isOldestInfo = messages.some(msg => 
                msg.dateInfo && new Date(msg.dateInfo).getTime() === oldestDate
              );
              
              const isNewestInfo = messages.some(msg => 
                msg.dateInfo && new Date(msg.dateInfo).getTime() === newestDate
              );
              
              // Neueste Information erhält einen starken Bonus
              if (isNewestInfo) {
                const daysDiff = Math.floor((now - newestDate) / (1000 * 3600 * 24));
                timeRelevanceBonus += 0.3 * Math.max(0, 1 - (daysDiff / 14)); // Neuere Nachrichten innerhalb von 14 Tagen bekommen bis zu +0.3
              }
              
              // Älteste Information erhält auch einen Bonus
              if (isOldestInfo) {
                timeRelevanceBonus += 0.2; // Feste +0.2 für die erste Erwähnung eines Themas
              }
            }
            
            // Kombiniere alle Faktoren zum Gesamt-Score
            const score = avgTopSimilarity + conversationQuality + timeRelevanceBonus;
            
            return { chatId, messages, score, hasNewest: timeRelevanceBonus > 0.2, hasOldest: timeRelevanceBonus >= 0.2 };
          });
          
          // Sortiere Gruppen nach Score absteigend
          scoredGroups.sort((a, b) => b.score - a.score);
          
          // Wähle die Top-3 relevantesten Gruppen
          const topGroups = scoredGroups.slice(0, 3);
          
          console.log(`🧠 Ausgewählte Chat-Gruppen für Kontext: ${topGroups.length}`);
          topGroups.forEach(group => {
            const topSimilarityMsg = group.messages
              .filter(msg => !msg.isContext)
              .reduce((max, msg) => msg.similarity > (max?.similarity || 0) ? msg : max, null);
            
            console.log(`  • Chat ${group.chatId.substring(0, 6)}... (Score: ${group.score.toFixed(2)}) mit ${group.messages.length} Nachrichten`);
            if (topSimilarityMsg) {
              console.log(`    Beste Übereinstimmung: "${(topSimilarityMsg.displayContent || '').substring(0, 40)}..." (${topSimilarityMsg.similarity.toFixed(2)})`);
            }
          });
          
          // Formatiere Nachrichten für den Kontext
          let contextContent = '';
          
          topGroups.forEach(group => {
            const chatMessages = group.messages;
            
            // Extrahiere den Chat-Namen wenn möglich
            const chatName = chatSessions.find(c => c.id === group.chatId)?.name || `Chat ${group.chatId.substring(0, 6)}...`;
            
            // Beginne mit Chat-Header
            contextContent += `Aus "${chatName}":\n`;
            
            // Füge formatierte Nachrichten hinzu
            const formattedMessages = chatMessages.map(msg => {
              const dateInfo = msg.dateInfo ? `[${msg.dateInfo}] ` : '';
              const role = msg.role === 'user' ? 'Benutzer' : 'KI';
              return `${dateInfo}${role}: ${msg.displayContent || msg.content}`;
            }).join('\n');
          
            contextContent += formattedMessages + '\n\n';
          });
          
          // Füge den Kontext zur API-Anfrage hinzu
          apiMessages.push({
            role: 'system',
            content: `Relevanter Kontext aus früheren Gesprächen:\n\n${contextContent}\n\nDies sind Ausschnitte aus vorherigen Konversationen, die für die aktuelle Frage relevant sein könnten. Nutze diese Informationen, um eine informierte Antwort zu geben, besonders wenn der Benutzer sich auf bereits besprochene Themen bezieht.`
          });
        }
        
        // Add the actual conversation messages
        messages.forEach(msg => {
          if (msg.role !== 'system') { // Skip system messages as we already added them above
            apiMessages.push({
              role: msg.role,
              content: msg.content
            });
          }
        });
        
        console.log(`📩 Sende an API: ${messages.filter(m => m.role !== 'system').length} Nachrichten, davon ${apiMessages.length - messages.filter(m => m.role !== 'system').length} Kontextnachrichten`);
        
        // Call API
        const apiUrl = `/api/chat?model=${encodeURIComponent(model)}&chatId=${encodeURIComponent(chatId)}`;
        const apiResponse = await fetch(apiUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            messages: apiMessages,
          }),
        });
        
        if (!apiResponse.ok) {
          throw new Error(`API responded with ${apiResponse.status}`);
        }
        
        const data = await apiResponse.json();
        return data;
        } else {
        console.log("ℹ️ Keine ähnlichen Nachrichten gefunden.");
      }
    }
    
    // Proceed without context if no similar messages or no last user message
    const apiMessages = messages.map(m => ({
      role: m.role,
      content: m.content
    }));
    
    console.log(`📩 Sende an API: ${apiMessages.length} Nachrichten ohne zusätzlichen Kontext`);
    
    const apiUrl = `/api/chat?model=${encodeURIComponent(model)}&chatId=${encodeURIComponent(chatId)}`;
    const apiResponse = await fetch(apiUrl, {
      method: 'POST',
        headers: {
        'Content-Type': 'application/json',
        },
        body: JSON.stringify({
        messages: apiMessages,
      }),
    });
    
    if (!apiResponse.ok) {
      throw new Error(`API responded with ${apiResponse.status}`);
    }
    
    const data = await apiResponse.json();
    return data;
  };
  
  const handleTypewriterComplete = (messageId: string) => {
    const updatedMessages = messages.map(m => 
      m.id === messageId ? { ...m, isTypewriting: false } : m
    )
    setMessages(updatedMessages)
    setTypingMessageId(null)
  }
  
  const handleCreateTask = async () => {
    if (!newTaskName.trim()) return;
    
    try {
      setLoading(true);
      
      const workspaceContext = rawWorkspaceId || null;
      
      const { data, error } = await supabase
        .from('tasks')
        .insert({
          title: newTaskName,
          description: newTaskDescription,
          system_prompt: newTaskSystemPrompt,
          ai_model: newTaskModel,
          status: 'todo',
          priority: 'medium',
          user_id: user.id,
          workspace_id: workspaceContext
        })
        .select();

      if (error) throw error;

      await loadTasks(user.id, workspaceContext);
      
      setShowTaskModal(false);
      setNewTaskName('');
      setNewTaskDescription('');
      setNewTaskSystemPrompt('');
      setNewTaskModel('gpt-4o');
      
    } catch (err) {
      console.error('Error creating task:', err);
    } finally {
      setLoading(false);
    }
  };
  
  const handleCreateProject = async () => {
    if (!newProjectName.trim()) return;

    try {
      setLoading(true);

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;

      // ---> START DEBUG LOG <---
      console.log("--- Creating Project --- ");
      console.log("User ID to send:", user?.id);
      console.log("Raw Workspace ID from URL:", rawWorkspaceId);
      console.log("Personal Workspace ID state:", personalWorkspaceId);
      console.log("Workspace Context to send:", workspaceContext);
      // ---> END DEBUG LOG <---

      // ---> ADDED AUTH CHECK <---
      const { data: authData, error: authError } = await supabase.auth.getSession();
      console.log("--- Auth Check Before Insert ---");
      console.log("Current Session:", authData?.session);
      console.log("Session User ID:", authData?.session?.user?.id);
      console.log("Auth Error:", authError);
      if (authError || !authData?.session) {
          console.error("CRITICAL: No valid session before insert!");
          // Optionally: Prevent the insert or show an error to the user
          // return;
      }
      // ---> END AUTH CHECK <---

      // ---> ADDED DIAGNOSTIC FUNCTION <---
      // This immediately runs when you click "Create Project" in the UI
      // It helps diagnose why the workspace membership check fails
      console.log("--- Running Diagnostic Function ---");
      const diagResult = await supabase.rpc('diagnose_workspace_membership', {
        p_user_id: user.id,
        p_workspace_id: workspaceContext
      });
      console.log("Diagnosis Result:", diagResult);
      // Explicit logging of the important diagnostic data
      console.log("MEMBERSHIP DATA:", JSON.stringify(diagResult.data, null, 2));
      if (diagResult.data) {
        console.log("User ID Input:", diagResult.data.user_id_input);
        console.log("Workspace ID Input:", diagResult.data.workspace_id_input);
        console.log("Membership Exists:", diagResult.data.membership_exists);
        console.log("Membership Count:", diagResult.data.membership_count);
        console.log("All User Workspaces:", diagResult.data.all_user_workspaces);
        console.log("All Workspace Members:", diagResult.data.all_workspace_members);
      }
      // ---> END DIAGNOSTIC FUNCTION <---

      // Use the database function instead of direct table access
      // This bypasses RLS issues while maintaining security checks in the function
      const { data, error } = await supabase
        .rpc('create_project', {
          p_name: newProjectName,
          p_description: newProjectDescription,
          p_user_id: user.id,
          p_workspace_id: workspaceContext,
          p_color: '#4c4cff',
          p_status: 'active'
        });

      if (error) throw error;

      await loadProjects(user.id, workspaceContext);
      setShowProjectModal(false);
      setNewProjectName('');
      setNewProjectDescription('');

    } catch (err) {
      console.error('Error creating project:', err);
    } finally {
      setLoading(false);
    }
  }
  
  // Generate a chat name from the first user message
  const generateChatName = (message: string): string => {
    // Split the message into words
    const words = message.trim().split(/\s+/);
    
    // Get up to the first 3 words
    const firstThreeWords = words.slice(0, 3).join(' ');
    
    // If the result is too short, use "Neuer Chat"
    return firstThreeWords.length >= 3 ? firstThreeWords : "Neuer Chat";
  };
  
  // Modifiziere den useEffect für Task-Wechsel
  useEffect(() => {
    // Only perform task change operations if no message update is pending
    // And ensure at least 500ms has passed since the last message update
    const timeSinceLastUpdate = Date.now() - lastMessageUpdate;
    if (messageUpdatePending || timeSinceLastUpdate < 500) {
      console.log("Message update in progress or too recent, deferring task change handling");
      return;
    }
    
    const handleTaskOrModelChange = async () => {
      // Prüfen, ob es sich um einen Task- oder Modellwechsel handelt
      const isTaskChange = selectedTask?.id !== previousSelectedTask?.id;
      // const isModelChange = selectedModel !== previousSelectedModel && !selectedTask;
      
      // Run this logic ONLY on task change, not on simple model selection
      if (isTaskChange && messages.length > 0) {
        // Wenn eine Task oder ein Modell gewechselt wurde und es Nachrichten gibt
        
        console.log("Task wurde gewechselt, erstelle Zusammenfassung...");
        
        try {
          // Prüfe, ob bereits eine Zusammenfassung im Chat existiert
          const lastSummaryMessage = [...messages]
            .reverse()
            .find(msg => 
              msg.role === 'assistant' && 
              (msg.content.includes('Chat-Zusammenfassung') || 
               msg.content.includes('Hauptpunkte:') || 
               msg.content.includes('Zusammenfassung des Chats'))
            );
          
          let summary: string;
          
          if (lastSummaryMessage) {
            // Verwende die vorhandene Zusammenfassung
            console.log("Verwende vorhandene Zusammenfassung");
            summary = lastSummaryMessage.content;
          } else {
            // Erstelle eine neue Zusammenfassung, da keine vorhanden ist
            console.log("Erstelle neue Zusammenfassung für Task-Wechsel");
            summary = await generateChatSummary(messages);
          }
          
          if (summary) {
            // Erstelle eine neue System-Nachricht mit der Zusammenfassung
            const summarySystemMessage: Message = {
              id: uuidv4(),
              role: 'system',
              content: `Zusammenfassung des bisherigen Gesprächs: ${summary}

${selectedTask ? selectedTask.system_prompt : "Fahre mit dem Gespräch fort, basierend auf dieser Zusammenfassung."}`,
              timestamp: new Date()
            };
            
            // Entferne alle bisherigen System-Nachrichten
            const filteredMessages = messages.filter(m => m.role !== 'system');
            
            // Füge die neue System-Nachricht am Anfang hinzu
            setMessages([summarySystemMessage, ...filteredMessages]);
            
            console.log("Zusammenfassung wurde als System-Nachricht hinzugefügt.");
            
            // Task-switching notification message is REMOVED
          }
        } catch (error) {
          console.error("Error in task change handling:", error);
        } finally {
          // Always set isTaskSwitching to false when complete
          setIsTaskSwitching(false);
        }
      } else {
        // If there's no task change or no messages, just reset the switching state
        setIsTaskSwitching(false);
      }
      
      // Aktuelle Task und Modell für den nächsten Vergleich speichern
      setPreviousSelectedTask(selectedTask);
      setPreviousSelectedModel(selectedModel);
    };
    
    handleTaskOrModelChange();
  }, [selectedTask, selectedModel, messages, messageUpdatePending, previousSelectedTask, previousSelectedModel, lastMessageUpdate]);
  
  // Add this function to sync messages with the database when needed
  const syncMessagesWithDatabase = async (chatId: string) => {
    if (!chatId) return;
    
    try {
      console.log('Syncing messages with database for chat:', chatId);
      const { data, error } = await supabase
        .from("chat_messages")
        .select('*')
        .eq('chat_id', chatId)
        .order('created_at', { ascending: true });
        
      if (error) {
        console.error('Error syncing messages:', error);
        return;
      }
      
      if (data) {
        // Convert database messages to app message format
        const formattedMessages: Message[] = data.map(dbMsg => ({
          id: dbMsg.id || uuidv4(),
          role: dbMsg.role as 'user' | 'assistant' | 'system',
          content: dbMsg.content,
          timestamp: new Date(dbMsg.created_at)
        }));
        
        console.log(`Synced ${formattedMessages.length} messages from database`);
        setMessages(formattedMessages);
      }
    } catch (error) {
      console.error('Error in syncMessagesWithDatabase:', error);
    }
  };

  // Modify handleSendMessage to optionally include web search results
  const handleSendMessage = async (message: string, includeWebSearch: boolean = false) => {
    if (message.trim().length === 0) return;
    if (isTyping || messageUpdatePending || isTaskSwitching) return;

    const userMessageId = uuidv4();
    const newMessage: Message = {
      id: userMessageId,
      role: 'user',
      content: message,
      timestamp: new Date(),
      user_id: user?.id,
      sentfrom: userFullName
    };

    console.log("Creating new message with user_id:", user?.id);

    try {
      // Prevent task switching effects during message sending
      setMessageUpdatePending(true);
      setLastMessageUpdate(Date.now());
      
      // Create the new array *before* setting state
      const newMessagesArray = [...messages, newMessage];
      
      // Add user message to state immediately for better UX
      setMessages(newMessagesArray); // Use the new array
      setInputValue(''); // Eingabefeld leeren
      
      // Show typing indicator
      setIsTyping(true);
      
      // If web search is requested, perform it before sending to API
      let webSearchResults = null;
      if (includeWebSearch) {
        setIsSearching(true);
        try {
          webSearchResults = await performSerpApiSearch(message);
          console.log("Web search results:", webSearchResults.length);
        } catch (searchError) {
          console.error("Error during web search:", searchError);
        } finally {
          setIsSearching(false);
        }
      }
      
      let chatIdToUse = currentChatId;
      
      // If no current chat exists, create a new one before proceeding
      if (!chatIdToUse) {
        console.log('No current chat, creating new one before sending message...');
        chatIdToUse = await createNewChat();
        if (!chatIdToUse) {
          throw new Error('Failed to create a new chat');
        }
        console.log(`Successfully created new chat with ID: ${chatIdToUse}`);
      }
      
      // Save the message to the database immediately, with retries
      console.log(`Saving message to chat ID: ${chatIdToUse}`);
      
      // For embedding only, not stored in the displayed message
      const currentDate = new Date().toISOString().split('T')[0]; 
      
      const { data: messageData, error: messageError } = await retryOperation(async () => {
        return await supabase
          .from("chat_messages")
          .insert({
            chat_id: chatIdToUse,
            role: 'user',
            content: message, // Store original message without date
            user_id: user?.id,
            sentfrom: userFullName,
            created_at: newMessage.timestamp.toISOString()
          })
          .select();
      }, 3, 1000);

        if (messageError) {
          console.error('❌ Error saving message:', messageError);
        // Keep the message in UI state but log the error
        } else {
          console.log('✅ Message saved successfully to database', messageData);
          
          // Verwende die tatsächliche DB-ID für das Embedding
          if (messageData && messageData.length > 0) {
            const dbMessage = {
              ...newMessage,
              id: messageData[0].id // Überschreibe die lokale ID mit der DB-ID
            };
            await createEmbedding(dbMessage, chatIdToUse, rawWorkspaceId || null);
          }
          
          // Generate chat title for new chats
          if (!currentChatId && chatIdToUse) {
            // Set current chat ID so we maintain context
            setCurrentChatId(chatIdToUse);
            // Generate title asynchronously
            generateAndSetChatTitle(chatIdToUse, message);
          }
          
          // Reload chat sessions to update UI
            if (user) {
              await loadChatSessions(user.id, rawWorkspaceId || null);
          }
        }
        
        // Now get the AI response
        try {
          // Prepare messages for the API with the exact required order
          const apiMessages: Message[] = [];
          
          // 1. Add the fixed EcomTask AI system message as the first message
          apiMessages.push({
            role: 'system',
            content: 'Du bist ein digitaler AI-Mitarbeiter von EcomTask. Du unterstützt den User professionell und freundlich bei der Arbeit an individuellen Aufgaben und Projekten.',
            id: uuidv4(),
            timestamp: new Date()
          });
          
          // 2. Add task-specific system prompt if available
          if (selectedTask?.system_prompt) {
            apiMessages.push({
              role: 'system',
              content: selectedTask.system_prompt,
              id: uuidv4(),
              timestamp: new Date()
            });
          }
          
          // 3. Add additional context (like web search results) if available
          if (webSearchResults && webSearchResults.length > 0) {
            const searchResultText = formatSearchResultsForAI(webSearchResults);
            apiMessages.push({
              role: 'system',
              content: `Web search results for "${message}":\n\n${searchResultText}\n\nUse these results to inform your response.`,
              id: uuidv4(),
              timestamp: new Date()
            });
          }
          
          // 4. Add the user message last
          apiMessages.push({
            role: 'user',
            content: message,
            id: newMessage.id,
            timestamp: newMessage.timestamp
          });

          // Call the API with the properly structured messages
          const modelToUse = selectedTask?.ai_model || selectedModel;
          
          // Immer die aktuelle Chat-ID verwenden, die jetzt gesetzt sein sollte
          console.log("📣 Sende Nachricht an API mit Chat-ID:", chatIdToUse);
             // Übergebe das *gesamte* newMessagesArray (den aktuellen Verlauf) an sendMessageToAPI
   console.log("🚀 Sending complete history to sendMessageToAPI (handleSendMessage)");
   const response = await sendMessageToAPI(newMessagesArray, modelToUse, chatIdToUse);
          
          // Create assistant message
          const assistantMessageId = uuidv4();
          const assistantMessage: Message = {
            id: assistantMessageId,
            role: 'assistant',
            content: response.content,
            timestamp: new Date(),
            isTypewriting: true
          };
          
          // Update messages with AI response
          setMessages(prevMessages => [...prevMessages, assistantMessage]);
          setTypingMessageId(assistantMessageId);
          
          // Save assistant message to database
          if (chatIdToUse) {
            const { data: aiMessageData, error: aiMessageError } = await supabase
              .from("chat_messages")
              .insert({
                chat_id: chatIdToUse,
                role: 'assistant',
                content: assistantMessage.content, // Store original content without date
                user_id: user?.id,
                sentfrom: "KI-Assistent", // Standard KI-Name
                created_at: assistantMessage.timestamp.toISOString()
              })
              .select();
              
            if (aiMessageError) {
              console.error('❌ Error saving AI message:', aiMessageError);
            } else {
              console.log('✅ AI message saved to database', aiMessageData);
              
              // Create embedding for the assistant message
              if (aiMessageData && aiMessageData.length > 0) {
                const dbAssistantMessage = {
                  ...assistantMessage,
                  id: aiMessageData[0].id // Überschreibe die lokale ID mit der DB-ID
                };
                await createEmbedding(dbAssistantMessage, chatIdToUse, rawWorkspaceId || null);
              }
              
              // Reload chat sessions to update last_message_timestamp
              if (user) {
                await loadChatSessions(user.id, rawWorkspaceId || null);
              }
            }
          }
        } catch (apiError) {
          console.error("Error getting AI response:", apiError);
          // Add error message to the chat
          const errorMessage: Message = {
              id: uuidv4(),
              role: 'assistant',
            content: "Es ist ein Fehler bei der Kommunikation mit der KI aufgetreten. Bitte versuchen Sie es erneut.",
              timestamp: new Date()
          };
          setMessages(prevMessages => [...prevMessages, errorMessage]);
        }
      } catch (error) {
        console.error("Error sending message:", error);
        setError(`Fehler beim Senden der Nachricht: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`);
      } finally {
        setIsTyping(false);
        setMessageUpdatePending(false);
        // Update the timestamp again to ensure task changes wait
        setLastMessageUpdate(Date.now());
      }
  }
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    handleSendMessage(inputValue);
  };
  
  const getModelLabel = (modelId: string | null): string => {
    // Map actual model IDs back to friendly names
    switch(modelId) {
      // Direkte Namen (keine Umwandlung nötig)
      case 'Basic': 
        return 'Basic';
      case 'Fast':
        return 'Fast';
      case 'Reason':
        return 'Reason';
      case 'Reason+':
        return 'Reason+';
      
      // Alte technische IDs für Abwärtskompatibilität
      case 'gpt-4o-2024-11-20': 
        return 'Basic';
      case 'gpt-4o-mini-2024-07-18':
        return 'Fast';
      case 'o3-mini-2025-01-31':
        return 'Reason';
      case 'gpt-4.5-preview-2025-02-27':
        return 'Reason+';
      
      // Sehr alte IDs für Abwärtskompatibilität
      case 'gpt-4o': 
        return 'Basic';
      case 'gpt-4o-mini':
        return 'Fast';
      case 'gpt-4-vision-preview':
        return 'Reason';
      default:
        // Standardwert
        return modelId || 'Basic';
    }
  };
  
  // Function to copy message content to clipboard
  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text)
      .then(() => {
        // Could show a toast notification here
        console.log('Copied to clipboard');
      })
      .catch(err => {
        console.error('Failed to copy: ', err);
      });
  };
  
  // Function to start editing a user message
  const startEditMessage = (message: Message) => {
    setEditingMessageId(message.id);
    setEditingContent(message.content);
  };
  
  // Function to cancel editing
  const cancelEditMessage = () => {
    setEditingMessageId(null);
    setEditingContent('');
  };
  
  // Function to save the edited message and resubmit
  const handleSaveEdit = async () => {
    if (!editingMessageId || !editingContent.trim()) return;
    
    const messageIndex = messages.findIndex(m => m.id === editingMessageId);
    if (messageIndex === -1) return;
    
    // Get the original message
    const originalMessage = messages[messageIndex];
    
    // Keep messages up to but NOT including the one being edited
    const messagesToKeep = messages.slice(0, messageIndex);
    
    // Reset editing state
    const editedContent = editingContent.trim(); // Store content before resetting state
    setEditingMessageId(null);
    setEditingContent('');
    
    console.log('Starting message edit process, deleting original and subsequent messages...');
    
    // Create a timestamp for the edited message that preserves the original position
    const editedMessageTimestamp = new Date(originalMessage.timestamp);
    editedMessageTimestamp.setMilliseconds(editedMessageTimestamp.getMilliseconds() + 1);
    
    // Create a new user message with the edited content
    const newUserMessageId = uuidv4();
    const userMessage: Message = {
      id: newUserMessageId,
      role: 'user',
      content: editedContent,
      timestamp: editedMessageTimestamp
    };
    
    // Set messages state directly with just the kept messages and edited message
    setMessages([...messagesToKeep, userMessage]);
    
    // Create timestamp for AI response that's 1ms after the edited message
    const aiResponseTimestamp = new Date(editedMessageTimestamp);
    aiResponseTimestamp.setMilliseconds(aiResponseTimestamp.getMilliseconds() + 1);
    
    // Delete all subsequent messages from database using a stored procedure
    if (currentChatId && user) {
      try {
        console.log('Attempting deletion via RPC force_delete_messages for chat ID', currentChatId);
        
        // STEP 1: Fetch message IDs that need to be deleted
        const { data: messagesToDelete, error: fetchError } = await supabase
          .from('chat_messages')
          .select('id') // Only need IDs
          .eq('chat_id', currentChatId)
          .gte('created_at', originalMessage.timestamp.toISOString());
        
        if (fetchError) {
          console.error('Error fetching message IDs to delete:', fetchError);
          throw new Error('Failed to fetch messages for deletion');
        }
        
        if (messagesToDelete && messagesToDelete.length > 0) {
          const messageIds = messagesToDelete.map(msg => msg.id);
          console.log(`Found ${messageIds.length} message IDs to delete:`, messageIds);
          
          // STEP 2: Call the stored procedure via RPC
          const { data: deletedCount, error: rpcError } = await supabase.rpc(
            'force_delete_messages',
            { message_ids: messageIds } // Übergabe der IDs als benanntes Argument
          );
          
          if (rpcError) {
            console.error('RPC call to force_delete_messages failed:', rpcError);
            // Hier könnten wir noch Fallback-Methoden einbauen, aber lassen wir es erstmal weg,
            // um zu sehen, ob die Hauptmethode funktioniert.
          } else {
            console.log(`Stored procedure force_delete_messages reported ${deletedCount} messages deleted.`);
          }
          
          // STEP 3: Verify deletion worked (wait a moment first)
          await new Promise(resolve => setTimeout(resolve, 1000)); 
          
          const { data: remainingMessages, error: verifyError } = await supabase
            .from('chat_messages')
            .select('id')
            .eq('chat_id', currentChatId)
            .gte('created_at', originalMessage.timestamp.toISOString());
            
          if (verifyError) {
            console.error('Error verifying message deletion:', verifyError);
          } else if (remainingMessages && remainingMessages.length > 0) {
            console.error(`CRITICAL ERROR (even with RPC): ${remainingMessages.length} messages still remain. Problem might be deeper.`);
            console.log('Remaining message IDs:', remainingMessages.map(m => m.id));
          } else {
            console.log('Verification successful: All messages seem to be properly deleted from database via RPC.');
          }
        } else {
          console.log('No messages found that match the deletion criteria');
        }
      } catch (error) {
        console.error('Error during RPC message deletion process:', error);
      }
    } else {
      console.error("Cannot delete messages: currentChatId or user object is missing.");
    }
    
    // Now insert the new edited message
    if (currentChatId) {
      try {
        const { error: insertError } = await supabase
          .from("chat_messages")
          .insert({
            chat_id: currentChatId,
            role: 'user',
            content: editedContent,
            user_id: user?.id, // Make sure user_id is included in database insert
            created_at: editedMessageTimestamp.toISOString()
          });
        
        if (insertError) {
          console.error('Error saving edited message:', insertError);
        } else {
          console.log('Edited message saved to database successfully with timestamp:', editedMessageTimestamp.toISOString());
          
          // Neu: Lade die Chat-Liste neu, um die Sortierung zu aktualisieren
          if (user) {
            await loadChatSessions(user.id, rawWorkspaceId || null);
          }
        }
      } catch (insertErr) {
        console.error('Error during message insertion:', insertErr);
      }
    }
    
    // Now get the AI response for the edited message
    try {
      // First prepare the messages for the API
      const apiMessages = [...messagesToKeep, userMessage].map(m => ({
        role: m.role,
        content: m.content,
        id: m.id,
        timestamp: m.timestamp
      }));
      
      // Ensure system messages come first
      apiMessages.sort((a, b) => {
        if (a.role === 'system') return -1;
        if (b.role === 'system') return 1;
        return 0;
      });
      
      // Set typing state
      setIsTyping(true);
      
      // Call API
      const modelToUse = selectedTask?.ai_model || selectedModel;
         // Übergebe das *gesamte* currentMessages Array (den aktuellen Verlauf) an sendMessageToAPI
   console.log("🚀 Sending complete history to sendMessageToAPI (handleSaveEdit)");
   const response = await sendMessageToAPI(messages, modelToUse, currentChatId);      
      // Create assistant message with sequential timestamp
      const assistantMessageId = uuidv4();
      const assistantMessage: Message = {
        id: assistantMessageId,
        role: 'assistant',
        content: response.content,
        timestamp: new Date(),
        isTypewriting: true
      };
      
      // Update messages with the AI response - use the current state to avoid race conditions
      setMessages(currentMessages => [...currentMessages, assistantMessage]);
      setTypingMessageId(assistantMessageId);
      
      // Save assistant message to database
      if (currentChatId) {
        try {
          console.log('💬 Saving AI response for chat:', currentChatId);
          
          // Add the missing currentDate definition
          const currentDate = new Date().toISOString().split('T')[0]; // Format: YYYY-MM-DD
          
          const { error: aiInsertError } = await supabase
            .from("chat_messages")
            .insert({
              chat_id: currentChatId,
              role: 'assistant',
              content: `[Datum: ${currentDate}]\n${assistantMessage.content}`, // Add date to AI messages too
              user_id: user?.id, // Make sure user_id is included in database insert
              created_at: aiResponseTimestamp.toISOString()
            });

          if (aiInsertError) {
            console.error('❌ Error saving AI response:', aiInsertError);
          } else {
            console.log('✅ AI response saved, reloading chat sessions...');
            // Neu: Lade die Chat-Liste neu, um die Sortierung zu aktualisieren
            if (user) {
              await loadChatSessions(user.id, rawWorkspaceId || null);
            }
          }
        } catch (aiInsertErr) {
          console.error('❌ Error during AI message insertion:', aiInsertErr);
        }
      }
    } catch (error) {
      console.error("API request failed:", error);
      // Add error message
      setMessages([
        ...messagesToKeep, 
        userMessage,
        {
          id: uuidv4(),
          role: 'assistant',
          content: "Sorry, es ist ein Fehler aufgetreten. Bitte versuche es erneut.",
          timestamp: new Date()
        }
      ]);
    } finally {
      setIsTyping(false);
    }
  };

  // Updated function to regenerate AI response
  const regenerateResponse = async (aiMessageId: string) => {
    setTypingMessageId(null);
    
    const aiMessageIndex = messages.findIndex(m => m.id === aiMessageId);
    if (aiMessageIndex === -1 || aiMessageIndex === 0) return; // Cannot regenerate if it's the first message or not found
    
    const userMessageIndex = aiMessageIndex - 1;
    if (messages[userMessageIndex].role !== 'user') return; // Should be preceded by a user message
    
    const userMessageToResend = messages[userMessageIndex];
    
    // Keep messages up to the preceding user message
    const messagesToKeep = messages.slice(0, userMessageIndex + 1);
    
    // Update UI state
      setMessages(messagesToKeep);
    
    // Delete the AI message and subsequent ones from DB
    if (currentChatId) {
      supabase
        .from('chat_messages')
        .delete()
        .eq('chat_id', currentChatId)
        .gte('created_at', messages[aiMessageIndex].timestamp.toISOString())
        .then(({ error }) => {
          if (error) {
            console.error('Error deleting messages for regeneration:', error);
          } else {
            console.log('Messages deleted for regeneration from DB');
          }
        });
    }
    
    // Resend the user message that led to this AI response
    await handleSendMessage(userMessageToResend.content);
  };
  
  // Add another function to retry failed database operations with logging
  const retryOperation = async (operation: () => Promise<any>, maxRetries = 3, delay = 500) => {
    let lastError;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
    } catch (err) {
        lastError = err;
        console.error(`Operation failed (attempt ${attempt}/${maxRetries}):`, err);
        
        if (attempt < maxRetries) {
          console.log(`Retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2; // Exponential backoff
        }
      }
    }
    throw lastError;
  };
  
  // Simplified deleteChat function that works with the consolidated database structure
  const deleteChat = async (chatId: string) => {
    try {
      // Close any open menus
      setChatMenuOpen(null)
      
      console.log('Starting delete process for chat:', chatId)
      
      // With the ON DELETE CASCADE constraint, we only need to delete the chat
      // All associated messages will be automatically deleted
      const { error } = await supabase
        .from('chats')
        .delete()
        .eq('id', chatId)
        .eq('user_id', user.id)

      if (error) {
        console.error('Error deleting chat:', error)
        return
      }

      console.log('Chat and all associated messages deleted successfully')
      
      // Remove from state
      setChatSessions(prevSessions => prevSessions.filter(chat => chat.id !== chatId))
      
      // If the deleted chat was the current one, load another chat
      if (currentChatId === chatId) {
        // Get a fresh list of remaining chats after removing the deleted one
        const remainingChats = [...chatSessions].filter(chat => chat.id !== chatId);
        
        if (remainingChats.length > 0) {
          const nextChatId = remainingChats[0].id;
          console.log('Switching to next chat:', nextChatId);
          setCurrentChatId(nextChatId);
    } else {
          console.log('No chats remaining, clearing state');
          setCurrentChatId(null);
          setMessages([]);
        }
      }
      
      // Reload chats from database to ensure we have fresh data
      await loadChatSessions(user.id, rawWorkspaceId || null);
      
      console.log('Chat successfully deleted:', chatId);
    } catch (err) {
      console.error('Error in deleteChat:', err)
    }
  }
  
  // Add function to open rename modal
  const openRenameModal = (chat: ChatSession) => {
    setChatToRename(chat)
    setNewChatName(chat.name)
    setRenameModalOpen(true)
    setChatMenuOpen(null)
  }
  
  // Start inline edit for a chat
  const startInlineEdit = (chat: ChatSession, e: React.MouseEvent) => {
    e.stopPropagation() // Verhindere Bubble-Up zum Button
    setEditingChatId(chat.id)
    setNewChatName(chat.name)
    setChatMenuOpen(null)
  }
  
  // Handle focus loss on inline edit
  const handleInlineEditBlur = async () => {
    if (editingChatId && newChatName.trim()) {
      // Finde den Chat
      const chatToUpdate = chatSessions.find(chat => chat.id === editingChatId)
      if (chatToUpdate) {
        try {
          // Update in DB
          const { error } = await supabase
            .from('chats')
            .update({ name: newChatName })
            .eq('id', editingChatId)
            .eq('user_id', user.id)
          
          if (error) {
            console.error('Error renaming chat:', error)
          } else {
            // Update local state
            setChatSessions(prevSessions => 
              prevSessions.map(chat => 
                chat.id === editingChatId 
                  ? { ...chat, name: newChatName } 
                  : chat
              )
            )
          }
        } catch (err) {
          console.error('Error in inline chat rename:', err)
        }
      }
    }
    // Reset edit state
    setEditingChatId(null)
    setNewChatName('')
  }
  
  // Submit inline edit with enter key
  const handleInlineEditKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      handleInlineEditBlur()
    } else if (e.key === 'Escape') {
      e.preventDefault()
      setEditingChatId(null)
      setNewChatName('')
    }
  }
  
  // Simplified function to handle chat renaming
  const handleRenameChat = async () => {
    if (!chatToRename || !newChatName.trim()) return

    try {
      const { error } = await supabase
        .from('chats')
        .update({ name: newChatName })
        .eq('id', chatToRename.id)
        .eq('user_id', user.id)
      
      if (error) {
        console.error('Error renaming chat:', error)
        return
      }
      
      console.log('Chat renamed successfully')
      
      // Update in state
      setChatSessions(prevSessions => 
        prevSessions.map(chat => 
          chat.id === chatToRename.id 
            ? { ...chat, name: newChatName } 
            : chat
        )
      )
      
      // Close modal
      setRenameModalOpen(false)
      setChatToRename(null)
      setNewChatName('')
      
      // Reload chats to ensure state is in sync
      await loadChatSessions(user.id, rawWorkspaceId || null)
    } catch (err) {
      console.error('Error in handleRenameChat:', err)
    }
  }
  
  const deleteProject = async (projectId: string) => {
    try {
      setError(null);
      setProjectMenuOpen(null);

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;

      // --- BERECHTIGUNGSPRÜFUNG ---
      // Diese Prüfung schlägt aktuell fehl (PGRST116) und muss behoben werden!
      const { data: memberData, error: memberError } = await supabase
        .from('workspace_members')
        .select('role')
        .eq('workspace_id', workspaceContext)
        .eq('user_id', user.id)
        .single(); // <- Findet 0 Zeilen!

      if (memberError) {
        console.error("Fehler beim Prüfen der Berechtigung:", memberError);
        // Zeige den Fehler an, aber kehre *noch nicht* zurück,
        // damit der Rest der Funktion für den Fall ausgeführt wird, dass die Prüfung *korrekt* wäre.
        // In der finalen Version sollte hier ein `return` stehen.
        setError(`Berechtigungsfehler: ${memberError.message}`);
        return; // <-- Wichtig: Reaktiviert!
      } else if (!memberData || !['admin', 'owner'].includes(memberData.role)) {
        setError("Nur Workspace-Administratoren oder Eigentümer können Projekte löschen.");
        return; // Hier ist der Return OK.
      }
      // --- ENDE BERECHTIGUNGSPRÜFUNG ---


      if (!confirm(`Projekt "${projects.find(p => p.id === projectId)?.name}" wirklich löschen?`)) {
        return;
      }

      // Lösche das Projekt
      const { error: deleteError } = await supabase
        .from('projects')
        .delete()
        .eq('id', projectId);

      if (deleteError) {
        console.error('Error deleting project:', deleteError);
        setError(`Fehler beim Löschen des Projekts: ${deleteError.message}`);
        return; // Beende bei Löschfehler
      }

      console.log("✅ Projekt erfolgreich gelöscht. Lade Daten neu...");

      // --- DATEN NEU LADEN statt lokalen State zu patchen ---
      setLoading(true); // Ladeindikator anzeigen
      try {
        // Lade Projekte und Chats neu
        if (user) {
          await loadProjects(user.id, workspaceContext);
          await loadChatSessions(user.id, workspaceContext);
        }

        // Setze abhängige Zustände zurück
        if (selectedProject?.id === projectId) {
          setSelectedProject(null);
        }
        // Finde Chats, die zu diesem Projekt gehören (basierend auf dem *alten* State vor dem Reload)
        const chatsInProjectToDelete = chatSessions.filter(chat => chat.project_id === projectId);
        if (editingChatId && chatsInProjectToDelete.some(chat => chat.id === editingChatId)) {
          setEditingChatId(null);
          setNewChatName('');
        }
        // expandedProjects muss nicht manuell bereinigt werden, da es von 'projects' abhängt

      } catch (reloadError) {
        console.error("Fehler beim Neuladen der Daten nach Projektlöschung:", reloadError);
        setError("Projekt gelöscht, aber Fehler beim Aktualisieren der Ansicht.");
      } finally {
        setLoading(false);
      }

    } catch (err) {
      // Dieser Catch ist jetzt hauptsächlich für unerwartete Fehler
      console.error('Unexpected error in deleteProject:', err);
      setError("Ein unerwarteter Fehler ist aufgetreten.");
    }
  };
  
  const updateProject = async () => {
    if (!projectToRename || !newProjectName.trim()) return;
    
    try {
      setLoading(true);
      
      const { data, error } = await supabase
        .from('projects')
        .update({
          name: newProjectName,
          description: newProjectDescription,
          updated_at: new Date().toISOString()
        })
        .eq('id', projectToRename.id)
        .select();

      if (error) throw error;

      // Aktualisiere Projektliste
      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
      await loadProjects(user.id, workspaceContext);
      
      // Wenn das bearbeitete Projekt ausgewählt war, aktualisiere die Auswahl
      if (selectedProject?.id === projectToRename.id && data?.[0]) {
        setSelectedProject(data[0]);
      }
      
      // Modal schließen
      setShowProjectModal(false);
      setProjectToRename(null);
      setNewProjectName('');
      setNewProjectDescription('');
      
    } catch (err) {
      console.error('Error updating project:', err);
    } finally {
      setLoading(false);
    }
  };
  
  // Chat einem Projekt zuweisen
  const assignChatToProject = async (chatId: string, projectId: string | null) => {
    try {
      console.log(`Zuweisen von Chat ${chatId} zu Projekt ${projectId || 'none'}`);
      
      // Update in der Datenbank
      const { error } = await supabase
        .from('chats')
        .update({ 
          project_id: projectId,
          // Auch last_message_timestamp aktualisieren, damit die Sortierung korrekt bleibt
          last_message_timestamp: new Date().toISOString()
        })
        .eq('id', chatId);

      if (error) throw error;

      // Update im lokalen State
      setChatSessions(prev => 
        prev.map(chat => 
          chat.id === chatId 
            ? { ...chat, project_id: projectId } 
            : chat
        )
      );

      // Lade Chats neu, um sicherzustellen, dass die UI korrekt aktualisiert wird
      if (user) {
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        // Verzögerung einbauen, damit die Datenbank Zeit hat, die Änderung zu verarbeiten
        setTimeout(async () => {
          await loadChatSessions(user.id, workspaceContext);
        }, 300);
      }

      console.log(`Chat ${chatId} wurde ${projectId ? `Projekt ${projectId}` : 'keinem Projekt'} zugewiesen`);
    } catch (err) {
      console.error('Fehler beim Zuweisen des Chats:', err);
      setError('Fehler beim Zuweisen des Chats zu einem Projekt');
    }
  };
  
  // Ergänze die Message-Komponente
  const Message = ({ message, isTyping }: { message: Message, isTyping?: boolean }) => {
    const isUser = message.role === 'user'
    const messageRef = useRef<HTMLDivElement>(null);
    
    // Add effect to ensure message is visible
    useEffect(() => {
      // Only scroll into view for the most recent message
      if (messageRef.current && !isTyping) {
        messageRef.current.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }
    }, [message.id, isTyping]);
    
    if (message.role === 'system') {
      return null // System-Nachrichten nicht anzeigen
    }
    
    return (
      <div 
        ref={messageRef}
        className={`mx-auto max-w-3xl px-4 py-3 ${isUser ? 'text-right' : 'text-left'}`}
        data-message-id={message.id}
      >
        <div 
          className={`inline-block ${isUser ? 'user-message' : 'assistant-message'}`}
        >
          {message.isTypewriting && message.role === 'assistant' ? (
            <TypewriterEffect 
              content={message.content} 
              onComplete={() => handleTypewriterComplete(message.id)} 
            />
          ) : (
            <div className={`prose prose-sm ${isUser ? 'text-black' : 'text-white'} text-left`}>
              <ReactMarkdown 
                remarkPlugins={[remarkGfm]}
                components={{
                  // Custom component for code blocks to add header and copy button
                  code: ({ node, inline, className, children, ...props }: CodeProps) => {
                    const match = /language-(\w+)/.exec(className || '');
                    const language = match ? match[1] : 'code';
                    const codeContent = String(children).replace(/\n$/, ''); // Extract code content

                    if (inline) {
                      // Handle inline code
                      return <code className={`rounded bg-[#333] px-1 py-0.5 text-sm ${className}`} {...props}>{children}</code>;
                    }
                    
                    // Handle block code
                    return (
                      <div className="relative my-2 rounded bg-[#282c34] text-white">
                        <div className="flex items-center justify-between bg-[#3c4043] px-4 py-1 text-xs text-gray-400">
                          <span>{language}</span>
                          <button
                            onClick={() => navigator.clipboard.writeText(codeContent)}
                            className="ml-2 text-gray-400 hover:text-white"
                          >
                            Kopieren
                          </button>
                        </div>
                        <pre className="overflow-x-auto p-4">
                          <code className={`language-${language}`}>{children}</code>
                        </pre>
                      </div>
                    );
                  }
                }}
              >
                {message.content}
              </ReactMarkdown>
            </div>
          )}
        </div>
      </div>
    )
  }
  
  // Add this new useEffect to listen for changes to personalWorkspaceId
  useEffect(() => {
    // When personalWorkspaceId is set, immediately load chats
    const loadInitialChats = async () => {
      // Nur laden, wenn wir noch keine Chats haben oder keinen aktuellen Chat
      // Dies verhindert, dass der Ladevorgang bestehende Daten überschreibt
      if (user && personalWorkspaceId && (chatSessions.length === 0 || !currentChatId)) {
        console.log("Personal workspace ID changed, no chats yet, loading for:", personalWorkspaceId);
        
        try {
          // Use the direct query approach to ensure we get the latest data
          let query = supabase
            .from('chats')
            .select('id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id')
            .eq('workspace_id', personalWorkspaceId)
            .order('last_message_timestamp', { ascending: false });
          
          const { data, error } = await query;
          
          if (error) {
            console.error('Error loading initial chats:', error);
            return;
          }
          
          if (data && data.length > 0) {
            console.log("Found existing chats:", data.length);
            const formattedSessions = data.map((chat: any) => ({
              id: chat.id || '', 
              name: chat.name || 'Unnamed Chat',
              created_at: chat.created_at || new Date().toISOString(),
              project_id: chat.project_id,
              user_id: chat.user_id,
              last_message_timestamp: chat.last_message_timestamp,
              ...(chat.description && { description: chat.description })
            }));
            
            setChatSessions(formattedSessions);
            
            // Set current chat if not already set
            if (!currentChatId) {
              console.log("Setting current chat to:", data[0].id);
              setCurrentChatId(data[0].id);
              await loadChat(data[0].id);
            }
          } else {
            console.log("No chats found for personal workspace, will create one on first message");
          }
        } catch (err) {
          console.error("Error in loadInitialChats:", err);
        }
      } else if (personalWorkspaceId) {
        console.log("Personal workspace ID changed, but chats already loaded, skipping reload");
      }
    };
    
    loadInitialChats();
  }, [personalWorkspaceId, user, supabase, currentChatId, chatSessions.length]);
  
  // Funktion zum Generieren und Setzen des Chat-Titels via AI
  const generateAndSetChatTitle = async (chatId: string, firstUserMessage: string) => {
    console.log(`✨ Generating title for chat ${chatId} based on: "${firstUserMessage}"`);
    try {
      // NEUE DIREKTE IMPLEMENTATION:
      // Statt sendMessageToAPI zu nutzen, machen wir den API Call direkt hier
      // um Fehler durch komplexe State-Handling-Logic in sendMessageToAPI zu vermeiden
      
      const prompt = `Analysiere die folgende Benutzernachricht und generiere einen kurzen, prägnanten Titel (maximal 4 Wörter) für diesen Chat. Gib NUR den Titel zurück, ohne Anführungszeichen oder zusätzliche Erklärungen:\n\nNachricht: "${firstUserMessage}"\n\nTitel:`;
      
      // Direkte Anfrage an unsere API-Route
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: [{ role: 'user', content: prompt }],
          model: 'Fast' // Schnelles Modell verwenden
        }),
      });
      
      if (!response.ok) {
        throw new Error(`API request failed: ${response.status}`);
      }
      
      const data = await response.json();
      let generatedTitle = data?.content?.trim() || null;
      
      console.log(`👋 API response for title generation:`, data);

      if (generatedTitle) {
        console.log(`✨ AI generated title: "${generatedTitle}"`);
        
        // Entferne mögliche Anführungszeichen am Anfang/Ende
        generatedTitle = generatedTitle.replace(/^"|"$/g, '');
        
        // Kurzen Fallback, falls Titel leer wird
        if (!generatedTitle.trim()) { 
             generatedTitle = generateChatName(firstUserMessage); // Fallback zur alten Methode
             console.log(`✨ AI title was empty, using fallback: "${generatedTitle}"`);
        } 

        // Update Datenbank
        const { error: updateError } = await supabase
          .from('chats')
          .update({ name: generatedTitle })
          .eq('id', chatId);

        if (updateError) {
          console.error('❌ Error updating chat name in DB:', updateError);
        } else {
          console.log(`✅ Chat ${chatId} name updated in DB to: "${generatedTitle}"`);
          // Update UI State
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: generatedTitle } : chat
            )
          );
        }
      } else {
         console.warn("⚠️ AI did not return a valid title.");
         // Optional: Fallback zur alten Methode, wenn AI versagt
         const fallbackTitle = generateChatName(firstUserMessage);
         const { error: updateError } = await supabase
          .from('chats')
          .update({ name: fallbackTitle })
          .eq('id', chatId);
          if (!updateError) {
              setChatSessions(prevSessions =>
                prevSessions.map(chat =>
                  chat.id === chatId ? { ...chat, name: fallbackTitle } : chat
                )
             );
          }
      }
    } catch (error) {
      console.error('❌ Error generating or setting chat title:', error);
      // Hier nicht abbrechen, Chat funktioniert trotzdem weiter
      
      // Fallback zur einfachen Methode bei Fehlern
      try {
        const fallbackTitle = generateChatName(firstUserMessage);
        console.log(`⚠️ Using fallback title due to error: "${fallbackTitle}"`);
        
        const { error: updateError } = await supabase
          .from('chats')
          .update({ name: fallbackTitle })
          .eq('id', chatId);
          
        if (!updateError) {
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: fallbackTitle } : chat
            )
          );
        }
      } catch (fbError) {
        console.error('❌ Even fallback title setting failed:', fbError);
      }
    }
  };
  
  // Füge Event-Listener für Klicks außerhalb der Edit-Box hinzu
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (editBoxRef.current && !editBoxRef.current.contains(event.target as Node) && editingMessageId) {
        cancelEditMessage();
      }
    };
    
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [editingMessageId]);

  // Handle Joyride callback
  const handleJoyrideCallback = (data: CallBackProps) => {
    const { action, index, status, type } = data;

    if (type === 'step:before' && index === 2) {
      // Show fake messages for message actions
      setShowFakeMessagesForTour(true);
      // Instead of continuing with the tour, show our custom dialog
      setShowMessageActionsDialog(true);
      // Pause the tour
      setRunTour(false);
    } else if (type === 'step:after' && index === 2) {
      // Clear fake messages after the step
      setShowFakeMessagesForTour(false);
    }

    if (action === 'reset' || status === STATUS.FINISHED) {
      setRunTour(false);
      setShowFakeMessagesForTour(false);
      setShowMessageActionsDialog(false);
    }
    
    if (type === 'step:after') {
      setStepIndex(index + 1);
    }
  };

  // Function to start the tour at a specific step
  const startTourAt = (index: number) => {
    setStepIndex(index);
    // Use timeout to ensure UI elements are rendered, especially if sidebar visibility changes
    setTimeout(() => {
        setRunTour(true);
    }, 100); // Small delay might be needed
  };
  
  // Function to handle "Deep Research" button click
  const handleDeepResearch = async () => {
    if (!inputValue.trim()) return; // Do nothing if input is empty
    
    // Use the enhanced handleSendMessage with web search enabled
    await handleSendMessage(inputValue.trim(), true);
  };
  
  // Handle PDF export with message selection
  const handleExportPdf = (selection: 'all' | 'last5' | 'last10' | number[]) => {
    try {
      const chatName = chatSessions.find(chat => chat.id === currentChatId)?.name || "Chat";
      downloadChatAsPdf(messages, chatName, selection);
    } catch (error) {
      console.error('Error exporting chat:', error);
      // You could add an error state and show a notification here
    }
  };

  // Handle chat summary generation
  const handleGenerateSummary = async () => {
    if (messages.length < 2) {
      // Füge eine Nachricht hinzu, wenn nicht genug Nachrichten vorhanden sind
      const errorMessage: Message = {
        id: uuidv4(),
        role: 'assistant',
        content: 'Es gibt nicht genügend Nachrichten für eine Zusammenfassung.',
        timestamp: new Date()
      };
      setMessages(prevMessages => [...prevMessages, errorMessage]);
      return;
    }

    // Zeige einen Ladeindikator im Chat
    const loadingMessage: Message = {
      id: uuidv4(),
      role: 'assistant',
      content: 'Erstelle eine Zusammenfassung des bisherigen Chats...',
      timestamp: new Date(),
      isTypewriting: true
    };
    
    const loadingMessageId = loadingMessage.id;
    setMessages(prevMessages => [...prevMessages, loadingMessage]);
    setIsTyping(true);

    try {
      // Generiere die Zusammenfassung
      const summary = await generateChatSummary(messages);
      
      // Ersetze die Lade-Nachricht mit der tatsächlichen Zusammenfassung
      setMessages(prevMessages => 
        prevMessages.map(msg => 
          msg.id === loadingMessageId 
            ? { ...msg, content: summary, isTypewriting: false } 
            : msg
        )
      );
      
      // Speichere die Nachricht in der Datenbank, wenn ein Chat aktiv ist
      if (currentChatId) {
        console.log('💬 Saving summary message for chat:', currentChatId);
        
        try {
          const { error: messageError } = await supabase
            .from("chat_messages")
            .insert({
              chat_id: currentChatId,
              role: 'assistant',
              content: summary,
              user_id: user?.id, // Make sure user_id is included in database insert
              created_at: new Date().toISOString()
            });

          if (messageError) {
            console.error('❌ Error saving summary message:', messageError);
          } else {
            console.log('✅ Summary message saved');
            // REMOVE: Reloading chat list is likely causing the issue
            // if (user) {
            //   await loadChatSessions(user.id, rawWorkspaceId || null);
            // }
          }
        } catch (dbError) {
          console.error('Database error saving summary:', dbError);
        }
      }
    } catch (error) {
      console.error('Error generating summary:', error);
      
      // Ersetze die Lade-Nachricht mit einer Fehlermeldung
      setMessages(prevMessages => 
        prevMessages.map(msg => 
          msg.id === loadingMessageId 
            ? { 
                ...msg, 
                content: 'Bei der Erstellung der Zusammenfassung ist ein Fehler aufgetreten. Bitte versuche es später erneut.', 
                isTypewriting: false 
              } 
            : msg
        )
      );
    } finally {
      setIsTyping(false);
    }
  };
  
  const chatSessionsWithProjectInfo = chatSessions.map(chat => {
    const assignedProject = projects.find(project => 
      chat.project_id === project.id
    );
    return {
      ...chat,
      assignedProjectName: assignedProject?.name || null
    };
  });
  
  // Nicht zugewiesene Chats filtern
  const unassignedChats = useMemo(() => {
    console.log("Recalculating unassigned chats from", chatSessions.length, "available chats");
    return chatSessions.filter(chat => chat.project_id === null);
  }, [chatSessions]);
  
  // Chats nach Projekten gruppieren
  const chatsByProject = useMemo(() => {
    console.log("Recalculating chats by project from", chatSessions.length, "available chats");
    // Kopiere die Projekte und füge die zugehörigen Chats hinzu
    return projects.map(project => { // Use 'projects' from state
      const projectChats = chatSessions.filter(chat => chat.project_id === project.id); // Use 'chatSessions' from state
      console.log(`Project ${project.name} has ${projectChats.length} chats`);
      return {
        ...project,
        chats: projectChats
      };
    });
  }, [projects, chatSessions]); // Add 'projects' and 'chatSessions' to dependency array

  // Toggle Funktion für das Aufklappen der Projekte
  const toggleProjectExpansion = (projectId: string) => {
    console.log("Toggling project expansion for", projectId);
    setExpandedProjects(prev => ({
      ...prev,
      [projectId]: !prev[projectId]
    }));

    // Wenn ein Projekt ausgewählt wird, setzen wir es auch als aktives Projekt
    setSelectedProject(projects.find(p => p.id === projectId) || null);
  };
  
  // Hinzufügen einer Funktion, um anzuzeigen, ob ein Chat geladen ist
  const isActiveChat = (chatId: string): boolean => {
    return currentChatId === chatId;
  };

  // Verbesserte Funktion zum Laden eines Chats
  const handleSelectChat = async (chatId: string) => {
    console.log(`Selecting chat: ${chatId}`);
    
    // Prüfe, ob es ein gültiger Chat ist
    const selectedChat = chatSessions.find(chat => chat.id === chatId);
    if (!selectedChat) {
      console.error(`Chat ${chatId} nicht in aktuellen Chat-Sessions gefunden!`);
      return;
    }
    
    // Setze aktuellen Chat
    setCurrentChatId(chatId);
    
    // Lade Chat-Inhalte
    await loadChat(chatId);
    
    // Wenn der Chat zu einem Projekt gehört, stelle sicher, dass das Projekt aufgeklappt ist
    if (selectedChat.project_id) {
      console.log(`Chat gehört zu Projekt ${selectedChat.project_id}, klappe auf`);
      setExpandedProjects(prev => ({
        ...prev,
        [selectedChat.project_id!]: true
      }));
    }
  };
  
  if (error) {
    return (
      <div className="flex h-screen items-center justify-center bg-[var(--bg-primary)]">
        <div className="max-w-md rounded-lg border border-[var(--border-light)] bg-[var(--bg-tertiary)] p-6 text-center">
          <h2 className="mb-4 text-xl font-medium text-[var(--text-primary)]">Fehler</h2>
          <p className="mb-4 text-[var(--text-secondary)]">{error}</p>
          <Link 
            href="/login"
            className="inline-flex rounded-md bg-[var(--accent-primary)] px-4 py-2 text-sm font-medium text-white hover:bg-[var(--accent-primary-hover)]"
          >
            Zum Login
          </Link>
        </div>
      </div>
    );
  }
  
  // Funktion, um einen neuen Chat zu beginnen (ohne ihn sofort zu erstellen)
  const startNewChat = () => {
    setCurrentChatId(null);
    setMessages([]);
    setInputValue('');
    setSelectedTask(null); // Auch Task zurücksetzen
    // Optional: URL cleanen, falls eine Chat-ID drin ist
    const currentPath = window.location.pathname; // z.B. /chat
    const workspaceQuery = rawWorkspaceId ? `?workspace=${rawWorkspaceId}` : '';
    router.push(`${currentPath}${workspaceQuery}`, undefined);

    // Fokus auf Inputfeld
    inputRef.current?.focus();
  };
  
  // Add message search functionality
  const handleMessageSearch = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!messageSearchQuery.trim()) return;
    
    try {
      setIsSearching(true);
      
      // Search in message content - fixed table name from messages to chat_messages
      const { data: messagesData, error: messagesError } = await supabase
        .from("chat_messages")
        .select("id, content, chat_id, created_at, chats(name)")
        .ilike("content", `%${messageSearchQuery}%`)
        .order("created_at", { ascending: false })
        .limit(20);
      
      if (messagesError) {
        console.error("Fehler bei der Suche in Nachrichten:", messagesError);
      }
      
      // Combine client-side chat results with server-side message results
      const messageResults = messagesData || [];
      
      // Format message results
      const formattedResults = messageResults.map(result => ({
        id: `message-${result.id}`,
        content: result.content,
        chat_id: result.chat_id,
        created_at: result.created_at,
        chats: result.chats,
        type: 'message'
      }));
      
      // Add any existing client-side filtered chat results
      const existingChatResults = messageSearchResults
        .filter(result => result.id?.startsWith('local-'))
        .map(result => ({...result, type: 'chat'}));
      
      // Combine both types of results
      setMessageSearchResults([...formattedResults, ...existingChatResults]);
      console.log("Search results:", [...formattedResults, ...existingChatResults].length);
    } catch (err) {
      console.error("Fehler bei der Suche:", err);
    } finally {
      setIsSearching(false);
    }
  };
  
  // Update handleSearchInputChange to trigger search automatically after 3+ characters
  const handleSearchInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const query = e.target.value;
    setMessageSearchQuery(query);
    
    // Client-side filtering of visible chats list when typing
    if (query.trim() === '') {
      setMessageSearchResults([]);
    } else {
      // Filter chat sessions that match the query and convert to search result format
      const filteredChats = chatSessions
        .filter(chat => 
          chat.name.toLowerCase().includes(query.toLowerCase())
        )
        .map(chat => ({
          id: `local-${chat.id}`,
          content: "Chat gefunden",
          chat_id: chat.id,
          created_at: chat.created_at,
          chats: { name: chat.name },
          type: 'chat'
        }));
      
      setMessageSearchResults(filteredChats);
      
      // If query is 3+ characters, automatically trigger the full search
      if (query.trim().length >= 3) {
        // Create a debounced search function to avoid too many API calls
        clearTimeout(searchDebounceTimeout.current);
        searchDebounceTimeout.current = setTimeout(async () => {
          try {
            setIsSearching(true);
            
            // Search in message content - fixed table name from messages to chat_messages
            const { data: messagesData, error: messagesError } = await supabase
              .from("chat_messages")
              .select("id, content, chat_id, created_at, chats(name)")
              .ilike("content", `%${query}%`)
              .order("created_at", { ascending: false })
              .limit(20);
            
            if (messagesError) {
              console.error("Fehler bei der Suche in Nachrichten:", messagesError);
            }
            
            // Combine client-side chat results with server-side message results
            const messageResults = messagesData || [];
            
            // Format message results
            const formattedResults = messageResults.map(result => ({
              id: `message-${result.id}`,
              content: result.content,
              chat_id: result.chat_id,
              created_at: result.created_at,
              chats: result.chats,
              type: 'message'
            }));
            
            // Combine both types of results
            setMessageSearchResults([...formattedResults, ...filteredChats]);
          } catch (err) {
            console.error("Fehler bei der Suche:", err);
          } finally {
            setIsSearching(false);
          }
        }, 300); // 300ms debounce
      }
    }
  };
  
  const toggleMessageSearch = () => {
    setSearchOpen(!searchOpen);
    if (!searchOpen) {
      setMessageSearchQuery("");
      setMessageSearchResults([]);
    }
  };
  
  const handleImprovePrompt = async () => {
    if (!newTaskSystemPrompt.trim()) return
    
    try {
      setIsImprovingPrompt(true)
      
      // Make API call to your reasoning model to improve the prompt
      const response = await fetch('/api/improve-prompt', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          prompt: newTaskSystemPrompt,
          userId: user.id
        }),
      })
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        const errorMessage = errorData?.error || 'Fehler beim Verbessern des Prompts';
        console.error('API Error:', errorData);
        throw new Error(errorMessage);
      }
      
      const data = await response.json()
      setNewTaskSystemPrompt(data.improvedPrompt)
      
      // Show success message -- Removed alert
      // alert(`Prompt erfolgreich verbessert! (Verwendet: ${data.modelUsed || 'GPT-Modell'})`);
      
    } catch (error: any) {
      console.error('Error improving prompt:', error)
      alert(`Fehler beim Verbessern des Prompts: ${error.message || 'Unbekannter Fehler'}`);
    } finally {
      setIsImprovingPrompt(false)
    }
  }
  
  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])
  
  // Realtime subscription für Chat-Nachrichten
  useEffect(() => {
    if (!currentChatId || !supabase) return;
    
    console.log('Setting up realtime subscription for chat messages:', currentChatId);
    
    // Konfiguriere den Realtime-Channel für chat_messages
    const messagesChannel = supabase
      .channel(`chat_messages_${currentChatId}`)
      .on(
        'postgres_changes',
        {
          event: '*', // INSERT, UPDATE, DELETE
          schema: 'public',
          table: 'chat_messages',
          filter: `chat_id=eq.${currentChatId}`
        },
        (payload) => {
          console.log('Realtime message update received:', payload);
          
          // Nur bei fremden Nachrichten (nicht vom aktuellen Client gesendet) aktualisieren
          // Die Prüfung erfolgt anhand eines Vergleichs mit den aktuellen Nachrichten
          if (payload.eventType === 'INSERT') {
            const newMsg = payload.new;
            setMessages((prevMessages) => {
              // Prüfe, ob die Nachricht bereits existiert
              const exists = prevMessages.some(msg => 
                msg.content === newMsg.content && 
                msg.role === newMsg.role &&
                new Date(msg.timestamp).getTime() > Date.now() - 5000 // Nur in den letzten 5 Sekunden
              );
              
              if (!exists) {
                // Neue Nachricht hinzufügen
                return [...prevMessages, {
                  id: newMsg.id || uuidv4(),
                  role: newMsg.role as 'user' | 'assistant' | 'system',
                  content: newMsg.content,
                  timestamp: new Date(newMsg.created_at)
                }];
              }
              return prevMessages;
            });
          }
        }
      )
      .subscribe();
    
    // Cleanup beim Unmount oder wenn sich currentChatId ändert
    return () => {
      console.log('Cleaning up realtime subscription');
      supabase.removeChannel(messagesChannel);
    };
  }, [currentChatId, supabase]);
  
  // Realtime subscription für Änderungen an Chats (insbesondere Projekt-Zuordnungen)
  useEffect(() => {
    if (!user || !supabase) return;
    
    console.log('Setting up realtime subscription for chats table');
    
    // Konfiguriere den Realtime-Channel für die chats Tabelle
    const chatsChannel = supabase
      .channel(`chats_updates`)
      .on(
        'postgres_changes',
        {
          event: 'UPDATE', // Nur Updates überwachen
          schema: 'public',
          table: 'chats'
        },
        (payload) => {
          console.log('Realtime chat update received:', payload);
          
          // Aktualisiere den lokalen State, wenn sich ein Chat ändert
          if (payload.eventType === 'UPDATE') {
            const updatedChat = payload.new;
            
            // Aktualisiere den chatSessions-State
            setChatSessions(prevSessions => 
              prevSessions.map(chat => 
                chat.id === updatedChat.id 
                  ? { 
                      ...chat, 
                      name: updatedChat.name,
                      project_id: updatedChat.project_id
                    } 
                  : chat
              )
            );
            
            // Wenn der aktuelle Chat aktualisiert wurde, aktualisiere auch currentChatId
            if (currentChatId === updatedChat.id) {
              setCurrentChatId(updatedChat.id);
            }
          }
        }
      )
      .subscribe();
    
    // Cleanup beim Unmount
    return () => {
      console.log('Cleaning up chats table subscription');
      supabase.removeChannel(chatsChannel);
    };
  }, [user, supabase]);
  
  // Hilfsfunktion, um Initialen aus User-ID oder E-Mail zu extrahieren
  const getUserInitials = (userId: string | undefined): string => {
    if (!userId) return "?";
    
    // Einfache Extraktionslogik - nimmt die ersten 2 Zeichen der userId
    // In einer realen Anwendung würde man hier den Namen des Benutzers abrufen
    return userId.substring(0, 2).toUpperCase();
  };

  // Funktion zum Erstellen und Speichern von Embeddings
  const createEmbedding = async (message: Message, chatId: string, workspaceId: string | null = null) => {
    try {
      console.log("🔄 Erstelle Embedding für Nachricht:", message.id);
      console.log("📨 Original Nachrichteninhalt:", message.content);
      
      // Current date formatted for embedding
      const currentDate = new Date().toISOString().split('T')[0]; // Format: YYYY-MM-DD
      
      // Append date information to the content for embedding
      const contentWithDate = `[Datum: ${currentDate}]\n${message.content}`;
      console.log("📅 Nachrichteninhalt mit Datum für Embedding:", contentWithDate);
      
      // OpenAI API für Embedding aufrufen
      console.log("🧠 Embedding wird generiert für Inhalt mit Länge:", contentWithDate.length);
      const response = await fetch('/api/embeddings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          input: contentWithDate
        }),
      });

      if (!response.ok) {
        throw new Error(`Embedding API responded with ${response.status}`);
      }

      const embeddingData = await response.json();
      console.log("✅ Embedding erfolgreich generiert:");
      console.log("📊 Embedding-Dimensionen:", embeddingData.embedding.length);
      console.log("🔍 Embedding-Vorschau (erste 5 Werte):", embeddingData.embedding.slice(0, 5));
      console.log("🔍 Embedding-Vorschau (letzte 5 Werte):", embeddingData.embedding.slice(-5));
      
      // In der Datenbank speichern
      const dbPayload = {
        message_id: message.id,
        chat_id: chatId,
        workspace_id: workspaceId,
        role: message.role,
        embedding: embeddingData.embedding,
        content_with_date: contentWithDate // Store the content with date in the new column
      };
      console.log("💾 Speichere in DB mit Payload:", {
        message_id: dbPayload.message_id,
        chat_id: dbPayload.chat_id,
        workspace_id: dbPayload.workspace_id,
        role: dbPayload.role,
        content_with_date: contentWithDate.substring(0, 50) + "...", // Log truncated for readability
        embedding_length: embeddingData.embedding.length
      });
      
      const { data, error } = await supabase.from('message_embeddings').insert(dbPayload).select();

      if (error) {
        console.error("❌ Fehler beim Speichern des Embeddings:", error);
        throw error;
      }
      console.log("✅ Embedding gespeichert für Nachricht:", message.id);
      if (data) {
        console.log("📝 DB-Eintrag erstellt mit ID:", data[0]?.id);
      }
    } catch (error) {
      console.error("❌ Fehler beim Erstellen des Embeddings:", error);
    }
  };

  // Funktion zum Finden ähnlicher Nachrichten für einen *Benutzer*
  const findSimilarMessages = async (query: string, userId: string) => {
    // Stelle sicher, dass eine userId vorhanden ist
    if (!userId) {
      console.error("❌ User ID fehlt für die Suche nach ähnlichen Nachrichten.");
      return [];
    }
  
    try {
      console.log(`🔍 Suche nach ähnlichen Nachrichten für User ${userId}`);
      console.log(`📝 Suchanfrage: "${query}"`);
      
      // Embedding für die Abfrage erstellen
      console.log("🧠 Generiere Embedding für Suchanfrage...");
      const response = await fetch('/api/embeddings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          input: query
        }),
      });

      if (!response.ok) {
        throw new Error(`Embedding API responded with ${response.status}`);
      }

      const embeddingData = await response.json();
      console.log("✅ Embedding für Abfrage erfolgreich generiert");
      console.log("📊 Query-Embedding-Dimensionen:", embeddingData.embedding.length);
      console.log("🔍 Query-Embedding-Vorschau (erste 5 Werte):", embeddingData.embedding.slice(0, 5));
      
      // Ähnliche Nachrichten mit *neuer* Stored Procedure finden
      console.log(`📞 Rufe search_similar_messages RPC für User ${userId} auf (Schwellwert: 0.7, Max Ergebnisse: 10)`);
      const { data, error } = await supabase.rpc('search_similar_messages', {
        query_embedding: embeddingData.embedding,
        p_user_id: userId, // Übergabe der User ID
        similarity_threshold: 0.7, // Erhöht von 0.3 auf 0.7 für präzisere Ergebnisse
        max_results: 10
      });

      if (error) {
        console.error("❌ Fehler in search_similar_messages RPC:", error);
        throw error;
      }
      
      console.log(`🔎 RPC Ergebnis: ${data?.length || 0} Nachrichten gefunden`);
      if (data && data.length > 0) {
        console.log("📋 Erste Ergebnisse (Rohdaten):", data.slice(0, 2));
      }
      
      // Filtere die Ergebnisse: Behalte Kontext-Nachrichten und ignoriere zu ähnliche primäre Nachrichten
      const filteredData = data?.filter((m: any) => 
        m.is_context || // immer Kontext-Nachrichten behalten
        m.similarity < 0.99 // Nur Hauptnachrichten filtern, nicht Kontext
      ) || [];
      
      console.log(`🧹 Nach Filterung: ${filteredData.length} Nachrichten übrig`);
      
      // Process messages to extract date information if present
      console.log("🔄 Verarbeite Nachrichten, um Datumsinformationen zu extrahieren...");
      const processedData = filteredData.map((m: any) => {
        let displayContent = m.content;
        let dateInfo = null;
        
        // Extract date information if it's included in the format [Datum: YYYY-MM-DD]
        const dateMatch = m.content.match(/\[Datum: (\d{4}-\d{2}-\d{2})\]/);
        if (dateMatch) {
          dateInfo = dateMatch[1];
          // Remove the date prefix for display
          displayContent = m.content.replace(/\[Datum: \d{4}-\d{2}-\d{2}\]\n/, '');
          console.log(`📅 Datum gefunden in Nachricht ${m.message_id}: ${dateInfo}`);
        } else {
          console.log(`⚠️ Kein Datum gefunden in Nachricht ${m.message_id}`);
        }
        
        return {
          ...m,
          displayContent,
          dateInfo,
          isContext: m.is_context || false // Übernehme das Kontext-Flag
        };
      });
      
      console.log(`✅ ${processedData.length} ähnliche Nachrichten nach Filterung gefunden`);
      
      // Gruppiere zusammengehörige Nachrichten für bessere Übersicht in Logs
      const contextGroups = new Map();
      
      processedData.forEach((m: any, index: number) => {
        const contextKey = m.isContext ? 'context' : `main-${index}`;
        
        console.log(`🔹 ${m.isContext ? 'Kontext-Nachricht' : 'Ergebnis'} #${index+1}:`);
        console.log(`  • ID: ${m.message_id}`);
        console.log(`  • Chat: ${m.chat_id}`);
        console.log(`  • Rolle: ${m.role}`);
        console.log(`  • Datum: ${m.dateInfo || 'Keines'}`);
        console.log(`  • Ähnlichkeit: ${m.similarity.toFixed(4)}${m.isContext ? ' (Kontext)' : ''}`);
        console.log(`  • Inhalt: ${(m.displayContent || m.content).substring(0, 100)}${(m.displayContent || m.content).length > 100 ? '...' : ''}`);
      });
      
      // Sortiere die Ergebnisse: Primäre Nachricht, dann Kontext
      processedData.sort((a: any, b: any) => {
        // Behalte die bestehende Sortierung bei
        return a.isContext === b.isContext 
          ? b.similarity - a.similarity // Bei gleichem Typ: Nach Ähnlichkeit absteigend
          : (a.isContext ? 1 : -1); // Primäre Nachrichten zuerst
      });
      
      return processedData;
    } catch (error) {
      console.error("❌ Fehler beim Suchen ähnlicher Nachrichten:", error);
      return [];
    }
  };

  return (
    <div className="flex h-screen overflow-hidden bg-[#1e1e1e]">
      {/* Use DynamicJoyride instead of Joyride */}
      <DynamicJoyride
        steps={tourSteps}
        run={runTour}
        stepIndex={stepIndex}
        callback={handleJoyrideCallback}
        continuous={true}
        showProgress={false}
        showSkipButton={true}
        locale={{
            back: 'Zurück',
            close: 'Schließen',
            last: 'Fertig',
            next: 'Weiter',
            skip: 'Überspringen',
        }}
        disableOverlayClose={true}
        styles={{
          options: {
            zIndex: 10000,
            arrowColor: '#333333',
            backgroundColor: '#1e1e1e',
            primaryColor: '#ffffff',
            textColor: '#cccccc',
          },
          tooltipContainer: {
            textAlign: "left",
          },
          buttonNext: {
              backgroundColor: '#555555',
          },
          buttonBack: {
              marginRight: 10,
          },
        }}
      />

      {/* Sidebar */}
      {showSidebar && (
        <aside id="chat-sidebar" className="flex h-screen shrink-0 flex-col rounded-r-xl border-r border-[#333333] bg-[#0d0d0d] p-0" style={{ width: "305px" }}>
          <div className="flex items-center justify-between border-b border-[#333333] p-4">
            {/* Replace H1 with Home Button */}
            <button 
              onClick={() => router.push('/dashboard')}
              className="rounded p-1.5 text-gray-400 hover:bg-[#2d2d2d] hover:text-white"
              title="Dashboard"
            >
              <Home size={18} />
            </button>
            <div className="flex items-center space-x-2">
              {/* Search and Add buttons remain here */}
              <button 
                onClick={toggleMessageSearch} // Corrected: Use toggleMessageSearch
                className="rounded p-1.5 text-gray-400 hover:bg-gray-800 hover:text-white"
                aria-label="Chats durchsuchen"
              >
                <Search size={16} />
              </button>
                <button 
                id="new-chat-button"
                onClick={startNewChat}
                className="rounded p-1.5 text-gray-400 hover:bg-gray-800 hover:text-white"
                aria-label="Neuer Chat"
              >
                <Plus size={16} />
                </button>
            </div>
          </div>

          {/* Search Panel */}
          {searchOpen && (
            <div className="border-b border-[#333333] px-3 py-2">
              <form onSubmit={handleMessageSearch} className="mb-2">
                <div className="relative">
                  <input
                    type="text"
                    value={messageSearchQuery}
                    onChange={handleSearchInputChange}
                    placeholder="Suche in Chats..."
                    className="w-full rounded-md border border-[#333333] bg-[#1a1a1a] px-3 py-1.5 text-xs text-white focus:outline-none"
                    autoFocus
                  />
            <button
                    type="submit" 
                    className="absolute right-2 top-1/2 -translate-y-1/2"
                    disabled={isSearching}
                  >
                    <Search className="size-3 text-gray-400" />
                  </button>
                </div>
              </form>
              
              {isSearching ? (
                <div className="py-2 text-center">
                  <div className="inline-block size-3 animate-spin rounded-full border-2 border-gray-400 border-t-transparent"></div>
                </div>
              ) : messageSearchResults.length > 0 ? (
                <div className="max-h-60 overflow-y-auto rounded-md border border-[#333333] bg-[#1a1a1a]">
                  {messageSearchResults.map((result) => (
                    <div
                      key={result.id}
                      onClick={() => {
                        if (result.chat_id) {
                          // Die neue Funktion verwenden, statt direkter API-Aufrufe
                          handleSelectChat(result.chat_id);
                          // Close search after selecting a result
                          setSearchOpen(false);
                        }
                      }}
                      className="block cursor-pointer border-b border-[#333333] p-2 last:border-0 hover:bg-[#272727]"
                    >
                      <div className="mb-1 flex items-center text-xs font-medium text-white">
                        {result.type === 'chat' ? (
                          <>
                            <MessageCircle className="mr-1 size-3 text-gray-300" />
                            <span>Chat: {result.chats?.name || "Chat"}</span>
                          </>
                        ) : (
                          <>
                            <FileText className="mr-1 size-3 text-gray-400" />
                            <span>Nachricht in: {result.chats?.name || "Chat"}</span>
                          </>
                        )}
          </div>
                      <p className="line-clamp-2 text-xs text-gray-400">
                        {result.type === 'chat' ? 
                          "Chat mit diesem Namen gefunden" : 
                          result.content}
                      </p>
                      <div className="mt-1 text-[10px] text-gray-500">
                        {new Date(result.created_at).toLocaleString()}
                      </div>
                    </div>
                  ))}
                </div>
              ) : messageSearchQuery && !isSearching ? (
                <div className="py-2 text-center text-xs text-gray-400">
                  Keine Ergebnisse gefunden
                </div>
              ) : null}
            </div>
          )}
          
          {/* Chat List */}
          <div className="custom-scrollbar scrollbar-hide grow overflow-y-auto p-3">
            <div className="mb-4">
              <h2 className="mb-2 text-sm font-semibold uppercase text-[#999999]">Chats</h2>
              <div className="space-y-1">
                {unassignedChats.map((chatSession) => (
                  <div 
                    key={chatSession.id} 
                    className="group flex items-center"
                    draggable="true"
                    onDragStart={(e) => {
                      e.dataTransfer.setData('chatId', chatSession.id);
                      setDraggedChatId(chatSession.id);
                    }}
                    onDragEnd={() => setDraggedChatId(null)}
                  >
                    <button
                      onClick={() => handleSelectChat(chatSession.id)}
                      className={cn(
                        "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                        isActiveChat(chatSession.id)
                          ? "bg-[#2d2d2d] text-white"
                          : "text-[#cccccc] hover:bg-[#222222]"
                      )}
                      style={{ maxWidth: "calc(100% - 40px)" }}
                    >
                      {editingChatId === chatSession.id ? (
                        <input
                          type="text"
                          value={newChatName}
                          onChange={(e) => setNewChatName(e.target.value)}
                          onBlur={handleInlineEditBlur}
                          onKeyDown={handleInlineEditKeyDown}
                          className="w-full rounded border border-[#444444] bg-[#333333] px-2 py-0.5 text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                          autoFocus
                          onClick={(e) => e.stopPropagation()}
                        />
                      ) : (
                        <div className="flex items-center">
                          <span className="block flex-1 truncate" title={chatSession.name}>{chatSession.name}</span>
                          {chatSession.user_id && chatSession.user_id !== user?.id && (
                            <span className="ml-2 flex size-5 items-center justify-center rounded-full bg-gray-700 text-xs text-gray-300" 
                                  title={`Erstellt von ${chatSession.user_id}`}>
                              {getUserInitials(chatSession.user_id)}
                            </span>
                          )}
                        </div>
                      )}
                    </button>
                    <div className="ml-1 flex min-w-[60px] opacity-0 transition-opacity group-hover:opacity-100">
                      <button
                        onClick={(e) => startInlineEdit(chatSession, e)}
                        className="p-1 text-[#cccccc] hover:text-white"
                        title="Umbenennen"
                      >
                        <Edit size={14} />
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation()
                          deleteChat(chatSession.id)
                        }}
                        className="p-1 text-[#cccccc] hover:text-red-500"
                        title="Löschen"
                      >
                        <Trash size={14} />
                      </button>
                    </div>
                  </div>
                ))}
                
                {unassignedChats.length === 0 && (
                  <div className="px-3 py-2 text-xs italic text-[#666666]">
                    Keine freien Chats
                  </div>
                )}
              </div>
              {/* Remove redundant "Neuer Chat" button since we already have one at the top of the sidebar */}
            </div>
            
            <div className="mt-6">
              <h2 className="mb-2 text-sm font-semibold uppercase text-[#999999]">Projekte</h2>
              <div className="space-y-1">
                {chatsByProject.map((project) => (
                  <div key={project.id} className="mb-1">
                    <div 
                      className="group flex items-center"
                      onDragOver={(e) => {
                        e.preventDefault();
                        setActiveDropTarget(project.id);
                      }}
                      onDragLeave={() => setActiveDropTarget(null)}
                      onDrop={(e) => {
                        e.preventDefault();
                        const chatId = e.dataTransfer.getData('chatId');
                        if (chatId) {
                          assignChatToProject(chatId, project.id);
                        }
                        setActiveDropTarget(null);
                      }}
                    >
                      <button
                        onClick={() => toggleProjectExpansion(project.id)}
                        className={cn(
                          "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                          selectedProject?.id === project.id
                            ? "bg-[#2d2d2d] text-white"
                            : "text-[#cccccc] hover:bg-[#222222]",
                          activeDropTarget === project.id && "border border-white/40 bg-[#2d2d2d]"
                        )}
                        style={{ maxWidth: "calc(100% - 40px)" }}
                      >
                        <span className="flex items-center">
                          {expandedProjects[project.id] ? (
                            <ChevronDown size={16} className="mr-2 min-w-4" />
                          ) : (
                            <ChevronRight size={16} className="mr-2 min-w-4" />
                          )}
                          <span className="block truncate" title={project.name}>{project.name}</span>
                          {project.chats.length > 0 && (
                            <span className="ml-2 text-xs text-gray-400">
                              ({project.chats.length})
                            </span>
                          )}
                        </span>
                      </button>
                      <div className="relative ml-1">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setProjectMenuOpen(project.id === projectMenuOpen ? null : project.id);
                          }}
                          className="p-1 text-[#cccccc] opacity-0 transition-opacity hover:text-white group-hover:opacity-100"
                          data-project-menu="trigger"
                        >
                          <MoreVertical size={16} />
                        </button>
                        {projectMenuOpen === project.id && (
                          <div 
                            className="absolute right-0 top-full z-10 mt-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg"
                            data-project-menu="content"
                          >
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                // Projekt-Bearbeitung implementieren
                                setProjectToRename(project);
                                setNewProjectName(project.name);
                                setNewProjectDescription(project.description || '');
                                setShowProjectModal(true);
                              }}
                              className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                            >
                              <Edit size={16} className="mr-2" />
                              Bearbeiten
                            </button>
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                deleteProject(project.id);
                              }}
                              className="flex w-full items-center px-4 py-2 text-sm text-red-500 hover:bg-[#2d2d2d]"
                            >
                              <Trash size={16} className="mr-2" />
                              Löschen
                            </button>
                          </div>
                        )}
                      </div>
                    </div>
                    
                    {/* Projektzugewiesene Chats anzeigen, wenn Projekt aufgeklappt ist */}
                    {expandedProjects[project.id] && project.chats.length > 0 && (
                      <div className="mt-1 space-y-1 pl-6">
                        {project.chats.map((chatSession) => (
                          <div key={chatSession.id} className="group flex items-center">
                            <button
                              onClick={() => handleSelectChat(chatSession.id)}
                              className={cn(
                                "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                                isActiveChat(chatSession.id)
                                  ? "bg-[#2d2d2d] text-white"
                                  : "text-[#cccccc] hover:bg-[#222222]"
                              )}
                              style={{ maxWidth: "calc(100% - 70px)" }}
                            >
                              {editingChatId === chatSession.id ? (
                                <input
                                  type="text"
                                  value={newChatName}
                                  onChange={(e) => setNewChatName(e.target.value)}
                                  onBlur={handleInlineEditBlur}
                                  onKeyDown={handleInlineEditKeyDown}
                                  className="w-full rounded border border-[#444444] bg-[#333333] px-2 py-0.5 text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                                  autoFocus
                                  onClick={(e) => e.stopPropagation()}
                                />
                              ) : (
                                <div className="flex items-center">
                                  <span className="block flex-1 truncate" title={chatSession.name}>{chatSession.name}</span>
                                  {chatSession.user_id && chatSession.user_id !== user?.id && (
                                    <span className="ml-2 flex size-5 items-center justify-center rounded-full bg-gray-700 text-xs text-gray-300" 
                                          title={`Erstellt von ${chatSession.user_id}`}>
                                      {getUserInitials(chatSession.user_id)}
                                    </span>
                                  )}
                                </div>
                              )}
                            </button>
                            <div className="ml-1 flex min-w-[60px] opacity-0 transition-opacity group-hover:opacity-100">
                              <button
                                onClick={(e) => startInlineEdit(chatSession, e)}
                                className="p-1 text-[#cccccc] hover:text-white"
                                title="Umbenennen"
                              >
                                <Edit size={14} />
                              </button>
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  // Von Projekt entfernen
                                  assignChatToProject(chatSession.id, null);
                                }}
                                className="p-1 text-[#cccccc] hover:text-white"
                                title="Von Projekt entfernen"
                              >
                                <FileText size={14} />
                              </button>
                              <button
                                onClick={(e) => {
                                  e.stopPropagation()
                                  deleteChat(chatSession.id)
                                }}
                                className="p-1 text-[#cccccc] hover:text-red-500"
                                title="Löschen"
                              >
                                <Trash size={14} />
                              </button>
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                ))}
                
                {chatsByProject.length === 0 && (
                  <div className="px-3 py-2 text-xs italic text-[#666666]">
                    Keine Projekte gefunden
                  </div>
                )}
              </div>
              <button 
                onClick={() => setShowProjectModal(true)}
                className="mt-2 flex w-full items-center rounded-lg px-3 py-2 text-sm text-[#cccccc] hover:bg-[#222222]"
              >
                <Plus size={16} className="mr-2" />
                Neues Projekt
              </button>
            </div>
          </div>
          
          {/* User Section */}
          <div className="mt-auto border-t border-[#333333] p-3">
            <button 
              onClick={() => setShowSettingsModal(true)} 
              className="flex w-full items-center rounded-lg px-3 py-2 text-sm text-[#cccccc] hover:bg-[#222222]"
            >
              <User size={16} className="mr-2" />
              <span className="grow truncate text-left text-xs">{user?.email || 'Kein Benutzer'}</span>
              <Settings size={16} />
            </button>
          </div>
        </aside>
      )}

      {/* Main Content Area */}
      <main className="flex flex-1 flex-col overflow-hidden">
        {/* Header */}
        <header className="flex h-14 items-center justify-between border-b border-neutral-700 bg-neutral-900 px-4">
          <div className="flex items-center space-x-4">
            {/* Back button is removed, H1 is the first item */}
            <h1 className="text-xl font-semibold text-white">
              {selectedTask ? selectedTask.title : (chatSessions.find(chat => chat.id === currentChatId)?.name || "Neuer Chat")}
            </h1>
          </div>
          <div className="flex items-center space-x-4">
            {/* Model Selection Dropdown */}
            <div className="relative" ref={modelDropdownRef} id="model-select-button">
                    <button 
              onClick={() => !selectedTask && setShowModelDropdown(!showModelDropdown)}
              className={`flex items-center space-x-2 rounded-lg border border-[#333333] px-3 py-1.5 text-sm ${
                selectedTask 
                  ? 'cursor-not-allowed text-[#666666]' 
                  : 'cursor-pointer text-[#cccccc] transition-all hover:border-[#444444] hover:text-white'
              }`}
            >
              <span>{selectedTask ? `${getModelLabel(selectedModel)} (in Task festgelegt)` : getModelLabel(selectedModel)}</span>
              {!selectedTask && <ChevronDown size={16} />}
                  </button>

              {showModelDropdown && !selectedTask && (
                <div className="absolute right-0 top-full z-10 mt-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg">
                    {/* Button for Basic - Verwende den Label-Namen "Basic" */}
                    <button 
                      onClick={() => {
                        setSelectedModel('Basic') 
                        setShowModelDropdown(false)
                      }}
                      className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                    >
                      Basic
                    </button>
                    {/* Button for Fast - Verwende den Label-Namen "Fast" */}
                    <button
                      onClick={() => {
                        setSelectedModel('Fast') 
                        setShowModelDropdown(false)
                      }}
                      className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                    >
                      Fast
                    </button>
                    {/* Button for Reason - Verwende den Label-Namen "Reason" */}
                    <button
                      onClick={() => {
                        setSelectedModel('Reason') 
                        setShowModelDropdown(false)
                      }}
                      className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                    >
                      Reason
                    </button>
                    {/* Button for Reason+ - Verwende den Label-Namen "Reason+" */}
                    <button
                      onClick={() => {
                        setSelectedModel('Reason+') 
                        setShowModelDropdown(false)
                      }}
                      className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                    >
                      Reason+
                    </button>
                </div>
              )}
            </div>

            {/* Task Selection Dropdown */}
            <div className="relative" ref={taskDropdownRef} id="task-select-button">
              <div className="flex items-center">
                  <button 
                  onClick={() => setShowTaskDropdown(!showTaskDropdown)}
                  disabled={isTaskSwitching}
                  className="flex items-center space-x-2 rounded-lg border border-[#333333] px-3 py-1.5 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white disabled:cursor-not-allowed disabled:opacity-50"
                >
              <span>{selectedTask ? selectedTask.title : "Task auswählen"}</span>
              <ChevronDown size={16} />
                  </button>
                
                {isTaskSwitching && (
                  <div className="ml-2">
                    <div className="size-4 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                  </div>
                )}
              </div>

                {showTaskDropdown && (
              <div className="absolute right-0 top-full z-10 mt-1 w-64 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg">
                            <button
                              onClick={() => {
                      setIsTaskSwitching(true)
                          setSelectedTask(null)
                          setShowTaskDropdown(false)
                        }}
                  className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                      >
                  Kein Task
                </button>
                <div className="my-1 border-t border-[#333333]"></div>
                      {tasks.map(task => (
                <button 
                          key={task.id}
                  onClick={() => {
                        setIsTaskSwitching(true)
                            setSelectedTask(task)
                            setShowTaskDropdown(false)
                          }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                        >
                          {task.title}
                </button>
                      ))}
                <div className="my-1 border-t border-[#333333]"></div>
                    <button 
                        onClick={() => {
                          setShowTaskModal(true)
                          setShowTaskDropdown(false)
                        }}
                  className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                      >
                  <Plus size={16} className="mr-2" />
                  Neuer Task
                    </button>
                </div>
              )}
          </div>
            </div>
        </header>

        {/* Message Area */}
        <div 
          id="message-area-wrapper"
            ref={chatBodyRef}
          className="flex w-full flex-1 justify-center overflow-y-auto p-4 pb-10"
          >
          <div className="space-y-4" style={{ maxWidth: "805px", width: "100%" }}>
            {/* Start Screen with Info Buttons */}
            {messages.length === 0 && !runTour && !showFakeMessagesForTour && (
              <div className="flex h-full flex-col items-center justify-center text-center">
                <h2 className="mb-4 text-2xl font-bold text-white">
                  Entdecken Sie die Funktionen dieses Chats
                </h2>
                <div className="grid max-w-2xl grid-cols-2 gap-4">
                  <button key="tour-tasks" className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]" onClick={() => startTourAt(0)}>{infoItems[0].title}</button>
                  <button key="tour-model" className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]" onClick={() => startTourAt(1)}>{infoItems[1].title}</button>
                  <button key="tour-messages" className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]" onClick={() => startTourAt(2)}>{infoItems[2].title}</button>
                  <button key="tour-chats" className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]" onClick={() => startTourAt(3)}>{infoItems[3].title}</button>
          </div>
        </div>
      )}
            
            {/* Real Messages */}
            {!showFakeMessagesForTour && messages
              .filter(message => message.role !== 'system')
              .map((message) => (
              <div
                key={message.id}
                  className={`group mb-4 flex flex-col ${ 
                    message.role === "user" ? "items-end" : "items-start"
                }`}
              >
                  {/* Sender and timestamp */}
                <div className={`mb-1 text-xs ${message.role === "user" ? "text-right" : "text-left"} text-gray-400`}>
                  {message.role === "user" 
                    ? (message.sentfrom 
                        ? message.sentfrom // Use sentfrom if available
                        : (message.user_id === user?.id 
                            ? userFullName 
                            : (message.user_id && userNamesMap && userNamesMap[message.user_id]) 
                              ? userNamesMap[message.user_id] 
                              : (message.user_id 
                                  ? `Benutzer ${message.user_id.substring(0, 4)}` 
                                  : "Anderer Benutzer"))) 
                    : (message.sentfrom 
                        ? message.sentfrom // Use sentfrom for assistant too
                        : "KI-Assistent")} {message.timestamp.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit', second: '2-digit'})}
                </div>
                
                  {/* Message content or edit box */}
                {editingMessageId === message.id ? (
                  <div 
                    ref={editBoxRef}
                      className="flex w-full max-w-[60%] flex-col items-end"
                  >
                    <textarea
                      value={editingContent}
                      onChange={(e) => setEditingContent(e.target.value)}
                      className="mb-2 w-full resize-none rounded-lg border border-[#444] bg-[#3a3a3a] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#555]"
                      rows={3}
                      autoFocus
                    />
                    <div className="self-end">
                      <button
                        onClick={handleSaveEdit}
                        disabled={!editingContent.trim()}
                        className={`rounded-lg px-4 py-2 text-sm ${
                          !editingContent.trim() 
                            ? 'cursor-not-allowed text-[#666666]' 
                            : 'border border-[#444] bg-[#2d2d2d] text-[#cccccc] hover:border-[#555] hover:text-white'
                        }`}
                      >
                        Senden
                      </button>
                    </div>
                  </div>
                ) : (
                    <div className={`max-w-[60%] ${message.role === "user" ? "user-message" : "assistant-message"}`}>
                      {message.role === 'assistant' && message.isTypewriting ? (
                        <TypewriterEffect 
                          content={message.content} 
                          onComplete={() => handleTypewriterComplete(message.id)} 
                        />
                      ) : (
                        <div className="prose prose-invert max-w-none prose-headings:mb-2 prose-headings:mt-4 prose-headings:font-semibold prose-p:my-1">
                  <ReactMarkdown
                    remarkPlugins={[remarkGfm]}
                    components={{
                      code: ({ node, inline, className, children, ...props }: CodeProps) => {
                                const match = /language-(\w+)/.exec(className || '');
                                const language = match ? match[1] : 'code';
                                const codeContent = String(children).replace(/\n$/, ''); // Extract code content

                                if (inline) {
                                  return <code className={`rounded bg-[#333] px-1 py-0.5 text-sm ${className}`} {...props}>{children}</code>;
                                }

                                // Handle block code
                                return (
                                  <div className="relative my-2 rounded bg-[#282c34] text-white">
                                    <div className="flex items-center justify-between bg-[#3c4043] px-4 py-1 text-xs text-gray-400">
                                      <span>{language}</span>
                                      <button
                                        onClick={() => navigator.clipboard.writeText(codeContent)}
                                        className="ml-2 text-gray-400 hover:text-white"
                                      >
                                        Kopieren
                                      </button>
                                    </div>
                                    <pre className="overflow-x-auto p-4">
                                      <code className={`language-${language}`}>{children}</code>
                          </pre>
                                  </div>
                                );
                              },
                              p: ({ node, children, ...props }) => {
                                const hasPreChild = React.Children.toArray(children).some(
                                  (child) => React.isValidElement(child) && child.type === 'pre'
                                );
                                return hasPreChild ? <div {...props}>{children}</div> : <p {...props}>{children}</p>;
                      }
                    }}
                  >
                    {message.content}
                  </ReactMarkdown>
              </div>
                      )}
                  </div>
                )}
                  
                  {/* Action buttons */}
                {editingMessageId !== message.id && (
                  <div className="mt-1 flex items-center space-x-2 opacity-0 transition-opacity duration-200 group-hover:opacity-100">
                    {message.role === 'user' && (
                      <>
                        <button 
                          onClick={() => copyToClipboard(message.content)}
                          className="p-1 text-[#aaa] hover:text-white"
                          title="Nachricht kopieren"
                        >
                          <Copy size={14} />
                        </button>
                        <button 
                          onClick={() => startEditMessage(message)}
                          className="p-1 text-[#aaa] hover:text-white"
                          title="Nachricht bearbeiten"
                        >
                          <Edit size={14} />
                        </button>
                      </>
                    )}
                    {message.role === 'assistant' && (
                      <>
                        <button 
                          onClick={() => copyToClipboard(message.content)}
                          className="p-1 text-[#aaa] hover:text-white"
                          title="Antwort kopieren"
                        >
                          <Copy size={14} />
                        </button>
                        <button 
                          onClick={() => regenerateResponse(message.id)} 
                          className="p-1 text-[#aaa] hover:text-white"
                          title="Antwort neu generieren"
                        >
                          <RotateCcw size={14} />
                        </button>
                      </>
                    )}
                  </div>
                )}
              </div>
            ))}

            {/* Tour Messages */}
            {showFakeMessagesForTour && fakeTourMessages.map((message) => (
              <div
                key={message.id}
                className={`group relative mb-8 flex flex-col ${
                  message.role === "user" ? "items-end" : "items-start"
                }`}
              >
                <div className={`mb-1 text-xs ${message.role === "user" ? "text-right" : "text-left"} text-gray-400`}>
                  {message.role === "user" ? "Beispiel User" : "Beispiel KI"} {message.timestamp.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'})}
              </div>
                <div className={`max-w-[60%] ${message.role === "user" ? "user-message" : "assistant-message"}`}>
                  <div className="prose prose-invert max-w-none prose-headings:mb-2 prose-headings:mt-4 prose-headings:font-semibold prose-p:my-1">
                    <p>{message.content}</p>
              </div>
                </div>
                
                {/* Action buttons - made more prominent for the tour */}
                <div className={`mt-2 flex animate-pulse items-center space-x-3 rounded-md border border-[#444444] bg-[#333333] px-3 py-2 shadow-lg ${
                  message.role === 'user' ? 'self-end' : 'self-start'
                }`}>
                  {message.role === 'user' && (
                    <>
                      <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                        <Copy size={14} className="mr-1.5" />
                        <span className="text-sm font-medium">Kopieren</span>
                      </div>
                      <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                        <Edit size={14} className="mr-1.5" />
                        <span className="text-sm font-medium">Bearbeiten</span>
                      </div>
                    </>
                  )}
                  {message.role === 'assistant' && (
                    <>
                      <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                        <Copy size={14} className="mr-1.5" />
                        <span className="text-sm font-medium">Kopieren</span>
              </div>
                      <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                        <RotateCcw size={14} className="mr-1.5" />
                        <span className="text-sm font-medium">Neu generieren</span>
                      </div>
                    </>
                  )}
            </div>
              
                {/* Show message actions explanation for AI message during tour */}
                {showMessageActionsDialog && message.id === 'fake-ai-message' && (
                  <div className="mt-3 max-w-[80%] self-start rounded-md border border-[#444444] bg-[#222222] p-4 shadow-lg">
                    <div className="mb-2 flex items-center justify-between">
                      <h3 className="font-medium text-white">Nachrichtenaktionen</h3>
              <button
                        onClick={() => setShowMessageActionsDialog(false)}
                        className="text-gray-400 hover:text-white"
              >
                        <X size={16} />
              </button>
                    </div>
                    <p className="mb-2 text-sm text-gray-300">Bewegen Sie den Mauszeiger über die Nachrichten, um folgende Aktionen zu nutzen:</p>
                    <ul className="mb-2 ml-2 list-inside list-disc space-y-1 text-xs text-gray-300">
                      <li><strong>Kopieren:</strong> Kopiert den Inhalt der Nachricht in die Zwischenablage</li>
                      <li><strong>Bearbeiten:</strong> Ändert Ihre bereits gesendeten Nachrichten</li>
                      <li><strong>Neu generieren:</strong> Erstellt eine neue KI-Antwort zur letzten Benutzernachricht</li>
                    </ul>
                    <p className="mt-3 text-xs italic text-gray-400">
                      Diese Optionen erscheinen unter jeder Nachricht, wenn Sie mit der Maus darüber fahren.
                    </p>
                    <div className="mt-3 flex justify-end">
                      <button 
                        onClick={() => {
                          setShowMessageActionsDialog(false);
                          setRunTour(true);
                          setStepIndex(3); // Skip to the next step (chat sidebar)
                        }}
                        className="rounded-md bg-[#555555] px-3 py-1 text-sm text-white hover:bg-[#666666]"
                      >
                        Weiter
                      </button>
                    </div>
                  </div>
                )}
              </div>
            ))}

            {/* Typing Indicator - Use the new component */}
            {!showFakeMessagesForTour && isTyping && (
              <div className="mb-4 flex justify-start pl-4"> {/* Added bottom margin mb-4 */}
                {/* Replace the old indicator with the new one */}
                <LoadingIndicator />
              </div>
            )}
          </div>
        </div>
        
        {/* Chat Input Footer */}
        <div className="mt-auto flex w-full flex-col items-center bg-[#1e1e1e] px-4 pb-4 pt-2">
          <div className="relative flex items-center space-x-2 rounded-lg border border-[#333333] bg-[#2d2d2d] p-2" style={{ maxWidth: "805px", width: "100%" }}>
            <div className="flex shrink-0 items-center space-x-1">
               <button
                 onClick={handleDeepResearch}
                 disabled={!inputValue.trim() || isTyping || isSearching}
                 className="flex items-center space-x-1 rounded-lg px-2 py-1 text-xs text-[#cccccc] transition-colors hover:bg-[#444444] disabled:cursor-not-allowed disabled:opacity-50"
                 title="Web-Suche starten"
               >
                 {isSearching ? (
                   <Loader size={16} className="animate-spin" />
                 ) : (
                   <Search size={16} />
                 )}
                 <span>Web-Suche</span>
               </button>
               <div className="relative">
                 <button
                   ref={moreOptionsButtonRef}
                   onClick={() => setShowInputMenu(!showInputMenu)}
                   className="rounded-full p-1.5 text-[#cccccc] transition-colors hover:bg-[#444444]"
                   title="Weitere Optionen"
                 >
                   <MoreHorizontal size={20} />
                 </button>
                 
                 {showInputMenu && (
                   <div
                     ref={inputMenuRef}
                     className="absolute bottom-full left-0 z-20 mb-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg"
                   >
                     <button
                       onClick={() => {
                         handleGenerateSummary();
                         setShowInputMenu(false);
                       }}
                       className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                       disabled={messages.length < 2 || isTyping}
                     >
                       <BookOpen size={14} className="mr-2" />
                       Zusammenfassen
                     </button>
                     <button
                       onClick={() => {
                         setShowExportModal(true);
                         setShowInputMenu(false);
                       }}
                       className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                       disabled={messages.length === 0 || isTyping}
                     >
                       <FileDown size={14} className="mr-2" />
                       Exportieren
                     </button>
                     <div className="my-1 border-t border-[#333333]"></div>
                     <button
                       onClick={() => {
                         if(currentChatId && user) deleteChat(currentChatId);
                         setShowInputMenu(false);
                       }}
                       className="flex w-full items-center px-4 py-2 text-sm text-red-500 hover:bg-[#2d2d2d] disabled:cursor-not-allowed disabled:opacity-50"
                       disabled={!currentChatId || messages.length === 0}
                     >
                       <Trash size={14} className="mr-2" />
                       Chat löschen
                     </button>
                   </div>
                 )}
               </div>
            </div>

            <div className="mx-4 flex grow items-center"> {/* Ensure parent uses flex and items-center */} 
                  <textarea
                id="chat-input-textarea"
                    ref={inputRef}
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                    handleSendMessage(inputValue, false);
                  }
                }}
                placeholder={isTaskSwitching ? "Task wird gewechselt..." : "Stelle irgendeine Frage ..."}
                disabled={isTaskSwitching}
                // Fine-tune vertical padding: pt-2 pb-1
                className={`min-h-10 w-full resize-none bg-transparent px-2 pb-1 pt-2 text-sm text-white placeholder-[#666666] focus:outline-none${isTaskSwitching ? 'cursor-not-allowed opacity-50' : ''}`}
                    rows={1}
                    style={{
                  // minHeight: '40px', // Still handled by Tailwind class
                  maxHeight: '400px'
                    }}
                  />
            </div>

            <div className="shrink-0">
              <button
                onClick={() => handleSendMessage(inputValue, false)}
                disabled={!inputValue.trim() || isTyping || isTaskSwitching}
                className="flex items-center space-x-1 rounded-lg bg-white px-3 py-1.5 text-sm text-black transition-colors hover:bg-gray-200 disabled:cursor-not-allowed disabled:opacity-50"
                title="Nachricht senden"
              >
                {isTaskSwitching ? (
                  <>
                    <div className="size-4 animate-spin rounded-full border-2 border-gray-800 border-t-transparent"></div>
                    <span>Wechseln...</span>
                  </>
                ) : (
                  <>
                <Send size={16} />
                <span>Senden</span>
                  </>
                )}
              </button>
              </div>
            </div>

          <div className="mt-2 text-center text-xs text-[#666666]" style={{ maxWidth: "805px", width: "100%" }}>
             ChatGPT kann Fehler machen. OpenAI verwendet keine Daten aus diesem Chat zum Trainieren seiner Modelle.
          </div>
        </div>
      </main>

      {/* Task Creation Modal */}
      {showTaskModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className="w-full max-w-md rounded-lg border border-[#333333] bg-[#1e1e1e] p-6">
            <h2 className="mb-4 text-xl font-semibold text-white">Neuen Task erstellen</h2>
            <div className="mb-4">
              <label htmlFor="taskName" className="mb-2 block text-sm font-medium text-[#cccccc]">
                Task-Name
              </label>
              <input
                id="taskName"
                type="text"
                value={newTaskName}
                onChange={(e) => setNewTaskName(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Task-Name eingeben"
              />
            </div>
            
            <div className="mb-4">
              <label htmlFor="taskDescription" className="mb-2 block text-sm font-medium text-[#cccccc]">
                Beschreibung
              </label>
              <textarea
                id="taskDescription"
                value={newTaskDescription}
                onChange={(e) => setNewTaskDescription(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Task beschreiben..."
                rows={3}
              />
            </div>
            
            <div className="mb-4">
              <label htmlFor="taskSystemPrompt" className="mb-2 block text-sm font-medium text-[#cccccc]">
                System-Prompt
              </label>
              <div className="relative">
                <textarea
                  id="taskSystemPrompt"
                  value={newTaskSystemPrompt}
                  onChange={(e) => setNewTaskSystemPrompt(e.target.value)}
                  className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 pr-10 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                  placeholder="Strukturiere deinen Prompt! Z.B.: ZIEL: [Dein Ziel...] FORMAT: [Gewünschtes Format...] WARNUNGEN: [Was vermeiden?...] KONTEXT: [Hintergrundinfos...]"
                  rows={4}
                />
                <button
                  type="button"
                  onClick={handleImprovePrompt}
                  disabled={isImprovingPrompt || !newTaskSystemPrompt.trim()}
                  className="absolute right-3 top-3 rounded-md bg-[#333333] p-1.5 text-white/80 transition-colors hover:bg-[#444444] hover:text-white disabled:cursor-not-allowed disabled:opacity-50"
                  title="AI-Unterstützung für Prompt"
                >
                  {isImprovingPrompt ? (
                    <Loader size={18} className="animate-spin" />
                  ) : (
                    <Sparkles size={18} />
                  )}
                </button>
              </div>
            </div>
            
            <div className="mb-4">
              <label htmlFor="taskModel" className="mb-2 block text-sm font-medium text-[#cccccc]">
                KI-Modell
              </label>
              <select
                id="taskModel"
                value={newTaskModel}
                onChange={(e) => setNewTaskModel(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white focus:outline-none focus:ring-1 focus:ring-[#444444]"
              >
                <option value="gpt-4o">Basic</option>
                <option value="gpt-4o-mini">Fast</option>
                <option value="o3-mini">Reason</option>
                <option value="gpt-4.5-preview">Reason+</option>
              </select>
            </div>
            
            <div className="flex justify-end space-x-3">
              <button
                onClick={() => {
                  setShowTaskModal(false);
                  setNewTaskName('');
                  setNewTaskDescription('');
                  setNewTaskSystemPrompt('');
                  setNewTaskModel('gpt-4o');
                }}
                className="rounded-lg border border-[#333333] px-4 py-2 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white"
              >
                Abbrechen
              </button>
              <button
                onClick={handleCreateTask}
                disabled={!newTaskName.trim()}
                className={`rounded-lg px-4 py-2 text-sm ${
                  newTaskName.trim() 
                    ? 'border border-[#444444] bg-[#333333] text-white hover:bg-[#444444]' 
                    : 'cursor-not-allowed border border-[#444444]/50 bg-[#333333]/50 text-white/70'
                }`}
              >
                Erstellen
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Export Modal */}
      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        messages={messages}
        onExport={handleExportPdf}
      />
      
      {/* Summary Modal */}
      <SummaryModal
        isOpen={showSummaryModal}
        onClose={() => setShowSummaryModal(false)}
        summary={chatSummary}
        loading={false}
      />

      {/* Projekt Modal (Erstellen/Bearbeiten) */}
      {showProjectModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className="w-full max-w-md rounded-lg border border-[#333333] bg-[#1e1e1e] p-6">
            <h2 className="mb-4 text-xl font-semibold text-white">
              {projectToRename ? 'Projekt bearbeiten' : 'Neues Projekt erstellen'}
            </h2>
            
            <div className="mb-4">
              <label htmlFor="projectName" className="mb-2 block text-sm font-medium text-[#cccccc]">
                Projektname
              </label>
              <input
                id="projectName"
                type="text"
                value={newProjectName}
                onChange={(e) => setNewProjectName(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Projektname eingeben"
              />
            </div>
            
            <div className="mb-4">
              <label htmlFor="projectDescription" className="mb-2 block text-sm font-medium text-[#cccccc]">
                Beschreibung (optional)
              </label>
              <textarea
                id="projectDescription"
                value={newProjectDescription}
                onChange={(e) => setNewProjectDescription(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Projekt beschreiben..."
                rows={3}
              />
            </div>
            
            <div className="flex justify-end space-x-3">
              <button
                onClick={() => {
                  setShowProjectModal(false);
                  setProjectToRename(null);
                  setNewProjectName('');
                  setNewProjectDescription('');
                }}
                className="rounded-lg border border-[#333333] px-4 py-2 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white"
              >
                Abbrechen
              </button>
              <button
                onClick={() => {
                  if (projectToRename) {
                    // Projekt aktualisieren
                    updateProject();
                  } else {
                    // Neues Projekt erstellen
                    handleCreateProject();
                  }
                }}
                disabled={!newProjectName.trim()}
                className={`rounded-lg px-4 py-2 text-sm ${
                  newProjectName.trim() 
                    ? 'border border-[#444444] bg-[#333333] text-white hover:bg-[#444444]' 
                    : 'cursor-not-allowed border border-[#444444]/50 bg-[#333333]/50 text-white/70'
                }`}
              >
                {projectToRename ? 'Aktualisieren' : 'Erstellen'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Settings Modal */}
      <SettingsModal 
        isOpen={showSettingsModal} 
        onClose={() => setShowSettingsModal(false)} 
        userId={user?.id || ''}
      />
    </div>
  );
}
