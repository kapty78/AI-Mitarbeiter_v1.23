"use client"

import React from 'react'
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs"
import { useEffect, useRef, useState, useMemo } from "react"
import { useSearchParams } from "next/navigation"
import Link from "next/link"
import { ChevronLeft, Menu, Plus, Send, ChevronDown, Copy, RotateCcw, Edit, Paperclip, Image, Search, MoreVertical, Trash, X, FlaskConical, MoreHorizontal, Mic, Loader, FileText, FileDown, BookOpen, User, Settings, Home, ChevronRight, MessageCircle, Sparkles } from "lucide-react" // Added Icons
import ReactMarkdown from "react-markdown"
import remarkGfm from 'remark-gfm'
import { v4 as uuidv4 } from 'uuid'
import { TypewriterEffect } from "../components/typewriter"
import { useRouter } from "next/navigation"
import { cn } from "@/lib/utils"
import Joyride, { Step, CallBackProps, STATUS } from 'react-joyride'; // Import Joyride
import dynamic from 'next/dynamic'; // Import dynamic
import { performSerpApiSearch, formatSearchResults, formatSearchResultsForAI } from "../utils/serpApi";
import { downloadChatAsPdf } from '../utils/pdfExport';
import { generateChatSummary } from '../utils/chatSummary';
import ExportModal from '../components/ExportModal';
import SummaryModal from '../components/SummaryModal';
// Drag-and-Drop-Bibliotheken
import { DndContext, useDraggable, useDroppable, useSensors, useSensor, PointerSensor } from '@dnd-kit/core';
import { LoadingIndicator } from '@/components/LoadingIndicator'; // Corrected import path
import SettingsModal from '@/app/components/SettingsModal'; // Import the SettingsModal component

// Dynamically import Joyride with SSR disabled
const DynamicJoyride = dynamic(() => import('react-joyride'), { ssr: false });

// Define a simpler interface for CodeProps
interface CodeProps {
  node?: any
  inline?: boolean
  className?: string
  children?: React.ReactNode
}

interface Message {
  id: string
  role: 'user' | 'assistant' | 'system'
  content: string
  timestamp: Date
  isTypewriting?: boolean
  user_id?: string // Add user_id to track message sender
  sentfrom?: string // Add sentfrom to store user name directly
}

interface ChatSession {
  id: string
  name: string
  created_at: string
  description?: string
  project_id?: string | null
  last_message_timestamp?: string
  user_id?: string
}

interface Task {
  id: string
  title: string
  description: string
  system_prompt: string
  ai_model: string
  created_at?: string
  updated_at?: string
  user_id?: string
  workspace_id?: string | null
  project_id?: string | null
}

interface Project {
  id: string
  name: string
  description?: string
  user_id: string
  workspace_id?: string | null
  chats?: ChatSession[] // Chats, die zu diesem Projekt geh√∂ren
}

// Define structure for info items (used for buttons, tour content can be different)
interface InfoItem {
  title: string
  // We'll define tour steps separately now
}

// Keep infoItems simple for the buttons
const infoItems: InfoItem[] = [
  { title: "Tasks nutzen" },
  { title: "KI-Modell wechseln" },
  { title: "Nachrichten bearbeiten & neu generieren" },
  { title: "Chats verwalten" }
]

const initialMessages: Message[] = []

// Define Tour Steps (Adjust step 3)
const tourSteps: Step[] = [
  {
    target: '#task-select-button',
    content: (
      <>
        <p className="mb-2">Mit Tasks k√∂nnen Sie der KI spezifische Anweisungen oder eine bestimmte Rolle f√ºr den gesamten Chat zuweisen.</p>
        <p>Klicken Sie hier, um einen vorhandenen Task zu w√§hlen oder einen neuen zu erstellen. Tasks √ºberschreiben die manuelle Modellauswahl.</p>
      </>
    ),
    placement: 'bottom-end',
    title: "Tasks nutzen",
  },
  {
    target: '#model-select-button',
    content: (
      <>
        <p className="mb-2 text-sm">W√§hlen Sie hier das KI-Modell, wenn kein Task aktiv ist:</p>
        <ul className="mb-2 ml-4 list-inside list-disc space-y-1 text-sm">
          <li><strong>Basic (GPT-4o):</strong> Ausgewogen.</li>
          <li><strong>Fast (GPT-4o mini):</strong> Schnell & G√ºnstig.</li>
          <li><strong>Reason (GPT-4 Vision):</strong> Leistungsstark.</li>
        </ul>
      </>
    ),
    placement: 'bottom-end',
    title: "KI-Modell wechseln",
  },
  {
    target: '#chat-sidebar',
    content: 'Hier verwalten Sie Ihre Chats: Neuen Chat erstellen (+), Chat ausw√§hlen, umbenennen oder l√∂schen (√ºber die drei Punkte).',
    placement: 'right',
    title: "Chats verwalten",
  },
  {
    target: '#new-chat-button',
    content: 'Klicken Sie hier, um einen neuen, leeren Chat zu beginnen.',
    placement: 'left',
    title: "Neuer Chat",
    disableScrolling: true,
    disableOverlayClose: true,
    spotlightPadding: 5
  },
   {
    target: '#chat-input-textarea',
    content: 'Geben Sie hier Ihre Nachricht ein und dr√ºcken Sie Enter oder klicken Sie auf den Senden-Button.',
    placement: 'top',
    title: "Nachricht senden",
  }
];

// Helper function to fix the columns handling consistently
const getColumnNames = (columns: any[] | null): string[] => {
  return columns ? columns.map((col: { column_name: string }) => col.column_name) : [];
};

export default function Chat() {
  const searchParams = useSearchParams()
  const rawWorkspaceId = searchParams.get("workspace")
  const taskId = searchParams.get("task")
  
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [user, setUser] = useState<any>(null)
  const [workspace, setWorkspace] = useState<any>(null)
  const [userFullName, setUserFullName] = useState<string>("Du")
  const [messages, setMessages] = useState<Message[]>(initialMessages)
  const [inputValue, setInputValue] = useState('')
  const [isTyping, setIsTyping] = useState(false)
  const [showIceBreakers, setShowIceBreakers] = useState(false)
  const [showModelDropdown, setShowModelDropdown] = useState(false)
  const [selectedModel, setSelectedModel] = useState('gpt-4o')
  const [chatSessions, setChatSessions] = useState<ChatSession[]>([])
  const [currentChatId, setCurrentChatId] = useState<string | null>(null)
  const [tasks, setTasks] = useState<Task[]>([])
  const [selectedTask, setSelectedTask] = useState<Task | null>(null)
  const [showTaskDropdown, setShowTaskDropdown] = useState(false)
  const [showTaskModal, setShowTaskModal] = useState(false)
  const [newTask, setNewTask] = useState<Task>({
    id: '',
    title: '',
    description: '',
    system_prompt: '',
    ai_model: ''
  })
  const [newTaskName, setNewTaskName] = useState('')
  const [newTaskDescription, setNewTaskDescription] = useState('')
  const [newTaskSystemPrompt, setNewTaskSystemPrompt] = useState('')
  const [newTaskModel, setNewTaskModel] = useState('gpt-4o')
  const [showSidebar, setShowSidebar] = useState(true)
  const [typingMessageId, setTypingMessageId] = useState<string | null>(null)
  const [personalWorkspaceId, setPersonalWorkspaceId] = useState<string | null>(null)
  const [previousSelectedTask, setPreviousSelectedTask] = useState<Task | null>(null)
  const [previousSelectedModel, setPreviousSelectedModel] = useState<string | null>(null)
  const [messageUpdatePending, setMessageUpdatePending] = useState(false)
  const [isTaskSwitching, setIsTaskSwitching] = useState(false)
  const [lastMessageUpdate, setLastMessageUpdate] = useState(Date.now())
  
  // State f√ºr Projekte
  const [projects, setProjects] = useState<Project[]>([])
  const [selectedProject, setSelectedProject] = useState<Project | null>(null)
  const [showProjectDropdown, setShowProjectDropdown] = useState(false)
  const [showProjectModal, setShowProjectModal] = useState(false)
  const [newProjectName, setNewProjectName] = useState('')
  const [newProjectDescription, setNewProjectDescription] = useState('')
  const [projectMenuOpen, setProjectMenuOpen] = useState<string | null>(null)
  const [projectToRename, setProjectToRename] = useState<Project | null>(null)
  
  // State f√ºr Drag & Drop
  const [draggedChatId, setDraggedChatId] = useState<string | null>(null)
  const [activeDropTarget, setActiveDropTarget] = useState<string | null>(null)
  
  // State f√ºr aufgeklappte Projekte
  const [expandedProjects, setExpandedProjects] = useState<Record<string, boolean>>({})
  
  // State for editing messages
  const [editingMessageId, setEditingMessageId] = useState<string | null>(null)
  const [editingContent, setEditingContent] = useState('')
  
  // Add searchDebounceTimeout ref
  const searchDebounceTimeout = useRef<any>(null);
  
  const chatBodyRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLTextAreaElement>(null)
  const modelDropdownRef = useRef<HTMLDivElement>(null)
  const taskDropdownRef = useRef<HTMLDivElement>(null)
  const projectDropdownRef = useRef<HTMLDivElement>(null)
  
  const supabase = createClientComponentClient()
  
  // Add state for chat menu and rename functionality
  const [chatMenuOpen, setChatMenuOpen] = useState<string | null>(null)
  const [renameModalOpen, setRenameModalOpen] = useState(false)
  const [chatToRename, setChatToRename] = useState<ChatSession | null>(null)
  const [newChatName, setNewChatName] = useState('')
  // Neuer State f√ºr inline edit
  const [editingChatId, setEditingChatId] = useState<string | null>(null)
  
  const router = useRouter()
  
  // Add state and refs for the input action menu
  const [showInputMenu, setShowInputMenu] = useState(false);
  const inputMenuRef = useRef<HTMLDivElement>(null);
  const moreOptionsButtonRef = useRef<HTMLButtonElement>(null);
  
  // F√ºge einen Ref f√ºr die Edit-Box hinzu
  const editBoxRef = useRef<HTMLDivElement>(null);
  
  // Add state for the new info modal
  // const [showInfoModal, setShowInfoModal] = useState(false)
  // const [modalContent, setModalContent] = useState<InfoItem | null>(null)
  
  // Add state for React Joyride
  const [runTour, setRunTour] = useState(false);
  const [stepIndex, setStepIndex] = useState(0);
  
  // State to control showing fake messages during the tour
  const [showFakeMessagesForTour, setShowFakeMessagesForTour] = useState(false);
  
  // Define fake messages for the tour demonstration
  const fakeTourMessages: Message[] = [
    {
      id: 'fake-user-1',
      role: 'user',
      content: 'Das ist eine Beispiel-Nachricht des Benutzers.',
      timestamp: new Date(Date.now() - 120000) // 2 minutes ago
    },
    {
      id: 'fake-ai-message',
      role: 'assistant',
      content: 'Und hier ist eine Beispiel-Antwort der KI. Wenn Sie den Mauszeiger √ºber diese Nachricht bewegen, werden Aktionsbuttons angezeigt.',
      timestamp: new Date(Date.now() - 60000) // 1 minute ago
    }
  ];
  
  // Add loading state specifically for search
  const [isSearching, setIsSearching] = useState(false);
  // Add chat message search state
  const [searchOpen, setSearchOpen] = useState(false);
  const [messageSearchQuery, setMessageSearchQuery] = useState("");
  const [messageSearchResults, setMessageSearchResults] = useState<any[]>([]);
  
  // New state variables for the export and summary modals
  const [showExportModal, setShowExportModal] = useState(false);
  const [showSummaryModal, setShowSummaryModal] = useState(false);
  const [chatSummary, setChatSummary] = useState('');
  const [isSummarizing, setIsSummarizing] = useState(false);
  
  // State for showing the message actions dialog
  const [showMessageActionsDialog, setShowMessageActionsDialog] = useState(false);
  const [isImprovingPrompt, setIsImprovingPrompt] = useState(false)
  
  // Add the state for showing settings modal
  const [showSettingsModal, setShowSettingsModal] = useState(false); // Add state for settings modal
  
  // Add state for storing user names
  const [userNamesMap, setUserNamesMap] = useState<{[key: string]: string}>({});
  
  useEffect(() => {
    if (selectedTask && selectedTask.ai_model) {
      setSelectedModel(selectedTask.ai_model);
    }
  }, [selectedTask]);
  
  useEffect(() => {
    const fetchPersonalWorkspace = async () => {
      if (user) {
        console.log("Fetching personal workspace for user:", user.id);
        const { data, error } = await supabase
          .from('workspaces')
          .select('id')
          .eq('user_id', user.id)
          .eq('is_home', true)
          .single(); // Annahme: Es gibt nur EINEN pers√∂nlichen Workspace

        if (error && error.code !== 'PGRST116') { // Ignore ' esattamente uma linha esperada'
          console.error("Error fetching personal workspace:", error);
        } else if (data) {
          console.log("Personal workspace found:", data.id);
          setPersonalWorkspaceId(data.id);
        } else {
          console.warn("Personal workspace not found for user:", user.id);
          // Hier k√∂nnte man optional den Workspace erstellen, falls er fehlt
          // oder eine Fehlermeldung anzeigen.
        }
      }
    };
    if (user && !rawWorkspaceId) { // Nur laden, wenn kein Workspace in URL und User bekannt
       fetchPersonalWorkspace();
    }
  }, [user, supabase, rawWorkspaceId]); // Abh√§ngigkeiten
  
  // Optimierte Kontextauswahl mit Caching, besserer Priorisierung und Ausschluss aktueller Nachrichten
  // Cache f√ºr Chat-Sessions um redundante Ladevorg√§nge zu vermeiden
  const chatSessionsCache = {
    sessions: null,
    timestamp: 0,
    maxAge: 5000, // Cache ist f√ºr 5 Sekunden g√ºltig
  };

  // Cache f√ºr Projektberechnungen
  const projectsCache = {
    projectChats: null,
    timestamp: 0,
    maxAge: 10000, // Cache ist f√ºr 10 Sekunden g√ºltig
  };

  // Optimierte Funktion zum Laden von Chat-Sessions mit Caching
  const loadChatSessionsWithCache = async (userId, workspaceId) => {
    const now = Date.now();
    
    // Pr√ºfen, ob der Cache g√ºltig ist
    if (chatSessionsCache.sessions && (now - chatSessionsCache.timestamp) < chatSessionsCache.maxAge) {
      console.log('üì¶ Verwende gecachte Chat-Sessions');
      return chatSessionsCache.sessions;
    }
    
    console.log(`üîÑ Loading chat sessions - userId: ${userId} workspaceId: ${workspaceId}`);
    
    // Lade Daten wie zuvor
    const { data, error } = await supabase
      .from('chats')
      .select('*')
      .eq('user_id', userId)
      .eq('workspace_id', workspaceId)
      .order('updated_at', { ascending: false });
    
    if (error) {
      console.error('‚ùå Fehler beim Laden der Chat-Sessions:', error);
      return [];
    }
    
    console.log(`‚úÖ Loaded ${data.length} chat sessions`);
    
    // Verarbeite Daten und speichere sie im Cache
    const formattedSessions = data.map((chat: any) => ({
      id: chat.id,
      name: chat.name || 'Neuer Chat',
      timestamp: chat.updated_at,
      message_count: chat.message_count || 0,
      project: chat.project || null,
      temperature: chat.temperature,
      model: chat.model || null,
    }));
    
    // Cache aktualisieren
    chatSessionsCache.sessions = formattedSessions;
    chatSessionsCache.timestamp = now;
    
    return formattedSessions;
  };

  // Optimierte Funktion zur Projektberechnung mit Caching
  const recalculateProjectsWithCache = (chats) => {
    const now = Date.now();
    
    // Pr√ºfen, ob der Cache g√ºltig ist
    if (projectsCache.projectChats && (now - projectsCache.timestamp) < projectsCache.maxAge) {
      return projectsCache.projectChats;
    }
    
    console.log(`üî¢ Berechne Projekte neu aus ${chats.length} verf√ºgbaren Chats`);
    
    const projectChats = new Map();
    
    // Projekte berechnen wie zuvor
    const availableProjects = [...new Set(chats.filter(c => c.project).map(c => c.project))];
    
    availableProjects.forEach(project => {
      const chatsInProject = chats.filter(c => c.project === project);
      projectChats.set(project, chatsInProject);
      console.log(`üóÇÔ∏è Projekt ${project} hat ${chatsInProject.length} Chats`);
    });
    
    // Cache aktualisieren
    projectsCache.projectChats = projectChats;
    projectsCache.timestamp = now;
    
    return projectChats;
  };

  // Hauptfunktion f√ºr die Kontext-Suche, verbessert mit Ausschluss der aktuellen Nachricht
  const findSimilarMessagesOptimized = async (userId: string, query: string, currentMessageId: string | null = null) => {
    console.log(`üîç Suche nach √§hnlichen Nachrichten f√ºr User ${userId}`);
    console.log(`üìù Suchanfrage: "${query}"`);
    
    try {
      // Erstelle Embedding f√ºr die Anfrage
      console.log(`üß† Generiere Embedding f√ºr Suchanfrage...`);
      const embedding = await createEmbedding({ content: query, id: 'query', role: 'user', timestamp: new Date() }, "", null);
      
      if (!embedding) {
        console.error('‚ùå Fehler beim Generieren des Embeddings f√ºr die Suche');
        return [];
      }
      
      console.log(`‚úÖ Embedding f√ºr Abfrage erfolgreich generiert`);
      console.log(`üìä Query-Embedding-Dimensionen: ${embedding.length}`);
      console.log(`üîç Query-Embedding-Vorschau (erste 5 Werte): ${JSON.stringify(embedding.slice(0, 5))}`);
      
      // RPC f√ºr die √Ñhnlichkeitssuche aufrufen
      console.log(`üìû Rufe search_similar_messages RPC f√ºr User ${userId} auf (Schwellwert: 0.7, Max Ergebnisse: 15)`);
      
      const { data: results, error } = await supabase.rpc('search_similar_messages', {
        p_user_id: userId,
        query_embedding: embedding,
        similarity_threshold: 0.7,
        max_results: 15  // Erh√∂ht, um mehr Kandidaten zu haben
      });
      
      if (error) {
        console.error('‚ùå Fehler bei der RPC-Suche nach √§hnlichen Nachrichten:', error);
        return [];
      }
      
      console.log(`üîé RPC Ergebnis: ${results?.length || 0} Nachrichten gefunden`);
      console.log(`üìã Erste Ergebnisse (Rohdaten): ${JSON.stringify(results?.slice(0, 2) || [])}`);
      
      // Filtere die aktuelle Nachricht, falls vorhanden
      let filteredResults = results || [];
      if (currentMessageId) {
        const originalLength = filteredResults.length;
        filteredResults = filteredResults.filter((msg: any) => msg.id !== currentMessageId);
        if (originalLength !== filteredResults.length) {
          console.log(`üßπ Aktuelle Nachricht mit ID ${currentMessageId} aus Ergebnissen ausgeschlossen`);
        }
      }
      
      console.log(`üßπ Nach Filterung: ${filteredResults.length} Nachrichten √ºbrig`);
      
      // Verarbeite die Nachrichten wie zuvor, um Datumsinformationen zu extrahieren...
      console.log(`üîÑ Verarbeite Nachrichten, um Datumsinformationen zu extrahieren...`);
      
      for (const msg of filteredResults) {
        // Extrahiere Datum aus dem Nachrichteninhalt
        const dateMatch = msg.content_with_date?.match(/\[Datum: ([^\]]+)\]/);
        if (dateMatch && dateMatch[1]) {
          msg.dateInfo = dateMatch[1];
          console.log(`üìÖ Datum gefunden in Nachricht ${msg.id}: ${msg.dateInfo}`);
        } else {
          console.log(`‚ö†Ô∏è Kein Datum gefunden in Nachricht ${msg.id}`);
        }
        
        // Generiere eine anzeigbare Version des Inhalts ohne Datum
        msg.displayContent = msg.content_with_date?.replace(/\[Datum: [^\]]+\]\n/, '') || msg.content;
      }
      
      console.log(`‚úÖ ${filteredResults.length} √§hnliche Nachrichten nach Filterung gefunden`);
      
      return filteredResults;
    } catch (error) {
      console.error('‚ùå Fehler bei der Suche nach √§hnlichen Nachrichten:', error);
      return [];
    }
  };

  // Verbesserte Kontext-Auswahlfunktion mit optimierter Bewertung f√ºr neueste/√§lteste Nachrichten
  if (similarMessages.length > 0) {
    // Gruppiere Nachrichten nach Chat-ID
    const chatGroups = new Map<string, any[]>();
    
    // Schritt 1: Gruppiere Nachrichten nach Chats
    similarMessages.forEach((msg: any) => {
      if (!chatGroups.has(msg.chat_id)) {
        chatGroups.set(msg.chat_id, []);
      }
      chatGroups.get(msg.chat_id)?.push(msg);
    });
    
    // Sortiere Nachrichten innerhalb der Gruppen nach Erstellungszeit
    chatGroups.forEach((messages, _) => {
      messages.sort((a, b) => 
        new Date(a.created_at || 0).getTime() - new Date(b.created_at || 0).getTime()
      );
    });
    
    // Schritt 2: Berechne Relevanz-Score f√ºr jede Gruppe mit verbesserter Priorisierung
    const scoredGroups = Array.from(chatGroups.entries()).map(([chatId, messages]) => {
      // Basis√§hnlichkeit: Die durchschnittliche √Ñhnlichkeit der Top-2 Nachrichten
      const topSimilarities = messages
        .filter(msg => !msg.isContext) // Nur prim√§re Treffer, keine Kontext-Nachrichten
        .map(msg => msg.similarity || 0)
        .sort((a, b) => b - a)
        .slice(0, 2);
      
      const avgTopSimilarity = topSimilarities.length > 0 
        ? topSimilarities.reduce((sum, sim) => sum + sim, 0) / topSimilarities.length
        : 0;
      
      // Qualit√§t der Konversation: Bewerte Gespr√§che mit Rollenwechseln h√∂her
      let conversationQuality = 0;
      let roleChanges = 0;
      
      for (let i = 1; i < messages.length; i++) {
        if (messages[i].role !== messages[i-1].role) {
          roleChanges++;
        }
      }
      
      // Normalisiere auf einen Wert zwischen 0 und 0.15
      conversationQuality = Math.min(0.15, roleChanges * 0.05);
      
      // Zeitliche Relevanz: √Ñlteste und neueste Nachrichten bevorzugen
      // Bestimme den Zeitbereich der Nachrichten
      const datesWithInfo = messages
        .filter(msg => msg.dateInfo)
        .map(msg => new Date(msg.dateInfo).getTime());
      
      let timeRelevanceBonus = 0;
      
      if (datesWithInfo.length > 0) {
        const sortedDates = [...datesWithInfo].sort((a, b) => a - b);
        const oldestDate = sortedDates[0];
        const newestDate = sortedDates[sortedDates.length - 1];
        const now = new Date().getTime();
        
        // Bestimme, ob diese Gruppe die √§lteste oder neueste Information enth√§lt
        const isOldestInfo = messages.some(msg => 
          msg.dateInfo && new Date(msg.dateInfo).getTime() === oldestDate
        );
        
        const isNewestInfo = messages.some(msg => 
          msg.dateInfo && new Date(msg.dateInfo).getTime() === newestDate
        );
        
        // Neueste Information erh√§lt einen starken Bonus
        if (isNewestInfo) {
          const daysDiff = Math.floor((now - newestDate) / (1000 * 3600 * 24));
          timeRelevanceBonus += 0.3 * Math.max(0, 1 - (daysDiff / 14)); // Neuere Nachrichten innerhalb von 14 Tagen bekommen bis zu +0.3
        }
        
        // √Ñlteste Information erh√§lt auch einen Bonus
        if (isOldestInfo) {
          timeRelevanceBonus += 0.2; // Feste +0.2 f√ºr die erste Erw√§hnung eines Themas
        }
      }
      
      // Kombiniere alle Faktoren zum Gesamt-Score
      const score = avgTopSimilarity + conversationQuality + timeRelevanceBonus;
      
      return { chatId, messages, score, hasNewest: timeRelevanceBonus > 0.2, hasOldest: timeRelevanceBonus >= 0.2 };
    });
    
    // Sortiere Gruppen nach Score absteigend
    scoredGroups.sort((a, b) => b.score - a.score);
    
    // W√§hle die Top-3 relevantesten Gruppen
    const topGroups = scoredGroups.slice(0, 3);
    
    console.log(`üß† Ausgew√§hlte Chat-Gruppen f√ºr Kontext: ${topGroups.length}`);
    topGroups.forEach(group => {
      const topSimilarityMsg = group.messages
        .filter(msg => !msg.isContext)
        .reduce((max, msg) => msg.similarity > (max?.similarity || 0) ? msg : max, null);
      
      console.log(`  ‚Ä¢ Chat ${group.chatId.substring(0, 6)}... (Score: ${group.score.toFixed(2)}) mit ${group.messages.length} Nachrichten`);
      if (topSimilarityMsg) {
        console.log(`    Beste √úbereinstimmung: "${(topSimilarityMsg.displayContent || '').substring(0, 40)}..." (${topSimilarityMsg.similarity.toFixed(2)})`);
      }
      
      // Log f√ºr neueste/√§lteste Informationen
      if (group.hasNewest) {
        console.log(`    ‚≠ê Diese Gruppe enth√§lt die NEUESTEN Informationen zu diesem Thema`);
      }
      if (group.hasOldest) {
        console.log(`    üìú Diese Gruppe enth√§lt die √ÑLTESTEN Informationen zu diesem Thema`);
      }
    });
    
    // Formatiere Nachrichten f√ºr den Kontext
    let contextContent = '';
    
    topGroups.forEach(group => {
      const chatMessages = group.messages;
      
      // Extrahiere den Chat-Namen wenn m√∂glich
      const chatName = chatSessions.find(c => c.id === group.chatId)?.name || `Chat ${group.chatId.substring(0, 6)}...`;
      
      // Spezielle Hervorhebung f√ºr neueste/√§lteste Information
      let chatHeader = `Aus "${chatName}"`;
      if (group.hasNewest) {
        chatHeader += " (neueste Information)";
      }
      if (group.hasOldest && !group.hasNewest) {
        chatHeader += " (erste Erw√§hnung)";
      }
      
      // Beginne mit Chat-Header
      contextContent += `${chatHeader}:\n`;
      
      // F√ºge formatierte Nachrichten hinzu
      const formattedMessages = chatMessages.map(msg => {
        const dateInfo = msg.dateInfo ? `[${msg.dateInfo}] ` : '';
        const role = msg.role === 'user' ? 'Benutzer' : 'KI';
        return `${dateInfo}${role}: ${msg.displayContent || msg.content}`;
      }).join('\n');
      
      contextContent += formattedMessages + '\n\n';
    });
    
    // F√ºge den Kontext zur API-Anfrage hinzu
    apiMessages.push({
      role: 'system',
      content: `Relevanter Kontext aus fr√ºheren Gespr√§chen:\n\n${contextContent}\n\nDies sind Ausschnitte aus vorherigen Konversationen, die f√ºr die aktuelle Frage relevant sein k√∂nnten. Die mit "neueste Information" markierten Abschnitte enthalten den aktuellsten Stand zu diesem Thema, w√§hrend "erste Erw√§hnung" historischen Kontext bietet. Nutze diese Informationen, um eine informierte Antwort zu geben, besonders wenn der Benutzer sich auf bereits besprochene Themen bezieht.`
    });
  }
  const loadChatSessions = async (userId: string, workspaceId: string | null = null) => {
    try {
      console.log('üîÑ Loading chat sessions - userId:', userId, 'workspaceId:', workspaceId);
      
      // Verwende personalWorkspaceId als Fallback, wenn keine workspaceId √ºbergeben wird
      const targetWorkspaceId = workspaceId || personalWorkspaceId;
      
      // Build the query
      let query = supabase
        .from('chats')
        .select('id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id');
      
      // Properly handle null workspace IDs
      if (targetWorkspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Chats in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq('workspace_id', targetWorkspaceId);
      } else {
        // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is('workspace_id', null).eq('user_id', userId);
      }
      
      const { data, error } = await query
        .order('last_message_timestamp', { ascending: false });
      
      if (error) {
        console.error('‚ùå Error loading chat sessions:', error);
        setError(`Fehler beim Laden der Chats: ${error.message}`);
        throw error;
      }
      
      if (data) {
        console.log('‚úÖ Loaded', data.length, 'chat sessions');
        console.log('Chat data:', data); // Debug: Zeige die Chat-Daten
        
        const formattedSessions = data.map((chat: any) => ({
          id: chat.id || '', 
          name: chat.name || 'Unnamed Chat',
          created_at: chat.created_at || new Date().toISOString(),
          last_message_timestamp: chat.last_message_timestamp,
          user_id: chat.user_id, // Behalte user_id um den Ersteller anzuzeigen
          ...(chat.description && { description: chat.description }),
          project_id: chat.project_id
        }));
        
        console.log('Formatted sessions:', formattedSessions); // Debug: Zeige die formatierten Sessions
        setChatSessions(formattedSessions);
      } else {
        console.log('‚ÑπÔ∏è No chat sessions found');
        setChatSessions([]);
      }
    } catch (err) {
      console.error('‚ùå Error in loadChatSessions:', err);
      setChatSessions([]);
    }
  }
  
  const createNewChat = async () => {
    try {
      if (!user) {
        setError("Sie m√ºssen angemeldet sein, um einen Chat zu erstellen.");
        return null;
      }
      
      // Determine the workspace ID to use - simplify this logic
      const workspaceId = rawWorkspaceId || personalWorkspaceId;

      if (!workspaceId) {
        setError("Konnte keinen g√ºltigen Arbeitsbereich zum Erstellen des Chats finden.");
        return null;
      }

      console.log(`Creating new chat in workspace: ${workspaceId}`);
      
      // Create a new chat with a temporary name - we'll update it later
      const newChatId = uuidv4();
      const initialTitle = "Neuer Chat";
      
      // Create with retry to ensure it succeeds
      const { data: newChat, error } = await supabase
        .from("chats")
        .insert({
          id: newChatId,
          user_id: user.id,
          name: initialTitle,
          workspace_id: workspaceId,
          created_at: new Date().toISOString(),
          last_message_timestamp: new Date().toISOString()
        })
        .select()
        .single();
      
      if (error) {
        console.error(`‚ùå Error creating new chat: ${error.message}`);
        setError(`Fehler beim Erstellen des Chats: ${error.message}`);
        return null;
      }
      
      if (!newChat) {
        console.error('‚ùå No chat data returned after creation');
        setError("Fehler beim Erstellen des Chats: Keine Daten zur√ºckgegeben");
        return null;
      }
      
      console.log(`‚úÖ Successfully created new chat with ID: ${newChatId}`);
      
      // Set the current chat ID immediately
      setCurrentChatId(newChatId);
      
      // Wait for the database to properly register the new chat
      await new Promise(resolve => setTimeout(resolve, 300));
      
      // Reload chat sessions to update UI
      if (user) {
        await loadChatSessions(user.id, workspaceId);
      }
      
      return newChatId;
    } catch (err) {
      console.error('Error in createNewChat:', err);
      setError(`Fehler beim Erstellen des Chats: ${err instanceof Error ? err.message : 'Unbekannter Fehler'}`);
      return null;
    }
  };
  
  const loadChat = async (chatId: string) => {
    try {
      setCurrentChatId(chatId);
      
      // Try to get chat details first to confirm it exists
      const { data: chatData, error: chatError } = await supabase
        .from('chats')
        .select('id, name')
        .eq('id', chatId)
        .single();
        
      if (chatError) {
        console.error('Error fetching chat details:', chatError);
        return;
      }
      
      // Get chat messages - now only using chat_id
      const { data: messagesData, error: messagesError } = await supabase
        .from('chat_messages')
        .select('*')
        .eq('chat_id', chatId)
        .order('created_at', { ascending: true });
        
      if (messagesError) {
        console.error('Error fetching chat messages:', messagesError);
        setMessages([]);
        return;
      }
      
      if (messagesData && messagesData.length > 0) {
        // Transform to our Message format
        const transformedMessages = messagesData.map((msg: any) => ({
          id: uuidv4(),
          role: msg.role as 'user' | 'assistant' | 'system',
          content: msg.content,
          timestamp: new Date(msg.created_at),
          user_id: msg.user_id, // Store user_id from database
          sentfrom: msg.sentfrom // Store sentfrom from database
        }));
        
        setMessages(transformedMessages);
        console.log(`Loaded ${transformedMessages.length} messages for chat ${chatId}`);
        
        // Fetch usernames for all unique user_ids in messages
        const userIds = [...new Set(transformedMessages
          .filter(msg => msg.role === 'user' && msg.user_id)
          .map(msg => msg.user_id))];
          
        if (userIds.length > 0) {
          const { data: profilesData, error: profilesError } = await supabase
            .from('profiles')
            .select('id, full_name')
            .in('id', userIds);
            
          if (profilesError) {
            console.error('Error fetching user profiles:', profilesError);
          } else if (profilesData) {
            // Create a map of user_id to full_name
            const userNames: {[key: string]: string} = {};
            profilesData.forEach(profile => {
              userNames[profile.id] = profile.full_name;
            });
            setUserNamesMap(userNames);
          }
        }
      } else {
        console.log(`No messages found for chat ${chatId}`);
        setMessages([]);
      }
    } catch (err) {
      console.error('Error loading chat:', err);
      setMessages([]);
    }
  };
  
  const loadTasks = async (userId: string, workspaceId: string | null = null) => {
    try {
      let query = supabase
        .from('tasks')
        .select('*');
      
      // Workspace-Filter
      if (workspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Tasks in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq('workspace_id', workspaceId);
      } else {
        // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is('workspace_id', null).eq('user_id', userId);
      }
      
      const { data, error } = await query;
      
      if (error) throw error;
      
      if (data) {
        const formattedTasks = data.map(task => ({
          ...task,
          title: task.title || task.name,
          ai_model: task.ai_model || task.preferred_model || 'gpt-4o'
        }));
        setTasks(formattedTasks);
      }
    } catch (err) {
      console.error('Error loading tasks:', err);
    }
  }
  
  const loadProjects = async (userId: string, workspaceId: string | null = null) => {
    try {
      let query = supabase
        .from('projects')
        .select('*');
      
      // Workspace-Filter
      if (workspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Projekte in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq('workspace_id', workspaceId);
      } else {
        // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is('workspace_id', null).eq('user_id', userId);
      }
      
      const { data, error } = await query;
      
      if (error) throw error;
      
      if (data) {
        const formattedProjects = data.map(project => ({
          ...project,
          name: project.name || project.title,
          workspace_id: project.workspace_id || project.preferred_workspace_id || 'gpt-4o'
        }));
        setProjects(formattedProjects);
      }
    } catch (err) {
      console.error('Error loading projects:', err);
    }
  }
  
  useEffect(() => {
    const checkSession = async () => {
      try {
        setLoading(true)
        
        const { data: { session }, error: sessionError } = await supabase.auth.getSession()
        
        if (sessionError) throw new Error(`Session-Fehler: ${sessionError.message}`)
        
        if (!session) {
          setError("Keine aktive Session gefunden. Bitte melden Sie sich an.")
          return
        }
        
        setUser(session.user)
        
        // Fetch user's full name from profile
        try {
          const { data: profileData, error: profileError } = await supabase
            .from('profiles')
            .select('full_name')
            .eq('id', session.user.id)
            .single()
            
          if (profileError) {
            console.error('Error fetching user profile:', profileError)
          } else if (profileData?.full_name) {
            setUserFullName(profileData.full_name)
          }
        } catch (profileErr) {
          console.error('Error fetching user profile:', profileErr)
        }
        
        if (rawWorkspaceId) {
          localStorage.setItem("workspaceId", rawWorkspaceId);
          
          try {
            const { data: workspaceData, error: workspaceError } = await supabase
              .from("workspaces")
              .select("*")
              .eq("id", rawWorkspaceId)
              .single();
              
            if (workspaceError) {
              console.error("Error fetching workspace:", workspaceError);
            } else {
              setWorkspace(workspaceData);
            }
          } catch (err) {
            console.error("Error fetching workspace data:", err);
          }
        } else {
          localStorage.removeItem("workspaceId");
        }
        
        // Ersten vollst√§ndigen Ladevorgang durchf√ºhren - alle Chats im Workspace laden
        console.log("üîÑ Initial loading ALL chats in workspace");
        if (rawWorkspaceId) {
          await loadChatSessions(session.user.id, rawWorkspaceId);
        } else {
          await loadChatSessions(session.user.id);
        }
        
        // Wichtig: Merken, dass wir die Chats bereits geladen haben
        const initialChatsLoaded = true;
        
        console.log("Loaded chat sessions:", chatSessions);
        
        // Auch Tasks laden
        try {
          if (rawWorkspaceId) {
            await loadTasks(session.user.id, rawWorkspaceId);
          } else {
            await loadTasks(session.user.id);
          }
        } catch (err) {
          console.error("Error loading tasks:", err);
        }
        
        // Lade Projekte f√ºr den aktuellen Workspace
        try {
          if (rawWorkspaceId) {
            await loadProjects(session.user.id, rawWorkspaceId);
          } else {
            await loadProjects(session.user.id);
          }
        } catch (err) {
          console.error("Error loading projects:", err);
        }
        
        if (taskId) {
            const { data: taskData, error: taskError } = await supabase
              .from('tasks')
              .select('*')
              .eq('id', taskId)
              .single();
              
            if (taskError) {
            console.error("Error fetching task:", taskError);
          } else if (taskData) {
              setSelectedTask(taskData);
            setSelectedModel(taskData.ai_model || 'gpt-4o');
            
            if (messages.length === 0) {
              const systemMessage: Message = {
                  id: uuidv4(),
                  role: 'system',
                content: taskData.system_prompt,
                timestamp: new Date()
              };
              setMessages([systemMessage]);
            }
          }
        }
        
        // WICHTIG: Wir √ºberspringen den zweiten Ladevorgang, da wir bereits alle Chats geladen haben
        // Das verhindert, dass bereits geladene Chats durch einen gefilterten Satz ersetzt werden
        if (chatSessions.length === 0) {
          console.log("‚ö†Ô∏è No chats loaded yet, checking database directly");
          
          // Nur wenn keine Chats geladen wurden, direkten DB-Zugriff versuchen
          let latestChatsQuery = supabase
            .from('chats')
            .select('id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id');

          // Handle workspace filtering properly to avoid null UUID errors
          const targetWorkspaceId = rawWorkspaceId || personalWorkspaceId;
          if (targetWorkspaceId) {
            // Bei Workspace-Auswahl KEINE user_id-Filterung, um alle Workspace-Chats zu sehen
            latestChatsQuery = latestChatsQuery.eq('workspace_id', targetWorkspaceId);
          } else {
            // Nur f√ºr pers√∂nliche Chats nach user_id filtern
            latestChatsQuery = latestChatsQuery.is('workspace_id', null).eq('user_id', session.user.id);
          }

          const { data: latestChatData, error: latestChatError } = await latestChatsQuery
            .order('last_message_timestamp', { ascending: false });
            
          if (latestChatError) {
            console.error('Error fetching latest chats:', latestChatError);
          } else if (latestChatData && latestChatData.length > 0) {
            console.log("Setting chats from direct query:", latestChatData.length, "chats found");
            const formattedSessions = latestChatData.map((chat: any) => ({
              id: chat.id || '', 
              name: chat.name || 'Unnamed Chat',
              created_at: chat.created_at || new Date().toISOString(),
              project_id: chat.project_id,
              user_id: chat.user_id,
              last_message_timestamp: chat.last_message_timestamp,
              ...(chat.description && { description: chat.description })
            }));
            
            // Set state with the new value
            setChatSessions(formattedSessions);
              
            if (!currentChatId) {
              console.log("Setting current chat ID to:", latestChatData[0].id);
              setCurrentChatId(latestChatData[0].id);
              await loadChat(latestChatData[0].id);
            }
          }
        } else {
          console.log("‚úÖ Using already loaded chats, count:", chatSessions.length);
          
          // Setze den aktuellen Chat, wenn noch keiner ausgew√§hlt ist
          if (!currentChatId && chatSessions.length > 0) {
            console.log("Setting current chat to first available:", chatSessions[0].id);
            setCurrentChatId(chatSessions[0].id);
            await loadChat(chatSessions[0].id);
          }
        }
      } catch (err: any) {
        console.error("Chat init error:", err)
        setError(err.message)
      } finally {
        setLoading(false)
      }
    }
    
    checkSession()
  }, [])
  
  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])
  
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (modelDropdownRef.current && !modelDropdownRef.current.contains(event.target as Node)) {
        setShowModelDropdown(false)
      }
      
      if (taskDropdownRef.current && !taskDropdownRef.current.contains(event.target as Node)) {
        setShowTaskDropdown(false)
      }
      
      // Schlie√üe Chat-Men√º bei Klick au√üerhalb
      const chatMenuTarget = (event.target as Element)?.closest('[data-chat-menu]');
      if (chatMenuOpen && !chatMenuTarget) {
        setChatMenuOpen(null);
      }
      
      // Schlie√üe Projekt-Men√º bei Klick au√üerhalb
      const projectMenuTarget = (event.target as Element)?.closest('[data-project-menu]');
      if (projectMenuOpen && !projectMenuTarget) {
        setProjectMenuOpen(null);
      }
    }
    
    document.addEventListener('mousedown', handleClickOutside)
    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [chatMenuOpen, projectMenuOpen])
  
  // Haupt-Funktion zum Senden einer Nachricht an die API
  const sendMessageToAPI = async (messages: Message[], model: string, chatId: string) => {
    console.log(`üîÑ sendMessageToAPI aufgerufen mit Chat-ID: ${chatId}`);
    
    // Der aktuelle User sollte existieren, da wir authentifiziert sind
    const userId = user?.id;
    
    if (!userId) {
      console.error("‚ùå User ID fehlt beim Senden an API. Authentifizierungsproblem?");
      throw new Error("User ID ist erforderlich");
    }
    
    // Suche nach relevanten Nachrichten in der Vektordatenbank
    const lastUserMessage = [...messages].reverse().find(m => m.role === 'user');
    
    if (lastUserMessage) {
      console.log(`üîç Suche nach User-weiten Kontext f√ºr User ${userId}, basierend auf: ${lastUserMessage.content}`);
      // Verwende die optimierte Funktion und √ºbergebe die aktuelle Nachricht-ID zum Ausschlie√üen
      const currentMessageId = lastUserMessage.id || null;
      const similarMessages = await findSimilarMessagesOptimized(userId, lastUserMessage.content, currentMessageId);
      
      // Verarbeite die gefundenen √§hnlichen Nachrichten
        if (similarMessages && similarMessages.length > 0) {
        // Gruppiere Nachrichten nach Chat-ID f√ºr besseren Kontext
        const messagesByChat = new Map<string, any[]>();
        
        similarMessages.forEach(msg => {
          if (!messagesByChat.has(msg.chat_id)) {
            messagesByChat.set(msg.chat_id, []);
          }
          messagesByChat.get(msg.chat_id)?.push(msg);
        });
        
        // Sortiere Nachrichten innerhalb jedes Chats nach Erstellungsdatum
        messagesByChat.forEach((msgs, chatId) => {
          msgs.sort((a, b) => 
            new Date(a.created_at || 0).getTime() - new Date(b.created_at || 0).getTime()
          );
        });
          
          console.log(`‚úÖ ${similarMessages.length} √§hnliche Nachrichten als User-Kontext hinzugef√ºgt`);
        
        // Log f√ºr Debugging
        Array.from(messagesByChat.entries()).forEach(([chatId, msgs]) => {
          msgs.forEach((msg: any) => {
            const datePrefix = msg.dateInfo ? `(vom ${msg.dateInfo}) ` : '';
            const contextPrefix = msg.isContext ? '[Kontext] ' : '';
            console.log(`   - [Chat ${chatId.substring(0, 4)}...] ${contextPrefix}${datePrefix}${msg.displayContent.substring(0, 50)}... (√Ñhnlichkeit: ${msg.similarity.toFixed(2)})`);
          });
        });
        
        // Build the context for the API call
        const apiMessages = [];
        
        // Add system message
        apiMessages.push({
          role: 'system',
          content: 'Du bist ein digitaler AI-Mitarbeiter von EcomTask. Du unterst√ºtzt den User professionell und freundlich bei der Arbeit an individuellen Aufgaben und Projekten.'
        });
        
        // Add task-specific system prompt if available
        if (selectedTask?.system_prompt) {
          apiMessages.push({
            role: 'system',
            content: selectedTask.system_prompt
          });
        }
        
        // Add context from similar messages, preserving conversation flow
        if (similarMessages.length > 0) {
          // Gruppiere Nachrichten nach Chat-ID
          const chatGroups = new Map<string, any[]>();
          
          // Schritt 1: Gruppiere Nachrichten nach Chats
          similarMessages.forEach((msg: any) => {
            if (!chatGroups.has(msg.chat_id)) {
              chatGroups.set(msg.chat_id, []);
            }
            chatGroups.get(msg.chat_id)?.push(msg);
          });
          
          // Sortiere Nachrichten innerhalb der Gruppen nach Erstellungszeit
          chatGroups.forEach((messages, _) => {
            messages.sort((a, b) => 
              new Date(a.created_at || 0).getTime() - new Date(b.created_at || 0).getTime()
            );
          });
          
          // Schritt 2: Berechne Relevanz-Score f√ºr jede Gruppe
          const scoredGroups = Array.from(chatGroups.entries()).map(([chatId, messages]) => {
            // Basis√§hnlichkeit: Die durchschnittliche √Ñhnlichkeit der Top-2 Nachrichten
            const topSimilarities = messages
              .filter(msg => !msg.isContext) // Nur prim√§re Treffer, keine Kontext-Nachrichten
              .map(msg => msg.similarity || 0)
              .sort((a, b) => b - a)
              .slice(0, 2);
            
            const avgTopSimilarity = topSimilarities.length > 0 
              ? topSimilarities.reduce((sum, sim) => sum + sim, 0) / topSimilarities.length
              : 0;
            
            // Qualit√§t der Konversation: Bewerte Gespr√§che mit Rollenwechseln h√∂her
            let conversationQuality = 0;
            let roleChanges = 0;
            
            for (let i = 1; i < messages.length; i++) {
              if (messages[i].role !== messages[i-1].role) {
                roleChanges++;
              }
            }
            
            // Normalisiere auf einen Wert zwischen 0 und 0.15
            conversationQuality = Math.min(0.15, roleChanges * 0.05);
            
            // Zeitliche Relevanz: √Ñlteste und neueste Nachrichten bevorzugen
            // Bestimme den Zeitbereich der Nachrichten
            const datesWithInfo = messages
              .filter(msg => msg.dateInfo)
              .map(msg => new Date(msg.dateInfo).getTime());
            
            let timeRelevanceBonus = 0;
            
            if (datesWithInfo.length > 0) {
              const sortedDates = [...datesWithInfo].sort((a, b) => a - b);
              const oldestDate = sortedDates[0];
              const newestDate = sortedDates[sortedDates.length - 1];
              const now = new Date().getTime();
              
              // Bestimme, ob diese Gruppe die √§lteste oder neueste Information enth√§lt
              const isOldestInfo = messages.some(msg => 
                msg.dateInfo && new Date(msg.dateInfo).getTime() === oldestDate
              );
              
              const isNewestInfo = messages.some(msg => 
                msg.dateInfo && new Date(msg.dateInfo).getTime() === newestDate
              );
              
              // Neueste Information erh√§lt einen starken Bonus
              if (isNewestInfo) {
                const daysDiff = Math.floor((now - newestDate) / (1000 * 3600 * 24));
                timeRelevanceBonus += 0.3 * Math.max(0, 1 - (daysDiff / 14)); // Neuere Nachrichten innerhalb von 14 Tagen bekommen bis zu +0.3
              }
              
              // √Ñlteste Information erh√§lt auch einen Bonus
              if (isOldestInfo) {
                timeRelevanceBonus += 0.2; // Feste +0.2 f√ºr die erste Erw√§hnung eines Themas
              }
            }
            
            // Kombiniere alle Faktoren zum Gesamt-Score
            const score = avgTopSimilarity + conversationQuality + timeRelevanceBonus;
            
            return { chatId, messages, score, hasNewest: timeRelevanceBonus > 0.2, hasOldest: timeRelevanceBonus >= 0.2 };
          });
          
          // Sortiere Gruppen nach Score absteigend
          scoredGroups.sort((a, b) => b.score - a.score);
          
          // W√§hle die Top-3 relevantesten Gruppen
          const topGroups = scoredGroups.slice(0, 3);
          
          console.log(`üß† Ausgew√§hlte Chat-Gruppen f√ºr Kontext: ${topGroups.length}`);
          topGroups.forEach(group => {
            const topSimilarityMsg = group.messages
              .filter(msg => !msg.isContext)
              .reduce((max, msg) => msg.similarity > (max?.similarity || 0) ? msg : max, null);
            
            console.log(`  ‚Ä¢ Chat ${group.chatId.substring(0, 6)}... (Score: ${group.score.toFixed(2)}) mit ${group.messages.length} Nachrichten`);
            if (topSimilarityMsg) {
              console.log(`    Beste √úbereinstimmung: "${(topSimilarityMsg.displayContent || '').substring(0, 40)}..." (${topSimilarityMsg.similarity.toFixed(2)})`);
            }
          });
          
          // Formatiere Nachrichten f√ºr den Kontext
          let contextContent = '';
          
          topGroups.forEach(group => {
            const chatMessages = group.messages;
            
            // Extrahiere den Chat-Namen wenn m√∂glich
            const chatName = chatSessions.find(c => c.id === group.chatId)?.name || `Chat ${group.chatId.substring(0, 6)}...`;
            
            // Beginne mit Chat-Header
            contextContent += `Aus "${chatName}":\n`;
            
            // F√ºge formatierte Nachrichten hinzu
            const formattedMessages = chatMessages.map(msg => {
              const dateInfo = msg.dateInfo ? `[${msg.dateInfo}] ` : '';
              const role = msg.role === 'user' ? 'Benutzer' : 'KI';
              return `${dateInfo}${role}: ${msg.displayContent || msg.content}`;
            }).join('\n');
          
            contextContent += formattedMessages + '\n\n';
          });
          
          // F√ºge den Kontext zur API-Anfrage hinzu
          apiMessages.push({
            role: 'system',
            content: `Relevanter Kontext aus fr√ºheren Gespr√§chen:\n\n${contextContent}\n\nDies sind Ausschnitte aus vorherigen Konversationen, die f√ºr die aktuelle Frage relevant sein k√∂nnten. Nutze diese Informationen, um eine informierte Antwort zu geben, besonders wenn der Benutzer sich auf bereits besprochene Themen bezieht.`
          });
        }
        
        // Add the actual conversation messages
        messages.forEach(msg => {
          if (msg.role !== 'system') { // Skip system messages as we already added them above
            apiMessages.push({
              role: msg.role,
              content: msg.content
            });
          }
        });
        
        console.log(`üì© Sende an API: ${messages.filter(m => m.role !== 'system').length} Nachrichten, davon ${apiMessages.length - messages.filter(m => m.role !== 'system').length} Kontextnachrichten`);
        
        // Call API
        const apiUrl = `/api/chat?model=${encodeURIComponent(model)}&chatId=${encodeURIComponent(chatId)}`;
        const apiResponse = await fetch(apiUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            messages: apiMessages,
          }),
        });
        
        if (!apiResponse.ok) {
          throw new Error(`API responded with ${apiResponse.status}`);
        }
        
        const data = await apiResponse.json();
        return data;
        } else {
        console.log("‚ÑπÔ∏è Keine √§hnlichen Nachrichten gefunden.");
      }
    }
    
    // Proceed without context if no similar messages or no last user message
    const apiMessages = messages.map(m => ({
      role: m.role,
      content: m.content
    }));
    
    console.log(`üì© Sende an API: ${apiMessages.length} Nachrichten ohne zus√§tzlichen Kontext`);
    
    const apiUrl = `/api/chat?model=${encodeURIComponent(model)}&chatId=${encodeURIComponent(chatId)}`;
    const apiResponse = await fetch(apiUrl, {
      method: 'POST',
        headers: {
        'Content-Type': 'application/json',
        },
        body: JSON.stringify({
        messages: apiMessages,
      }),
    });
    
    if (!apiResponse.ok) {
      throw new Error(`API responded with ${apiResponse.status}`);
    }
    
    const data = await apiResponse.json();
    return data;
  };
  
  const handleTypewriterComplete = (messageId: string) => {
    const updatedMessages = messages.map(m => 
      m.id === messageId ? { ...m, isTypewriting: false } : m
    )
    setMessages(updatedMessages)
    setTypingMessageId(null)
  }
  
  const handleCreateTask = async () => {
    if (!newTaskName.trim()) return;
    
    try {
      setLoading(true);
      
      const workspaceContext = rawWorkspaceId || null;
      
      const { data, error } = await supabase
        .from('tasks')
        .insert({
          title: newTaskName,
          description: newTaskDescription,
          system_prompt: newTaskSystemPrompt,
          ai_model: newTaskModel,
          status: 'todo',
          priority: 'medium',
          user_id: user.id,
          workspace_id: workspaceContext
        })
        .select();

      if (error) throw error;

      await loadTasks(user.id, workspaceContext);
      
      setShowTaskModal(false);
      setNewTaskName('');
      setNewTaskDescription('');
      setNewTaskSystemPrompt('');
      setNewTaskModel('gpt-4o');
      
    } catch (err) {
      console.error('Error creating task:', err);
    } finally {
      setLoading(false);
    }
  };
  
  const handleCreateProject = async () => {
    if (!newProjectName.trim()) return;

    try {
      setLoading(true);

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;

      // ---> START DEBUG LOG <---
      console.log("--- Creating Project --- ");
      console.log("User ID to send:", user?.id);
      console.log("Raw Workspace ID from URL:", rawWorkspaceId);
      console.log("Personal Workspace ID state:", personalWorkspaceId);
      console.log("Workspace Context to send:", workspaceContext);
      // ---> END DEBUG LOG <---

      // ---> ADDED AUTH CHECK <---
      const { data: authData, error: authError } = await supabase.auth.getSession();
      console.log("--- Auth Check Before Insert ---");
      console.log("Current Session:", authData?.session);
      console.log("Session User ID:", authData?.session?.user?.id);
      console.log("Auth Error:", authError);
      if (authError || !authData?.session) {
          console.error("CRITICAL: No valid session before insert!");
          // Optionally: Prevent the insert or show an error to the user
          // return;
      }
      // ---> END AUTH CHECK <---

      // ---> ADDED DIAGNOSTIC FUNCTION <---
      // This immediately runs when you click "Create Project" in the UI
      // It helps diagnose why the workspace membership check fails
      console.log("--- Running Diagnostic Function ---");
      const diagResult = await supabase.rpc('diagnose_workspace_membership', {
        p_user_id: user.id,
        p_workspace_id: workspaceContext
      });
      console.log("Diagnosis Result:", diagResult);
      // Explicit logging of the important diagnostic data
      console.log("MEMBERSHIP DATA:", JSON.stringify(diagResult.data, null, 2));
      if (diagResult.data) {
        console.log("User ID Input:", diagResult.data.user_id_input);
        console.log("Workspace ID Input:", diagResult.data.workspace_id_input);
        console.log("Membership Exists:", diagResult.data.membership_exists);
        console.log("Membership Count:", diagResult.data.membership_count);
        console.log("All User Workspaces:", diagResult.data.all_user_workspaces);
        console.log("All Workspace Members:", diagResult.data.all_workspace_members);
      }
      // ---> END DIAGNOSTIC FUNCTION <---

      // Use the database function instead of direct table access
      // This bypasses RLS issues while maintaining security checks in the function
      const { data, error } = await supabase
        .rpc('create_project', {
          p_name: newProjectName,
          p_description: newProjectDescription,
          p_user_id: user.id,
          p_workspace_id: workspaceContext,
          p_color: '#4c4cff',
          p_status: 'active'
        });

      if (error) throw error;

      await loadProjects(user.id, workspaceContext);
      setShowProjectModal(false);
      setNewProjectName('');
      setNewProjectDescription('');

    } catch (err) {
      console.error('Error creating project:', err);
    } finally {
      setLoading(false);
    }
  }
  
  // Generate a chat name from the first user message
  const generateChatName = (message: string): string => {
    // Split the message into words
    const words = message.trim().split(/\s+/);
    
    // Get up to the first 3 words
    const firstThreeWords = words.slice(0, 3).join(' ');
    
    // If the result is too short, use "Neuer Chat"
    return firstThreeWords.length >= 3 ? firstThreeWords : "Neuer Chat";
  };
  
  // Modifiziere den useEffect f√ºr Task-Wechsel
  useEffect(() => {
    // Only perform task change operations if no message update is pending
    // And ensure at least 500ms has passed since the last message update
    const timeSinceLastUpdate = Date.now() - lastMessageUpdate;
    if (messageUpdatePending || timeSinceLastUpdate < 500) {
      console.log("Message update in progress or too recent, deferring task change handling");
      return;
    }
    
    const handleTaskOrModelChange = async () => {
      // Pr√ºfen, ob es sich um einen Task- oder Modellwechsel handelt
      const isTaskChange = selectedTask?.id !== previousSelectedTask?.id;
      // const isModelChange = selectedModel !== previousSelectedModel && !selectedTask;
      
      // Run this logic ONLY on task change, not on simple model selection
      if (isTaskChange && messages.length > 0) {
        // Wenn eine Task oder ein Modell gewechselt wurde und es Nachrichten gibt
        
        console.log("Task wurde gewechselt, erstelle Zusammenfassung...");
        
        try {
          // Pr√ºfe, ob bereits eine Zusammenfassung im Chat existiert
          const lastSummaryMessage = [...messages]
            .reverse()
            .find(msg => 
              msg.role === 'assistant' && 
              (msg.content.includes('Chat-Zusammenfassung') || 
               msg.content.includes('Hauptpunkte:') || 
               msg.content.includes('Zusammenfassung des Chats'))
            );
          
          let summary: string;
          
          if (lastSummaryMessage) {
            // Verwende die vorhandene Zusammenfassung
            console.log("Verwende vorhandene Zusammenfassung");
            summary = lastSummaryMessage.content;
          } else {
            // Erstelle eine neue Zusammenfassung, da keine vorhanden ist
            console.log("Erstelle neue Zusammenfassung f√ºr Task-Wechsel");
            summary = await generateChatSummary(messages);
          }
          
          if (summary) {
            // Erstelle eine neue System-Nachricht mit der Zusammenfassung
            const summarySystemMessage: Message = {
              id: uuidv4(),
              role: 'system',
              content: `Zusammenfassung des bisherigen Gespr√§chs: ${summary}

${selectedTask ? selectedTask.system_prompt : "Fahre mit dem Gespr√§ch fort, basierend auf dieser Zusammenfassung."}`,
              timestamp: new Date()
            };
            
            // Entferne alle bisherigen System-Nachrichten
            const filteredMessages = messages.filter(m => m.role !== 'system');
            
            // F√ºge die neue System-Nachricht am Anfang hinzu
            setMessages([summarySystemMessage, ...filteredMessages]);
            
            console.log("Zusammenfassung wurde als System-Nachricht hinzugef√ºgt.");
            
            // Task-switching notification message is REMOVED
          }
        } catch (error) {
          console.error("Error in task change handling:", error);
        } finally {
          // Always set isTaskSwitching to false when complete
          setIsTaskSwitching(false);
        }
      } else {
        // If there's no task change or no messages, just reset the switching state
        setIsTaskSwitching(false);
      }
      
      // Aktuelle Task und Modell f√ºr den n√§chsten Vergleich speichern
      setPreviousSelectedTask(selectedTask);
      setPreviousSelectedModel(selectedModel);
    };
    
    handleTaskOrModelChange();
  }, [selectedTask, selectedModel, messages, messageUpdatePending, previousSelectedTask, previousSelectedModel, lastMessageUpdate]);
  
  // Add this function to sync messages with the database when needed
  const syncMessagesWithDatabase = async (chatId: string) => {
    if (!chatId) return;
    
    try {
      console.log('Syncing messages with database for chat:', chatId);
      const { data, error } = await supabase
        .from("chat_messages")
        .select('*')
        .eq('chat_id', chatId)
        .order('created_at', { ascending: true });
        
      if (error) {
        console.error('Error syncing messages:', error);
        return;
      }
      
      if (data) {
        // Convert database messages to app message format
        const formattedMessages: Message[] = data.map(dbMsg => ({
          id: dbMsg.id || uuidv4(),
          role: dbMsg.role as 'user' | 'assistant' | 'system',
          content: dbMsg.content,
          timestamp: new Date(dbMsg.created_at)
        }));
        
        console.log(`Synced ${formattedMessages.length} messages from database`);
        setMessages(formattedMessages);
      }
    } catch (error) {
      console.error('Error in syncMessagesWithDatabase:', error);
    }
  };

  // Modify handleSendMessage to optionally include web search results
  const handleSendMessage = async (message: string, includeWebSearch: boolean = false) => {
    if (message.trim().length === 0) return;
    if (isTyping || messageUpdatePending || isTaskSwitching) return;

    const userMessageId = uuidv4();
    const newMessage: Message = {
      id: userMessageId,
      role: 'user',
      content: message,
      timestamp: new Date(),
      user_id: user?.id,
      sentfrom: userFullName
    };

    console.log("Creating new message with user_id:", user?.id);

    try {
      // Prevent task switching effects during message sending
      setMessageUpdatePending(true);
      setLastMessageUpdate(Date.now());
      
      // Create the new array *before* setting state
      const newMessagesArray = [...messages, newMessage];
      
      // Add user message to state immediately for better UX
      setMessages(newMessagesArray); // Use the new array
      setInputValue(''); // Eingabefeld leeren
      
      // Show typing indicator
      setIsTyping(true);
      
      // If web search is requested, perform it before sending to API
      let webSearchResults = null;
      if (includeWebSearch) {
        setIsSearching(true);
        try {
          webSearchResults = await performSerpApiSearch(message);
          console.log("Web search results:", webSearchResults.length);
        } catch (searchError) {
          console.error("Error during web search:", searchError);
        } finally {
          setIsSearching(false);
        }
      }
      
      let chatIdToUse = currentChatId;
      
      // If no current chat exists, create a new one before proceeding
      if (!chatIdToUse) {
        console.log('No current chat, creating new one before sending message...');
        chatIdToUse = await createNewChat();
        if (!chatIdToUse) {
          throw new Error('Failed to create a new chat');
        }
        console.log(`Successfully created new chat with ID: ${chatIdToUse}`);
      }
      
      // Save the message to the database immediately, with retries
      console.log(`Saving message to chat ID: ${chatIdToUse}`);
      
      // For embedding only, not stored in the displayed message
      const currentDate = new Date().toISOString().split('T')[0]; 
      
      const { data: messageData, error: messageError } = await retryOperation(async () => {
        return await supabase
          .from("chat_messages")
          .insert({
            chat_id: chatIdToUse,
            role: 'user',
            content: message, // Store original message without date
            user_id: user?.id,
            sentfrom: userFullName,
            created_at: newMessage.timestamp.toISOString()
          })
          .select();
      }, 3, 1000);

        if (messageError) {
          console.error('‚ùå Error saving message:', messageError);
        // Keep the message in UI state but log the error
        } else {
          console.log('‚úÖ Message saved successfully to database', messageData);
          
          // Verwende die tats√§chliche DB-ID f√ºr das Embedding
          if (messageData && messageData.length > 0) {
            const dbMessage = {
              ...newMessage,
              id: messageData[0].id // √úberschreibe die lokale ID mit der DB-ID
            };
            await createEmbedding(dbMessage, chatIdToUse, rawWorkspaceId || null);
          }
          
          // Generate chat title for new chats
          if (!currentChatId && chatIdToUse) {
            // Set current chat ID so we maintain context
            setCurrentChatId(chatIdToUse);
            // Generate title asynchronously
            generateAndSetChatTitle(chatIdToUse, message);
          }
          
          // Reload chat sessions to update UI
            if (user) {
              await loadChatSessions(user.id, rawWorkspaceId || null);
          }
        }
        
        // Now get the AI response
        try {
          // Prepare messages for the API with the exact required order
          const apiMessages: Message[] = [];
          
          // 1. Add the fixed EcomTask AI system message as the first message
          apiMessages.push({
            role: 'system',
            content: 'Du bist ein digitaler AI-Mitarbeiter von EcomTask. Du unterst√ºtzt den User professionell und freundlich bei der Arbeit an individuellen Aufgaben und Projekten.',
            id: uuidv4(),
            timestamp: new Date()
          });
          
          // 2. Add task-specific system prompt if available
          if (selectedTask?.system_prompt) {
            apiMessages.push({
              role: 'system',
              content: selectedTask.system_prompt,
              id: uuidv4(),
              timestamp: new Date()
            });
          }
          
          // 3. Add additional context (like web search results) if available
          if (webSearchResults && webSearchResults.length > 0) {
            const searchResultText = formatSearchResultsForAI(webSearchResults);
            apiMessages.push({
              role: 'system',
              content: `Web search results for "${message}":\n\n${searchResultText}\n\nUse these results to inform your response.`,
              id: uuidv4(),
              timestamp: new Date()
            });
          }
          
          // 4. Add the user message last
          apiMessages.push({
            role: 'user',
            content: message,
            id: newMessage.id,
            timestamp: newMessage.timestamp
          });

          // Call the API with the properly structured messages
          const modelToUse = selectedTask?.ai_model || selectedModel;
          
          // Immer die aktuelle Chat-ID verwenden, die jetzt gesetzt sein sollte
          console.log("üì£ Sende Nachricht an API mit Chat-ID:", chatIdToUse);
             // √úbergebe das *gesamte* newMessagesArray (den aktuellen Verlauf) an sendMessageToAPI
   console.log("üöÄ Sending complete history to sendMessageToAPI (handleSendMessage)");
   const response = await sendMessageToAPI(newMessagesArray, modelToUse, chatIdToUse);
          
          // Create assistant message
          const assistantMessageId = uuidv4();
          const assistantMessage: Message = {
            id: assistantMessageId,
            role: 'assistant',
            content: response.content,
            timestamp: new Date(),
            isTypewriting: true
          };
          
          // Update messages with AI response
          setMessages(prevMessages => [...prevMessages, assistantMessage]);
          setTypingMessageId(assistantMessageId);
          
          // Save assistant message to database
          if (chatIdToUse) {
            const { data: aiMessageData, error: aiMessageError } = await supabase
              .from("chat_messages")
              .insert({
                chat_id: chatIdToUse,
                role: 'assistant',
                content: assistantMessage.content, // Store original content without date
                user_id: user?.id,
                sentfrom: "KI-Assistent", // Standard KI-Name
                created_at: assistantMessage.timestamp.toISOString()
              })
              .select();
              
            if (aiMessageError) {
              console.error('‚ùå Error saving AI message:', aiMessageError);
            } else {
              console.log('‚úÖ AI message saved to database', aiMessageData);
              
              // Create embedding for the assistant message
              if (aiMessageData && aiMessageData.length > 0) {
                const dbAssistantMessage = {
                  ...assistantMessage,
                  id: aiMessageData[0].id // √úberschreibe die lokale ID mit der DB-ID
                };
                await createEmbedding(dbAssistantMessage, chatIdToUse, rawWorkspaceId || null);
              }
              
              // Reload chat sessions to update last_message_timestamp
              if (user) {
                await loadChatSessions(user.id, rawWorkspaceId || null);
              }
            }
          }
        } catch (apiError) {
          console.error("Error getting AI response:", apiError);
          // Add error message to the chat
          const errorMessage: Message = {
              id: uuidv4(),
              role: 'assistant',
            content: "Es ist ein Fehler bei der Kommunikation mit der KI aufgetreten. Bitte versuchen Sie es erneut.",
              timestamp: new Date()
          };
          setMessages(prevMessages => [...prevMessages, errorMessage]);
        }
      } catch (error) {
        console.error("Error sending message:", error);
        setError(`Fehler beim Senden der Nachricht: ${error instanceof Error ? error.message : 'Unbekannter Fehler'}`);
      } finally {
        setIsTyping(false);
        setMessageUpdatePending(false);
        // Update the timestamp again to ensure task changes wait
        setLastMessageUpdate(Date.now());
      }
  }
  
  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    handleSendMessage(inputValue);
  };
  
  const getModelLabel = (modelId: string | null): string => {
    // Map actual model IDs back to friendly names
    switch(modelId) {
      // Direkte Namen (keine Umwandlung n√∂tig)
      case 'Basic': 
        return 'Basic';
      case 'Fast':
        return 'Fast';
      case 'Reason':
        return 'Reason';
      case 'Reason+':
        return 'Reason+';
      
      // Alte technische IDs f√ºr Abw√§rtskompatibilit√§t
      case 'gpt-4o-2024-11-20': 
        return 'Basic';
      case 'gpt-4o-mini-2024-07-18':
        return 'Fast';
      case 'o3-mini-2025-01-31':
        return 'Reason';
      case 'gpt-4.5-preview-2025-02-27':
        return 'Reason+';
      
      // Sehr alte IDs f√ºr Abw√§rtskompatibilit√§t
      case 'gpt-4o': 
        return 'Basic';
      case 'gpt-4o-mini':
        return 'Fast';
      case 'gpt-4-vision-preview':
        return 'Reason';
      default:
        // Standardwert
        return modelId || 'Basic';
    }
  };
  
  // Function to copy message content to clipboard
  const copyToClipboard = (text: string) => {
    navigator.clipboard.writeText(text)
      .then(() => {
        // Could show a toast notification here
        console.log('Copied to clipboard');
      })
      .catch(err => {
        console.error('Failed to copy: ', err);
      });
  };
  
  // Function to start editing a user message
  const startEditMessage = (message: Message) => {
    setEditingMessageId(message.id);
    setEditingContent(message.content);
  };
  
  // Function to cancel editing
  const cancelEditMessage = () => {
    setEditingMessageId(null);
    setEditingContent('');
  };
  
  // Function to save the edited message and resubmit
  const handleSaveEdit = async () => {
    if (!editingMessageId || !editingContent.trim()) return;
    
    const messageIndex = messages.findIndex(m => m.id === editingMessageId);
    if (messageIndex === -1) return;
    
    // Get the original message
    const originalMessage = messages[messageIndex];
    
    // Keep messages up to but NOT including the one being edited
    const messagesToKeep = messages.slice(0, messageIndex);
    
    // Reset editing state
    const editedContent = editingContent.trim(); // Store content before resetting state
    setEditingMessageId(null);
    setEditingContent('');
    
    console.log('Starting message edit process, deleting original and subsequent messages...');
    
    // Create a timestamp for the edited message that preserves the original position
    const editedMessageTimestamp = new Date(originalMessage.timestamp);
    editedMessageTimestamp.setMilliseconds(editedMessageTimestamp.getMilliseconds() + 1);
    
    // Create a new user message with the edited content
    const newUserMessageId = uuidv4();
    const userMessage: Message = {
      id: newUserMessageId,
      role: 'user',
      content: editedContent,
      timestamp: editedMessageTimestamp
    };
    
    // Set messages state directly with just the kept messages and edited message
    setMessages([...messagesToKeep, userMessage]);
    
    // Create timestamp for AI response that's 1ms after the edited message
    const aiResponseTimestamp = new Date(editedMessageTimestamp);
    aiResponseTimestamp.setMilliseconds(aiResponseTimestamp.getMilliseconds() + 1);
    
    // Delete all subsequent messages from database using a stored procedure
    if (currentChatId && user) {
      try {
        console.log('Attempting deletion via RPC force_delete_messages for chat ID', currentChatId);
        
        // STEP 1: Fetch message IDs that need to be deleted
        const { data: messagesToDelete, error: fetchError } = await supabase
          .from('chat_messages')
          .select('id') // Only need IDs
          .eq('chat_id', currentChatId)
          .gte('created_at', originalMessage.timestamp.toISOString());
        
        if (fetchError) {
          console.error('Error fetching message IDs to delete:', fetchError);
          throw new Error('Failed to fetch messages for deletion');
        }
        
        if (messagesToDelete && messagesToDelete.length > 0) {
          const messageIds = messagesToDelete.map(msg => msg.id);
          console.log(`Found ${messageIds.length} message IDs to delete:`, messageIds);
          
          // STEP 2: Call the stored procedure via RPC
          const { data: deletedCount, error: rpcError } = await supabase.rpc(
            'force_delete_messages',
            { message_ids: messageIds } // √úbergabe der IDs als benanntes Argument
          );
          
          if (rpcError) {
            console.error('RPC call to force_delete_messages failed:', rpcError);
            // Hier k√∂nnten wir noch Fallback-Methoden einbauen, aber lassen wir es erstmal weg,
            // um zu sehen, ob die Hauptmethode funktioniert.
          } else {
            console.log(`Stored procedure force_delete_messages reported ${deletedCount} messages deleted.`);
          }
          
          // STEP 3: Verify deletion worked (wait a moment first)
          await new Promise(resolve => setTimeout(resolve, 1000)); 
          
          const { data: remainingMessages, error: verifyError } = await supabase
            .from('chat_messages')
            .select('id')
            .eq('chat_id', currentChatId)
            .gte('created_at', originalMessage.timestamp.toISOString());
            
          if (verifyError) {
            console.error('Error verifying message deletion:', verifyError);
          } else if (remainingMessages && remainingMessages.length > 0) {
            console.error(`CRITICAL ERROR (even with RPC): ${remainingMessages.length} messages still remain. Problem might be deeper.`);
            console.log('Remaining message IDs:', remainingMessages.map(m => m.id));
          } else {
            console.log('Verification successful: All messages seem to be properly deleted from database via RPC.');
          }
        } else {
          console.log('No messages found that match the deletion criteria');
        }
      } catch (error) {
        console.error('Error during RPC message deletion process:', error);
      }
    } else {
      console.error("Cannot delete messages: currentChatId or user object is missing.");
    }
    
    // Now insert the new edited message
    if (currentChatId) {
      try {
        const { error: insertError } = await supabase
          .from("chat_messages")
          .insert({
            chat_id: currentChatId,
            role: 'user',
            content: editedContent,
            user_id: user?.id, // Make sure user_id is included in database insert
            created_at: editedMessageTimestamp.toISOString()
          });
        
        if (insertError) {
          console.error('Error saving edited message:', insertError);
        } else {
          console.log('Edited message saved to database successfully with timestamp:', editedMessageTimestamp.toISOString());
          
          // Neu: Lade die Chat-Liste neu, um die Sortierung zu aktualisieren
          if (user) {
            await loadChatSessions(user.id, rawWorkspaceId || null);
          }
        }
      } catch (insertErr) {
        console.error('Error during message insertion:', insertErr);
      }
    }
    
    // Now get the AI response for the edited message
    try {
      // First prepare the messages for the API
      const apiMessages = [...messagesToKeep, userMessage].map(m => ({
        role: m.role,
        content: m.content,
        id: m.id,
        timestamp: m.timestamp
      }));
      
      // Ensure system messages come first
      apiMessages.sort((a, b) => {
        if (a.role === 'system') return -1;
        if (b.role === 'system') return 1;
        return 0;
      });
      
      // Set typing state
      setIsTyping(true);
      
      // Call API
      const modelToUse = selectedTask?.ai_model || selectedModel;
         // √úbergebe das *gesamte* currentMessages Array (den aktuellen Verlauf) an sendMessageToAPI
   console.log("üöÄ Sending complete history to sendMessageToAPI (handleSaveEdit)");
   const response = await sendMessageToAPI(messages, modelToUse, currentChatId);      
      // Create assistant message with sequential timestamp
      const assistantMessageId = uuidv4();
      const assistantMessage: Message = {
        id: assistantMessageId,
        role: 'assistant',
        content: response.content,
        timestamp: new Date(),
        isTypewriting: true
      };
      
      // Update messages with the AI response - use the current state to avoid race conditions
      setMessages(currentMessages => [...currentMessages, assistantMessage]);
      setTypingMessageId(assistantMessageId);
      
      // Save assistant message to database
      if (currentChatId) {
        try {
          console.log('üí¨ Saving AI response for chat:', currentChatId);
          
          // Add the missing currentDate definition
          const currentDate = new Date().toISOString().split('T')[0]; // Format: YYYY-MM-DD
          
          const { error: aiInsertError } = await supabase
            .from("chat_messages")
            .insert({
              chat_id: currentChatId,
              role: 'assistant',
              content: `[Datum: ${currentDate}]\n${assistantMessage.content}`, // Add date to AI messages too
              user_id: user?.id, // Make sure user_id is included in database insert
              created_at: aiResponseTimestamp.toISOString()
            });

          if (aiInsertError) {
            console.error('‚ùå Error saving AI response:', aiInsertError);
          } else {
            console.log('‚úÖ AI response saved, reloading chat sessions...');
            // Neu: Lade die Chat-Liste neu, um die Sortierung zu aktualisieren
            if (user) {
              await loadChatSessions(user.id, rawWorkspaceId || null);
            }
          }
        } catch (aiInsertErr) {
          console.error('‚ùå Error during AI message insertion:', aiInsertErr);
        }
      }
    } catch (error) {
      console.error("API request failed:", error);
      // Add error message
      setMessages([
        ...messagesToKeep, 
        userMessage,
        {
          id: uuidv4(),
          role: 'assistant',
          content: "Sorry, es ist ein Fehler aufgetreten. Bitte versuche es erneut.",
          timestamp: new Date()
        }
      ]);
    } finally {
      setIsTyping(false);
    }
  };

  // Updated function to regenerate AI response
  const regenerateResponse = async (aiMessageId: string) => {
    setTypingMessageId(null);
    
    const aiMessageIndex = messages.findIndex(m => m.id === aiMessageId);
    if (aiMessageIndex === -1 || aiMessageIndex === 0) return; // Cannot regenerate if it's the first message or not found
    
    const userMessageIndex = aiMessageIndex - 1;
    if (messages[userMessageIndex].role !== 'user') return; // Should be preceded by a user message
    
    const userMessageToResend = messages[userMessageIndex];
    
    // Keep messages up to the preceding user message
    const messagesToKeep = messages.slice(0, userMessageIndex + 1);
    
    // Update UI state
      setMessages(messagesToKeep);
    
    // Delete the AI message and subsequent ones from DB
    if (currentChatId) {
      supabase
        .from('chat_messages')
        .delete()
        .eq('chat_id', currentChatId)
        .gte('created_at', messages[aiMessageIndex].timestamp.toISOString())
        .then(({ error }) => {
          if (error) {
            console.error('Error deleting messages for regeneration:', error);
          } else {
            console.log('Messages deleted for regeneration from DB');
          }
        });
    }
    
    // Resend the user message that led to this AI response
    await handleSendMessage(userMessageToResend.content);
  };
  
  // Add another function to retry failed database operations with logging
  const retryOperation = async (operation: () => Promise<any>, maxRetries = 3, delay = 500) => {
    let lastError;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
    } catch (err) {
        lastError = err;
        console.error(`Operation failed (attempt ${attempt}/${maxRetries}):`, err);
        
        if (attempt < maxRetries) {
          console.log(`Retrying in ${delay}ms...`);
          await new Promise(resolve => setTimeout(resolve, delay));
          delay *= 2; // Exponential backoff
        }
      }
    }
    throw lastError;
  };
  
  // Simplified deleteChat function that works with the consolidated database structure
  const deleteChat = async (chatId: string) => {
    try {
      // Close any open menus
      setChatMenuOpen(null)
      
      console.log('Starting delete process for chat:', chatId)
      
      // With the ON DELETE CASCADE constraint, we only need to delete the chat
      // All associated messages will be automatically deleted
      const { error } = await supabase
        .from('chats')
        .delete()
        .eq('id', chatId)
        .eq('user_id', user.id)

      if (error) {
        console.error('Error deleting chat:', error)
        return
      }

      console.log('Chat and all associated messages deleted successfully')
      
      // Remove from state
      setChatSessions(prevSessions => prevSessions.filter(chat => chat.id !== chatId))
      
      // If the deleted chat was the current one, load another chat
      if (currentChatId === chatId) {
        // Get a fresh list of remaining chats after removing the deleted one
        const remainingChats = [...chatSessions].filter(chat => chat.id !== chatId);
        
        if (remainingChats.length > 0) {
          const nextChatId = remainingChats[0].id;
          console.log('Switching to next chat:', nextChatId);
          setCurrentChatId(nextChatId);
    } else {
          console.log('No chats remaining, clearing state');
          setCurrentChatId(null);
          setMessages([]);
        }
      }
      
      // Reload chats from database to ensure we have fresh data
      await loadChatSessions(user.id, rawWorkspaceId || null);
      
      console.log('Chat successfully deleted:', chatId);
    } catch (err) {
      console.error('Error in deleteChat:', err)
    }
  }
  
  // Add function to open rename modal
  const openRenameModal = (chat: ChatSession) => {
    setChatToRename(chat)
    setNewChatName(chat.name)
    setRenameModalOpen(true)
    setChatMenuOpen(null)
  }
  
  // Start inline edit for a chat
  const startInlineEdit = (chat: ChatSession, e: React.MouseEvent) => {
    e.stopPropagation() // Verhindere Bubble-Up zum Button
    setEditingChatId(chat.id)
    setNewChatName(chat.name)
    setChatMenuOpen(null)
  }
  
  // Handle focus loss on inline edit
  const handleInlineEditBlur = async () => {
    if (editingChatId && newChatName.trim()) {
      // Finde den Chat
      const chatToUpdate = chatSessions.find(chat => chat.id === editingChatId)
      if (chatToUpdate) {
        try {
          // Update in DB
          const { error } = await supabase
            .from('chats')
            .update({ name: newChatName })
            .eq('id', editingChatId)
            .eq('user_id', user.id)
          
          if (error) {
            console.error('Error renaming chat:', error)
          } else {
            // Update local state
            setChatSessions(prevSessions => 
              prevSessions.map(chat => 
                chat.id === editingChatId 
                  ? { ...chat, name: newChatName } 
                  : chat
              )
            )
          }
        } catch (err) {
          console.error('Error in inline chat rename:', err)
        }
      }
    }
    // Reset edit state
    setEditingChatId(null)
    setNewChatName('')
  }
  
  // Submit inline edit with enter key
  const handleInlineEditKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === 'Enter') {
      e.preventDefault()
      handleInlineEditBlur()
    } else if (e.key === 'Escape') {
      e.preventDefault()
      setEditingChatId(null)
      setNewChatName('')
    }
  }
  
  // Simplified function to handle chat renaming
  const handleRenameChat = async () => {
    if (!chatToRename || !newChatName.trim()) return

    try {
      const { error } = await supabase
        .from('chats')
        .update({ name: newChatName })
        .eq('id', chatToRename.id)
        .eq('user_id', user.id)
      
      if (error) {
        console.error('Error renaming chat:', error)
        return
      }
      
      console.log('Chat renamed successfully')
      
      // Update in state
      setChatSessions(prevSessions => 
        prevSessions.map(chat => 
          chat.id === chatToRename.id 
            ? { ...chat, name: newChatName } 
            : chat
        )
      )
      
      // Close modal
      setRenameModalOpen(false)
      setChatToRename(null)
      setNewChatName('')
      
      // Reload chats to ensure state is in sync
      await loadChatSessions(user.id, rawWorkspaceId || null)
    } catch (err) {
      console.error('Error in handleRenameChat:', err)
    }
  }
  
  const deleteProject = async (projectId: string) => {
    try {
      setError(null);
      setProjectMenuOpen(null);

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;

      // --- BERECHTIGUNGSPR√úFUNG ---
      // Diese Pr√ºfung schl√§gt aktuell fehl (PGRST116) und muss behoben werden!
      const { data: memberData, error: memberError } = await supabase
        .from('workspace_members')
        .select('role')
        .eq('workspace_id', workspaceContext)
        .eq('user_id', user.id)
        .single(); // <- Findet 0 Zeilen!

      if (memberError) {
        console.error("Fehler beim Pr√ºfen der Berechtigung:", memberError);
        // Zeige den Fehler an, aber kehre *noch nicht* zur√ºck,
        // damit der Rest der Funktion f√ºr den Fall ausgef√ºhrt wird, dass die Pr√ºfung *korrekt* w√§re.
        // In der finalen Version sollte hier ein `return` stehen.
        setError(`Berechtigungsfehler: ${memberError.message}`);
        return; // <-- Wichtig: Reaktiviert!
      } else if (!memberData || !['admin', 'owner'].includes(memberData.role)) {
        setError("Nur Workspace-Administratoren oder Eigent√ºmer k√∂nnen Projekte l√∂schen.");
        return; // Hier ist der Return OK.
      }
      // --- ENDE BERECHTIGUNGSPR√úFUNG ---


      if (!confirm(`Projekt "${projects.find(p => p.id === projectId)?.name}" wirklich l√∂schen?`)) {
        return;
      }

      // L√∂sche das Projekt
      const { error: deleteError } = await supabase
        .from('projects')
        .delete()
        .eq('id', projectId);

      if (deleteError) {
        console.error('Error deleting project:', deleteError);
        setError(`Fehler beim L√∂schen des Projekts: ${deleteError.message}`);
        return; // Beende bei L√∂schfehler
      }

      console.log("‚úÖ Projekt erfolgreich gel√∂scht. Lade Daten neu...");

      // --- DATEN NEU LADEN statt lokalen State zu patchen ---
      setLoading(true); // Ladeindikator anzeigen
      try {
        // Lade Projekte und Chats neu
        if (user) {
          await loadProjects(user.id, workspaceContext);
          await loadChatSessions(user.id, workspaceContext);
        }

        // Setze abh√§ngige Zust√§nde zur√ºck
        if (selectedProject?.id === projectId) {
          setSelectedProject(null);
        }
        // Finde Chats, die zu diesem Projekt geh√∂ren (basierend auf dem *alten* State vor dem Reload)
        const chatsInProjectToDelete = chatSessions.filter(chat => chat.project_id === projectId);
        if (editingChatId && chatsInProjectToDelete.some(chat => chat.id === editingChatId)) {
          setEditingChatId(null);
          setNewChatName('');
        }
        // expandedProjects muss nicht manuell bereinigt werden, da es von 'projects' abh√§ngt

      } catch (reloadError) {
        console.error("Fehler beim Neuladen der Daten nach Projektl√∂schung:", reloadError);
        setError("Projekt gel√∂scht, aber Fehler beim Aktualisieren der Ansicht.");
      } finally {
        setLoading(false);
      }

    } catch (err) {
      // Dieser Catch ist jetzt haupts√§chlich f√ºr unerwartete Fehler
      console.error('Unexpected error in deleteProject:', err);
      setError("Ein unerwarteter Fehler ist aufgetreten.");
    }
  };
  
  const updateProject = async () => {
    if (!projectToRename || !newProjectName.trim()) return;
    
    try {
      setLoading(true);
      
      const { data, error } = await supabase
        .from('projects')
        .update({
          name: newProjectName,
          description: newProjectDescription,
          updated_at: new Date().toISOString()
        })
        .eq('id', projectToRename.id)
        .select();

      if (error) throw error;

      // Aktualisiere Projektliste
      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
      await loadProjects(user.id, workspaceContext);
      
      // Wenn das bearbeitete Projekt ausgew√§hlt war, aktualisiere die Auswahl
      if (selectedProject?.id === projectToRename.id && data?.[0]) {
        setSelectedProject(data[0]);
      }
      
      // Modal schlie√üen
      setShowProjectModal(false);
      setProjectToRename(null);
      setNewProjectName('');
      setNewProjectDescription('');
      
    } catch (err) {
      console.error('Error updating project:', err);
    } finally {
      setLoading(false);
    }
  };
  
  // Chat einem Projekt zuweisen
  const assignChatToProject = async (chatId: string, projectId: string | null) => {
    try {
      console.log(`Zuweisen von Chat ${chatId} zu Projekt ${projectId || 'none'}`);
      
      // Update in der Datenbank
      const { error } = await supabase
        .from('chats')
        .update({ 
          project_id: projectId,
          // Auch last_message_timestamp aktualisieren, damit die Sortierung korrekt bleibt
          last_message_timestamp: new Date().toISOString()
        })
        .eq('id', chatId);

      if (error) throw error;

      // Update im lokalen State
      setChatSessions(prev => 
        prev.map(chat => 
          chat.id === chatId 
            ? { ...chat, project_id: projectId } 
            : chat
        )
      );

      // Lade Chats neu, um sicherzustellen, dass die UI korrekt aktualisiert wird
      if (user) {
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        // Verz√∂gerung einbauen, damit die Datenbank Zeit hat, die √Ñnderung zu verarbeiten
        setTimeout(async () => {
          await loadChatSessions(user.id, workspaceContext);
        }, 300);
      }

      console.log(`Chat ${chatId} wurde ${projectId ? `Projekt ${projectId}` : 'keinem Projekt'} zugewiesen`);
    } catch (err) {
      console.error('Fehler beim Zuweisen des Chats:', err);
      setError('Fehler beim Zuweisen des Chats zu einem Projekt');
    }
  };
  
  // Erg√§nze die Message-Komponente
  const Message = ({ message, isTyping }: { message: Message, isTyping?: boolean }) => {
    const isUser = message.role === 'user'
    const messageRef = useRef<HTMLDivElement>(null);
    
    // Add effect to ensure message is visible
    useEffect(() => {
      // Only scroll into view for the most recent message
      if (messageRef.current && !isTyping) {
        messageRef.current.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }
    }, [message.id, isTyping]);
    
    if (message.role === 'system') {
      return null // System-Nachrichten nicht anzeigen
    }
    
    return (
      <div 
        ref={messageRef}
        className={`mx-auto max-w-3xl px-4 py-3 ${isUser ? 'text-right' : 'text-left'}`}
        data-message-id={message.id}
      >
        <div 
          className={`inline-block ${isUser ? 'user-message' : 'assistant-message'}`}
        >
          {message.isTypewriting && message.role === 'assistant' ? (
            <TypewriterEffect 
              content={message.content} 
              onComplete={() => handleTypewriterComplete(message.id)} 
            />
          ) : (
            <div className={`prose prose-sm ${isUser ? 'text-black' : 'text-white'} text-left`}>
              <ReactMarkdown 
                remarkPlugins={[remarkGfm]}
                components={{
                  // Custom component for code blocks to add header and copy button
                  code: ({ node, inline, className, children, ...props }: CodeProps) => {
                    const match = /language-(\w+)/.exec(className || '');
                    const language = match ? match[1] : 'code';
                    const codeContent = String(children).replace(/\n$/, ''); // Extract code content

                    if (inline) {
                      // Handle inline code
                      return <code className={`rounded bg-[#333] px-1 py-0.5 text-sm ${className}`} {...props}>{children}</code>;
                    }
                    
                    // Handle block code
                    return (
                      <div className="relative my-2 rounded bg-[#282c34] text-white">
                        <div className="flex items-center justify-between bg-[#3c4043] px-4 py-1 text-xs text-gray-400">
                          <span>{language}</span>
                          <button
                            onClick={() => navigator.clipboard.writeText(codeContent)}
                            className="ml-2 text-gray-400 hover:text-white"
                          >
                            Kopieren
                          </button>
                        </div>
                        <pre className="overflow-x-auto p-4">
                          <code className={`language-${language}`}>{children}</code>
                        </pre>
                      </div>
                    );
                  }
                }}
              >
                {message.content}
              </ReactMarkdown>
            </div>
          )}
        </div>
      </div>
    )
  }
  
  // Add this new useEffect to listen for changes to personalWorkspaceId
  useEffect(() => {
    // When personalWorkspaceId is set, immediately load chats
    const loadInitialChats = async () => {
      // Nur laden, wenn wir noch keine Chats haben oder keinen aktuellen Chat
      // Dies verhindert, dass der Ladevorgang bestehende Daten √ºberschreibt
      if (user && personalWorkspaceId && (chatSessions.length === 0 || !currentChatId)) {
        console.log("Personal workspace ID changed, no chats yet, loading for:", personalWorkspaceId);
        
        try {
          // Use the direct query approach to ensure we get the latest data
          let query = supabase
            .from('chats')
            .select('id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id')
            .eq('workspace_id', personalWorkspaceId)
            .order('last_message_timestamp', { ascending: false });
          
          const { data, error } = await query;
          
          if (error) {
            console.error('Error loading initial chats:', error);
            return;
          }
          
          if (data && data.length > 0) {
            console.log("Found existing chats:", data.length);
            const formattedSessions = data.map((chat: any) => ({
              id: chat.id || '', 
              name: chat.name || 'Unnamed Chat',
              created_at: chat.created_at || new Date().toISOString(),
              project_id: chat.project_id,
              user_id: chat.user_id,
              last_message_timestamp: chat.last_message_timestamp,
              ...(chat.description && { description: chat.description })
            }));
            
            setChatSessions(formattedSessions);
            
            // Set current chat if not already set
            if (!currentChatId) {
              console.log("Setting current chat to:", data[0].id);
              setCurrentChatId(data[0].id);
              await loadChat(data[0].id);
            }
          } else {
            console.log("No chats found for personal workspace, will create one on first message");
          }
        } catch (err) {
          console.error("Error in loadInitialChats:", err);
        }
      } else if (personalWorkspaceId) {
        console.log("Personal workspace ID changed, but chats already loaded, skipping reload");
      }
    };
    
    loadInitialChats();
  }, [personalWorkspaceId, user, supabase, currentChatId, chatSessions.length]);
  
  // Funktion zum Generieren und Setzen des Chat-Titels via AI
  const generateAndSetChatTitle = async (chatId: string, firstUserMessage: string) => {
    console.log(`‚ú® Generating title for chat ${chatId} based on: "${firstUserMessage}"`);
    try {
      // NEUE DIREKTE IMPLEMENTATION:
      // Statt sendMessageToAPI zu nutzen, machen wir den API Call direkt hier
      // um Fehler durch komplexe State-Handling-Logic in sendMessageToAPI zu vermeiden
      
      const prompt = `Analysiere die folgende Benutzernachricht und generiere einen kurzen, pr√§gnanten Titel (maximal 4 W√∂rter) f√ºr diesen Chat. Gib NUR den Titel zur√ºck, ohne Anf√ºhrungszeichen oder zus√§tzliche Erkl√§rungen:\n\nNachricht: "${firstUserMessage}"\n\nTitel:`;
      
      // Direkte Anfrage an unsere API-Route
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: [{ role: 'user', content: prompt }],
          model: 'Fast' // Schnelles Modell verwenden
        }),
      });
      
      if (!response.ok) {
        throw new Error(`API request failed: ${response.status}`);
      }
      
      const data = await response.json();
      let generatedTitle = data?.content?.trim() || null;
      
      console.log(`üëã API response for title generation:`, data);

      if (generatedTitle) {
        console.log(`‚ú® AI generated title: "${generatedTitle}"`);
        
        // Entferne m√∂gliche Anf√ºhrungszeichen am Anfang/Ende
        generatedTitle = generatedTitle.replace(/^"|"$/g, '');
        
        // Kurzen Fallback, falls Titel leer wird
        if (!generatedTitle.trim()) { 
             generatedTitle = generateChatName(firstUserMessage); // Fallback zur alten Methode
             console.log(`‚ú® AI title was empty, using fallback: "${generatedTitle}"`);
        } 

        // Update Datenbank
        const { error: updateError } = await supabase
          .from('chats')
          .update({ name: generatedTitle })
          .eq('id', chatId);

        if (updateError) {
          console.error('‚ùå Error updating chat name in DB:', updateError);
        } else {
          console.log(`‚úÖ Chat ${chatId} name updated in DB to: "${generatedTitle}"`);
          // Update UI State
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: generatedTitle } : chat
            )
          );
        }
      } else {
         console.warn("‚ö†Ô∏è AI did not return a valid title.");
         // Optional: Fallback zur alten Methode, wenn AI versagt
         const fallbackTitle = generateChatName(firstUserMessage);
         const { error: updateError } = await supabase
          .from('chats')
          .update({ name: fallbackTitle })
          .eq('id', chatId);
          if (!updateError) {
              setChatSessions(prevSessions =>
                prevSessions.map(chat =>
                  chat.id === chatId ? { ...chat, name: fallbackTitle } : chat
                )
             );
          }
      }
    } catch (error) {
      console.error('‚ùå Error generating or setting chat title:', error);
      // Hier nicht abbrechen, Chat funktioniert trotzdem weiter
      
      // Fallback zur einfachen Methode bei Fehlern
      try {
        const fallbackTitle = generateChatName(firstUserMessage);
        console.log(`‚ö†Ô∏è Using fallback title due to error: "${fallbackTitle}"`);
        
        const { error: updateError } = await supabase
          .from('chats')
          .update({ name: fallbackTitle })
          .eq('id', chatId);
          
        if (!updateError) {
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: fallbackTitle } : chat
            )
          );
        }
      } catch (fbError) {
        console.error('‚ùå Even fallback title setting failed:', fbError);
      }
    }
  };
  
  // F√ºge Event-Listener f√ºr Klicks au√üerhalb der Edit-Box hinzu
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (editBoxRef.current && !editBoxRef.current.contains(event.target as Node) && editingMessageId) {
        cancelEditMessage();
      }
    };
    
    document.addEventListener('mousedown', handleClickOutside);
    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [editingMessageId]);

  // Handle Joyride callback
  const handleJoyrideCallback = (data: CallBackProps) => {
    const { action, index, status, type } = data;

    if (type === 'step:before' && index === 2) {
      // Show fake messages for message actions
      setShowFakeMessagesForTour(true);
      // Instead of continuing with the tour, show our custom dialog
      setShowMessageActionsDialog(true);
      // Pause the tour
      setRunTour(false);
    } else if (type === 'step:after' && index === 2) {
      // Clear fake messages after the step
      setShowFakeMessagesForTour(false);
    }

    if (action === 'reset' || status === STATUS.FINISHED) {
      setRunTour(false);
      setShowFakeMessagesForTour(false);
      setShowMessageActionsDialog(false);
    }
    
    if (type === 'step:after') {
      setStepIndex(index + 1);
    }
  };

  // Function to start the tour at a specific step
  const startTourAt = (index: number) => {
    setStepIndex(index);
    // Use timeout to ensure UI elements are rendered, especially if sidebar visibility changes
    setTimeout(() => {
        setRunTour(true);
    }, 100); // Small delay might be needed
  };
  
  // Function to handle "Deep Research" button click
  const handleDeepResearch = async () => {
    if (!inputValue.trim()) return; // Do nothing if input is empty
    
    // Use the enhanced handleSendMessage with web search enabled
    await handleSendMessage(inputValue.trim(), true);
  };
  
  // Handle PDF export with message selection
  const handleExportPdf = (selection: 'all' | 'last5' | 'last10' | number[]) => {
    try {
      const chatName = chatSessions.find(chat => chat.id === currentChatId)?.name || "Chat";
      downloadChatAsPdf(messages, chatName, selection);
    } catch (error) {
      console.error('Error exporting chat:', error);
      // You could add an error state and show a notification here
    }
  };

  // Handle chat summary generation
  const handleGenerateSummary = async () => {
    if (messages.length < 2) {
      // F√ºge eine Nachricht hinzu, wenn nicht genug Nachrichten vorhanden sind
      const errorMessage: Message = {
        id: uuidv4(),
        role: 'assistant',
        content: 'Es gibt nicht gen√ºgend Nachrichten f√ºr eine Zusammenfassung.',
        timestamp: new Date()
      };
      setMessages(prevMessages => [...prevMessages, errorMessage]);
      return;
    }

    // Zeige einen Ladeindikator im Chat
    const loadingMessage: Message = {
      id: uuidv4(),
      role: 'assistant',
      content: 'Erstelle eine Zusammenfassung des bisherigen Chats...',
      timestamp: new Date(),
      isTypewriting: true
    };
    
    const loadingMessageId = loadingMessage.id;
    setMessages(prevMessages => [...prevMessages, loadingMessage]);
    setIsTyping(true);

    try {
      // Generiere die Zusammenfassung
      const summary = await generateChatSummary(messages);
      
      // Ersetze die Lade-Nachricht mit der tats√§chlichen Zusammenfassung
      setMessages(prevMessages => 
        prevMessages.map(msg => 
          msg.id === loadingMessageId 
            ? { ...msg, content: summary, isTypewriting: false } 
            : msg
        )
      );
      
      // Speichere die Nachricht in der Datenbank, wenn ein Chat aktiv ist
      if (currentChatId) {
        console.log('üí¨ Saving summary message for chat:', currentChatId);
        
        try {
          const { error: messageError } = await supabase
            .from("chat_messages")
            .insert({
              chat_id: currentChatId,
              role: 'assistant',
              content: summary,
              user_id: user?.id, // Make sure user_id is included in database insert
              created_at: new Date().toISOString()
            });

          if (messageError) {
            console.error('‚ùå Error saving summary message:', messageError);
          } else {
            console.log('‚úÖ Summary message saved');
            // REMOVE: Reloading chat list is likely causing the issue
            // if (user) {
            //   await loadChatSessions(user.id, rawWorkspaceId || null);
            // }
          }
        } catch (dbError) {
          console.error('Database error saving summary:', dbError);
        }
      }
    } catch (error) {
      console.error('Error generating summary:', error);
      
      // Ersetze die Lade-Nachricht mit einer Fehlermeldung
      setMessages(prevMessages => 
        prevMessages.map(msg => 
          msg.id === loadingMessageId 
            ? { 
                ...msg, 
                content: 'Bei der Erstellung der Zusammenfassung ist ein Fehler aufgetreten. Bitte versuche es sp√§ter erneut.', 
                isTypewriting: false 
              } 
            : msg
        )
      );
    } finally {
      setIsTyping(false);
    }
  };
  
  const chatSessionsWithProjectInfo = chatSessions.map(chat => {
    const assignedProject = projects.find(project => 
      chat.project_id === project.id
    );
    return {
      ...chat,
      assignedProjectName: assignedProject?.name || null
    };
  });
  
  // Nicht zugewiesene Chats filtern
  const unassignedChats = useMemo(() => {
    console.log("Recalculating unassigned chats from", chatSessions.length, "available chats");
    return chatSessions.filter(chat => chat.project_id === null);
  }, [chatSessions]);
  
  // Chats nach Projekten gruppieren
  const chatsByProject = useMemo(() => {
    console.log("Recalculating chats by project from", chatSessions.length, "available chats");
    // Kopiere die Projekte und f√ºge die zugeh√∂rigen Chats hinzu
    return projects.map(project => { // Use 'projects' from state
      const projectChats = chatSessions.filter(chat => chat.project_id === project.id); // Use 'chatSessions' from state
      console.log(`Project ${project.name} has ${projectChats.length} chats`);
      return {
        ...project,
        chats: projectChats
      };
    });
  }, [projects, chatSessions]); // Add 'projects' and 'chatSessions' to dependency array

  // Toggle Funktion f√ºr das Aufklappen der Projekte
  const toggleProjectExpansion = (projectId: string) => {
    console.log("Toggling project expansion for", projectId);
    setExpandedProjects(prev => ({
      ...prev,
      [projectId]: !prev[projectId]
    }));

    // Wenn ein Projekt ausgew√§hlt wird, setzen wir es auch als aktives Projekt
    setSelectedProject(projects.find(p => p.id === projectId) || null);
  };
  
  // Hinzuf√ºgen einer Funktion, um anzuzeigen, ob ein Chat geladen ist
  const isActiveChat = (chatId: string): boolean => {
    return currentChatId === chatId;
  };

  // Verbesserte Funktion zum Laden eines Chats
  const handleSelectChat = async (chatId: string) => {
    console.log(`Selecting chat: ${chatId}`);
    
    // Pr√ºfe, ob es ein g√ºltiger Chat ist
    const selectedChat = chatSessions.find(chat => chat.id === chatId);
    if (!selectedChat) {
      console.error(`Chat ${chatId} nicht in aktuellen Chat-Sessions gefunden!`);
      return;
    }
    
    // Setze aktuellen Chat
    setCurrentChatId(chatId);
    
    // Lade Chat-Inhalte
    await loadChat(chatId);
    
    // Wenn der Chat zu einem Projekt geh√∂rt, stelle sicher, dass das Projekt aufgeklappt ist
    if (selectedChat.project_id) {
      console.log(`Chat geh√∂rt zu Projekt ${selectedChat.project_id}, klappe auf`);
      setExpandedProjects(prev => ({
        ...prev,
        [selectedChat.project_id!]: true
      }));
    }
  };
  
  if (error) {
    return (
      <div className="flex h-screen items-center justify-center bg-[var(--bg-primary)]">
        <div className="max-w-md rounded-lg border border-[var(--border-light)] bg-[var(--bg-tertiary)] p-6 text-center">
          <h2 className="mb-4 text-xl font-medium text-[var(--text-primary)]">Fehler</h2>
          <p className="mb-4 text-[var(--text-secondary)]">{error}</p>
          <Link 
            href="/login"
            className="inline-flex rounded-md bg-[var(--accent-primary)] px-4 py-2 text-sm font-medium text-white hover:bg-[var(--accent-primary-hover)]"
          >
            Zum Login
          </Link>
        </div>
      </div>
    );
  }
  
  // Funktion, um einen neuen Chat zu beginnen (ohne ihn sofort zu erstellen)
  const startNewChat = () => {
    setCurrentChatId(null);
    setMessages([]);
    setInputValue('');
    setSelectedTask(null); // Auch Task zur√ºcksetzen
    // Optional: URL cleanen, falls eine Chat-ID drin ist
    const currentPath = window.location.pathname; // z.B. /chat
    const workspaceQuery = rawWorkspaceId ? `?workspace=${rawWorkspaceId}` : '';
    router.push(`${currentPath}${workspaceQuery}`, undefined);

    // Fokus auf Inputfeld
    inputRef.current?.focus();
  };
  
  // Add message search functionality
  const handleMessageSearch = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!messageSearchQuery.trim()) return;
    
    try {
      setIsSearching(true);
      
      // Search in message content - fixed table name from messages to chat_messages
      const { data: messagesData, error: messagesError } = await supabase
        .from("chat_messages")
        .select("id, content, chat_id, created_at, chats(name)")
        .ilike("content", `%${messageSearchQuery}%`)
        .order("created_at", { ascending: false })
        .limit(20);
      
      if (messagesError) {
        console.error("Fehler bei der Suche in Nachrichten:", messagesError);
      }
      
      // Combine client-side chat results with server-side message results
      const messageResults = messagesData || [];
      
      // Format message results
      const formattedResults = messageResults.map(result => ({
        id: `message-${result.id}`,
        content: result.content,
        chat_id: result.chat_id,
        created_at: result.created_at,
        chats: result.chats,
        type: 'message'
      }));
      
      // Add any existing client-side filtered chat results
      const existingChatResults = messageSearchResults
        .filter(result => result.id?.startsWith('local-'))
        .map(result => ({...result, type: 'chat'}));
      
      // Combine both types of results
      setMessageSearchResults([...formattedResults, ...existingChatResults]);
      console.log("Search results:", [...formattedResults, ...existingChatResults].length);
    } catch (err) {
      console.error("Fehler bei der Suche:", err);
    } finally {
      setIsSearching(false);
    }
  };
  
  // Update handleSearchInputChange to trigger search automatically after 3+ characters
  const handleSearchInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const query = e.target.value;
    setMessageSearchQuery(query);
    
    // Client-side filtering of visible chats list when typing
    if (query.trim() === '') {
      setMessageSearchResults([]);
    } else {
      // Filter chat sessions that match the query and convert to search result format
      const filteredChats = chatSessions
        .filter(chat => 
          chat.name.toLowerCase().includes(query.toLowerCase())
        )
        .map(chat => ({
          id: `local-${chat.id}`,
          content: "Chat gefunden",
          chat_id: chat.id,
          created_at: chat.created_at,
          chats: { name: chat.name },
          type: 'chat'
        }));
      
      setMessageSearchResults(filteredChats);
      
      // If query is 3+ characters, automatically trigger the full search
      if (query.trim().length >= 3) {
        // Create a debounced search function to avoid too many API calls
        clearTimeout(searchDebounceTimeout.current);
        searchDebounceTimeout.current = setTimeout(async () => {
          try {
            setIsSearching(true);
            
            // Search in message content - fixed table name from messages to chat_messages
            const { data: messagesData, error: messagesError } = await supabase
              .from("chat_messages")
              .select("id, content, chat_id, created_at, chats(name)")
              .ilike("content", `%${query}%`)
              .order("created_at", { ascending: false })
              .limit(20);
            
            if (messagesError) {
              console.error("Fehler bei der Suche in Nachrichten:", messagesError);
            }
            
            // Combine client-side chat results with server-side message results
            const messageResults = messagesData || [];
            
            // Format message results
            const formattedResults = messageResults.map(result => ({
              id: `message-${result.id}`,
              content: result.content,
              chat_id: result.chat_id,
              created_at: result.created_at,
              chats: result.chats,
              type: 'message'
            }));
            
            // Combine both types of results
            setMessageSearchResults([...formattedResults, ...filteredChats]);
          } catch (err) {
            console.error("Fehler bei der Suche:", err);
          } finally {
            setIsSearching(false);
          }
        }, 300); // 300ms debounce
      }
    }
  };
  
  const toggleMessageSearch = () => {
    setSearchOpen(!searchOpen);
    if (!searchOpen) {
      setMessageSearchQuery("");
      setMessageSearchResults([]);
    }
  };
  
  const handleImprovePrompt = async () => {
    if (!newTaskSystemPrompt.trim()) return
    
    try {
      setIsImprovingPrompt(true)
      
      // Make API call to your reasoning model to improve the prompt
      const response = await fetch('/api/improve-prompt', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          prompt: newTaskSystemPrompt,
          userId: user.id
        }),
      })
      
      if (!response.ok) {
        const errorData = await response.json().catch(() => null);
        const errorMessage = errorData?.error || 'Fehler beim Verbessern des Prompts';
        console.error('API Error:', errorData);
        throw new Error(errorMessage);
      }
      
      const data = await response.json()
      setNewTaskSystemPrompt(data.improvedPrompt)
      
      // Show success message -- Removed alert
      // alert(`Prompt erfolgreich verbessert! (Verwendet: ${data.modelUsed || 'GPT-Modell'})`);
      
    } catch (error: any) {
      console.error('Error improving prompt:', error)
      alert(`Fehler beim Verbessern des Prompts: ${error.message || 'Unbekannter Fehler'}`);
    } finally {
      setIsImprovingPrompt(false)
    }
  }
  
  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])
  
  // Realtime subscription f√ºr Chat-Nachrichten
  useEffect(() => {
    if (!currentChatId || !supabase) return;
    
    console.log('Setting up realtime subscription for chat messages:', currentChatId);
    
    // Konfiguriere den Realtime-Channel f√ºr chat_messages
    const messagesChannel = supabase
      .channel(`chat_messages_${currentChatId}`)
      .on(
        'postgres_changes',
        {
          event: '*', // INSERT, UPDATE, DELETE
          schema: 'public',
          table: 'chat_messages',
          filter: `chat_id=eq.${currentChatId}`
        },
        (payload) => {
          console.log('Realtime message update received:', payload);
          
          // Nur bei fremden Nachrichten (nicht vom aktuellen Client gesendet) aktualisieren
          // Die Pr√ºfung erfolgt anhand eines Vergleichs mit den aktuellen Nachrichten
          if (payload.eventType === 'INSERT') {
            const newMsg = payload.new;
            setMessages((prevMessages) => {
              // Pr√ºfe, ob die Nachricht bereits existiert
              const exists = prevMessages.some(msg => 
                msg.content === newMsg.content && 
                msg.role === newMsg.role &&
                new Date(msg.timestamp).getTime() > Date.now() - 5000 // Nur in den letzten 5 Sekunden
              );
              
              if (!exists) {
                // Neue Nachricht hinzuf√ºgen
                return [...prevMessages, {
                  id: newMsg.id || uuidv4(),
                  role: newMsg.role as 'user' | 'assistant' | 'system',
                  content: newMsg.content,
                  timestamp: new Date(newMsg.created_at)
                }];
              }
              return prevMessages;
            });
          }
        }
      )
      .subscribe();
    
    // Cleanup beim Unmount oder wenn sich currentChatId √§ndert
    return () => {
      console.log('Cleaning up realtime subscription');
      supabase.removeChannel(messagesChannel);
    };
  }, [currentChatId, supabase]);
  
  // Realtime subscription f√ºr √Ñnderungen an Chats (insbesondere Projekt-Zuordnungen)
  useEffect(() => {
    if (!user || !supabase) return;
    
    console.log('Setting up realtime subscription for chats table');
    
    // Konfiguriere den Realtime-Channel f√ºr die chats Tabelle
    const chatsChannel = supabase
      .channel(`chats_updates`)
      .on(
        'postgres_changes',
        {
          event: 'UPDATE', // Nur Updates √ºberwachen
          schema: 'public',
          table: 'chats'
        },
        (payload) => {
          console.log('Realtime chat update received:', payload);
          
          // Aktualisiere den lokalen State, wenn sich ein Chat √§ndert
          if (payload.eventType === 'UPDATE') {
            const updatedChat = payload.new;
            
            // Aktualisiere den chatSessions-State
            setChatSessions(prevSessions => 
              prevSessions.map(chat => 
                chat.id === updatedChat.id 
                  ? { 
                      ...chat, 
                      name: updatedChat.name,
                      project_id: updatedChat.project_id
                    } 
                  : chat
              )
            );
            
            // Wenn der aktuelle Chat aktualisiert wurde, aktualisiere auch currentChatId
            if (currentChatId === updatedChat.id) {
              setCurrentChatId(updatedChat.id);
            }
          }
        }
      )
      .subscribe();
    
    // Cleanup beim Unmount
    return () => {
      console.log('Cleaning up chats table subscription');
      supabase.removeChannel(chatsChannel);
    };
  }, [user, supabase]);
  
  // Hilfsfunktion, um Initialen aus User-ID oder E-Mail zu extrahieren
  const getUserInitials = (userId: string | undefined): string => {
    if (!userId) return "?";
    
    // Einfache Extraktionslogik - nimmt die ersten 2 Zeichen der userId
    // In einer realen Anwendung w√ºrde man hier den Namen des Benutzers abrufen
    return userId.substring(0, 2).toUpperCase();
  };

  // Funktion zum Erstellen und Speichern von Embeddings
  const createEmbedding = async (message: Message, chatId: string, workspaceId: string | null = null) => {
    try {
      console.log("üîÑ Erstelle Embedding f√ºr Nachricht:", message.id);
      console.log("üì® Original Nachrichteninhalt:", message.content);
      
      // Current date formatted for embedding
      const currentDate = new Date().toISOString().split('T')[0]; // Format: YYYY-MM-DD
      
      // Append date information to the content for embedding
      const contentWithDate = `[Datum: ${currentDate}]\n${message.content}`;
      console.log("üìÖ Nachrichteninhalt mit Datum f√ºr Embedding:", contentWithDate);
      
      // OpenAI API f√ºr Embedding aufrufen
      console.log("üß† Embedding wird generiert f√ºr Inhalt mit L√§nge:", contentWithDate.length);
      const response = await fetch('/api/embeddings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          input: contentWithDate
        }),
      });

      if (!response.ok) {
        throw new Error(`Embedding API responded with ${response.status}`);
      }

      const embeddingData = await response.json();
      console.log("‚úÖ Embedding erfolgreich generiert:");
      console.log("üìä Embedding-Dimensionen:", embeddingData.embedding.length);
      console.log("üîç Embedding-Vorschau (erste 5 Werte):", embeddingData.embedding.slice(0, 5));
      console.log("üîç Embedding-Vorschau (letzte 5 Werte):", embeddingData.embedding.slice(-5));
      
      // In der Datenbank speichern
      const dbPayload = {
        message_id: message.id,
        chat_id: chatId,
        workspace_id: workspaceId,
        role: message.role,
        embedding: embeddingData.embedding,
        content_with_date: contentWithDate // Store the content with date in the new column
      };
      console.log("üíæ Speichere in DB mit Payload:", {
        message_id: dbPayload.message_id,
        chat_id: dbPayload.chat_id,
        workspace_id: dbPayload.workspace_id,
        role: dbPayload.role,
        content_with_date: contentWithDate.substring(0, 50) + "...", // Log truncated for readability
        embedding_length: embeddingData.embedding.length
      });
      
      const { data, error } = await supabase.from('message_embeddings').insert(dbPayload).select();

      if (error) {
        console.error("‚ùå Fehler beim Speichern des Embeddings:", error);
        throw error;
      }
      console.log("‚úÖ Embedding gespeichert f√ºr Nachricht:", message.id);
      if (data) {
        console.log("üìù DB-Eintrag erstellt mit ID:", data[0]?.id);
      }
    } catch (error) {
      console.error("‚ùå Fehler beim Erstellen des Embeddings:", error);
    }
  };

  // Funktion zum Finden √§hnlicher Nachrichten f√ºr einen *Benutzer*
  const findSimilarMessages = async (query: string, userId: string) => {
    // Stelle sicher, dass eine userId vorhanden ist
    if (!userId) {
      console.error("‚ùå User ID fehlt f√ºr die Suche nach √§hnlichen Nachrichten.");
      return [];
    }
  
    try {
      console.log(`üîç Suche nach √§hnlichen Nachrichten f√ºr User ${userId}`);
      console.log(`üìù Suchanfrage: "${query}"`);
      
      // Embedding f√ºr die Abfrage erstellen
      console.log("üß† Generiere Embedding f√ºr Suchanfrage...");
      const response = await fetch('/api/embeddings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          input: query
        }),
      });

      if (!response.ok) {
        throw new Error(`Embedding API responded with ${response.status}`);
      }

      const embeddingData = await response.json();
      console.log("‚úÖ Embedding f√ºr Abfrage erfolgreich generiert");
      console.log("üìä Query-Embedding-Dimensionen:", embeddingData.embedding.length);
      console.log("üîç Query-Embedding-Vorschau (erste 5 Werte):", embeddingData.embedding.slice(0, 5));
      
      // √Ñhnliche Nachrichten mit *neuer* Stored Procedure finden
      console.log(`üìû Rufe search_similar_messages RPC f√ºr User ${userId} auf (Schwellwert: 0.7, Max Ergebnisse: 10)`);
      const { data, error } = await supabase.rpc('search_similar_messages', {
        query_embedding: embeddingData.embedding,
        p_user_id: userId, // √úbergabe der User ID
        similarity_threshold: 0.7, // Erh√∂ht von 0.3 auf 0.7 f√ºr pr√§zisere Ergebnisse
        max_results: 10
      });

      if (error) {
        console.error("‚ùå Fehler in search_similar_messages RPC:", error);
        throw error;
      }
      
      console.log(`üîé RPC Ergebnis: ${data?.length || 0} Nachrichten gefunden`);
      if (data && data.length > 0) {
        console.log("üìã Erste Ergebnisse (Rohdaten):", data.slice(0, 2));
      }
      
      // Filtere die Ergebnisse: Behalte Kontext-Nachrichten und ignoriere zu √§hnliche prim√§re Nachrichten
      const filteredData = data?.filter((m: any) => 
        m.is_context || // immer Kontext-Nachrichten behalten
        m.similarity < 0.99 // Nur Hauptnachrichten filtern, nicht Kontext
      ) || [];
      
      console.log(`üßπ Nach Filterung: ${filteredData.length} Nachrichten √ºbrig`);
      
      // Process messages to extract date information if present
      console.log("üîÑ Verarbeite Nachrichten, um Datumsinformationen zu extrahieren...");
      const processedData = filteredData.map((m: any) => {
        let displayContent = m.content;
        let dateInfo = null;
        
        // Extract date information if it's included in the format [Datum: YYYY-MM-DD]
        const dateMatch = m.content.match(/\[Datum: (\d{4}-\d{2}-\d{2})\]/);
        if (dateMatch) {
          dateInfo = dateMatch[1];
          // Remove the date prefix for display
          displayContent = m.content.replace(/\[Datum: \d{4}-\d{2}-\d{2}\]\n/, '');
          console.log(`üìÖ Datum gefunden in Nachricht ${m.message_id}: ${dateInfo}`);
        } else {
          console.log(`‚ö†Ô∏è Kein Datum gefunden in Nachricht ${m.message_id}`);
        }
        
        return {
          ...m,
          displayContent,
          dateInfo,
          isContext: m.is_context || false // √úbernehme das Kontext-Flag
        };
      });
      
      console.log(`‚úÖ ${processedData.length} √§hnliche Nachrichten nach Filterung gefunden`);
      
      // Gruppiere zusammengeh√∂rige Nachrichten f√ºr bessere √úbersicht in Logs
      const contextGroups = new Map();
      
      processedData.forEach((m: any, index: number) => {
        const contextKey = m.isContext ? 'context' : `main-${index}`;
        
        console.log(`üîπ ${m.isContext ? 'Kontext-Nachricht' : 'Ergebnis'} #${index+1}:`);
        console.log(`  ‚Ä¢ ID: ${m.message_id}`);
        console.log(`  ‚Ä¢ Chat: ${m.chat_id}`);
        console.log(`  ‚Ä¢ Rolle: ${m.role}`);
        console.log(`  ‚Ä¢ Datum: ${m.dateInfo || 'Keines'}`);
        console.log(`  ‚Ä¢ √Ñhnlichkeit: ${m.similarity.toFixed(4)}${m.isContext ? ' (Kontext)' : ''}`);
        console.log(`  ‚Ä¢ Inhalt: ${(m.displayContent || m.content).substring(0, 100)}${(m.displayContent || m.content).length > 100 ? '...' : ''}`);
      });
      
      // Sortiere die Ergebnisse: Prim√§re Nachricht, dann Kontext
      processedData.sort((a: any, b: any) => {
        // Behalte die bestehende Sortierung bei
        return a.isContext === b.isContext 
          ? b.similarity - a.similarity // Bei gleichem Typ: Nach √Ñhnlichkeit absteigend
          : (a.isContext ? 1 : -1); // Prim√§re Nachrichten zuerst
      });
      
      return processedData;
    } catch (error) {
      console.error("‚ùå Fehler beim Suchen √§hnlicher Nachrichten:", error);
      return [];
    }
  };

  return (
    <div className="flex h-screen overflow-hidden bg-[#1e1e1e]">
      {/* Use DynamicJoyride instead of Joyride */}
      <DynamicJoyride
        steps={tourSteps}
        run={runTour}
        stepIndex={stepIndex}
        callback={handleJoyrideCallback}
        continuous={true}
        showProgress={false}
        showSkipButton={true}
        locale={{
            back: 'Zur√ºck',
            close: 'Schlie√üen',
            last: 'Fertig',
            next: 'Weiter',
            skip: '√úberspringen',
        }}
        disableOverlayClose={true}
        styles={{
          options: {
            zIndex: 10000,
            arrowColor: '#333333',
            backgroundColor: '#1e1e1e',
            primaryColor: '#ffffff',
            textColor: '#cccccc',
          },
          tooltipContainer: {
            textAlign: "left",
          },
          buttonNext: {
              backgroundColor: '#555555',
          },
          buttonBack: {
              marginRight: 10,
          },
        }}
      />

      {/* Sidebar */}
      {showSidebar && (
        <aside id="chat-sidebar" className="flex h-screen shrink-0 flex-col rounded-r-xl border-r border-[#333333] bg-[#0d0d0d] p-0" style={{ width: "305px" }}>
          <div className="flex items-center justify-between border-b border-[#333333] p-4">
            {/* Replace H1 with Home Button */}
            <button 
              onClick={() => router.push('/dashboard')}
              className="rounded p-1.5 text-gray-400 hover:bg-[#2d2d2d] hover:text-white"
              title="Dashboard"
            >
              <Home size={18} />
            </button>
            <div className="flex items-center space-x-2">
              {/* Search and Add buttons remain here */}
              <button 
                onClick={toggleMessageSearch} // Corrected: Use toggleMessageSearch
                className="rounded p-1.5 text-gray-400 hover:bg-gray-800 hover:text-white"
                aria-label="Chats durchsuchen"
              >
                <Search size={16} />
              </button>
                <button 
                id="new-chat-button"
                onClick={startNewChat}
                className="rounded p-1.5 text-gray-400 hover:bg-gray-800 hover:text-white"
                aria-label="Neuer Chat"
              >
                <Plus size={16} />
                </button>
            </div>
          </div>

          {/* Search Panel */}
          {searchOpen && (
            <div className="border-b border-[#333333] px-3 py-2">
              <form onSubmit={handleMessageSearch} className="mb-2">
                <div className="relative">
                  <input
                    type="text"
                    value={messageSearchQuery}
                    onChange={handleSearchInputChange}
                    placeholder="Suche in Chats..."
                    className="w-full rounded-md border border-[#333333] bg-[#1a1a1a] px-3 py-1.5 text-xs text-white focus:outline-none"
                    autoFocus
                  />
            <button
                    type="submit" 
                    className="absolute right-2 top-1/2 -translate-y-1/2"
                    disabled={isSearching}
                  >
                    <Search className="size-3 text-gray-400" />
                  </button>
                </div>
              </form>
              
              {isSearching ? (
                <div className="py-2 text-center">
                  <div className="inline-block size-3 animate-spin rounded-full border-2 border-gray-400 border-t-transparent"></div>
                </div>
              ) : messageSearchResults.length > 0 ? (
                <div className="max-h-60 overflow-y-auto rounded-md border border-[#333333] bg-[#1a1a1a]">
                  {messageSearchResults.map((result) => (
                    <div
                      key={result.id}
                      onClick={() => {
                        if (result.chat_id) {
                          // Die neue Funktion verwenden, statt direkter API-Aufrufe
                          handleSelectChat(result.chat_id);
                          // Close search after selecting a result
                          setSearchOpen(false);
                        }
                      }}
                      className="block cursor-pointer border-b border-[#333333] p-2 last:border-0 hover:bg-[#272727]"
                    >
                      <div className="mb-1 flex items-center text-xs font-medium text-white">
                        {result.type === 'chat' ? (
                          <>
                            <MessageCircle className="mr-1 size-3 text-gray-300" />
                            <span>Chat: {result.chats?.name || "Chat"}</span>
                          </>
                        ) : (
                          <>
                            <FileText className="mr-1 size-3 text-gray-400" />
                            <span>Nachricht in: {result.chats?.name || "Chat"}</span>
                          </>
                        )}
          </div>
                      <p className="line-clamp-2 text-xs text-gray-400">
                        {result.type === 'chat' ? 
                          "Chat mit diesem Namen gefunden" : 
                          result.content}
                      </p>
                      <div className="mt-1 text-[10px] text-gray-500">
                        {new Date(result.created_at).toLocaleString()}
                      </div>
                    </div>
                  ))}
                </div>
              ) : messageSearchQuery && !isSearching ? (
                <div className="py-2 text-center text-xs text-gray-400">
                  Keine Ergebnisse gefunden
                </div>
              ) : null}
            </div>
          )}
          
          {/* Chat List */}
          <div className="custom-scrollbar scrollbar-hide grow overflow-y-auto p-3">
            <div className="mb-4">
              <h2 className="mb-2 text-sm font-semibold uppercase text-[#999999]">Chats</h2>
              <div className="space-y-1">
                {unassignedChats.map((chatSession) => (
                  <div 
                    key={chatSession.id} 
                    className="group flex items-center"
                    draggable="true"
                    onDragStart={(e) => {
                      e.dataTransfer.setData('chatId', chatSession.id);
                      setDraggedChatId(chatSession.id);
                    }}
                    onDragEnd={() => setDraggedChatId(null)}
                  >
                    <button
                      onClick={() => handleSelectChat(chatSession.id)}
                      className={cn(
                        "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                        isActiveChat(chatSession.id)
                          ? "bg-[#2d2d2d] text-white"
                          : "text-[#cccccc] hover:bg-[#222222]"
                      )}
                      style={{ maxWidth: "calc(100% - 40px)" }}
                    >
                      {editingChatId === chatSession.id ? (
                        <input
                          type="text"
                          value={newChatName}
                          onChange={(e) => setNewChatName(e.target.value)}
                          onBlur={handleInlineEditBlur}
                          onKeyDown={handleInlineEditKeyDown}
                          className="w-full rounded border border-[#444444] bg-[#333333] px-2 py-0.5 text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                          autoFocus
                          onClick={(e) => e.stopPropagation()}
                        />
                      ) : (
                        <div className="flex items-center">
                          <span className="block flex-1 truncate" title={chatSession.name}>{chatSession.name}</span>
                          {chatSession.user_id && chatSession.user_id !== user?.id && (
                            <span className="ml-2 flex size-5 items-center justify-center rounded-full bg-gray-700 text-xs text-gray-300" 
                                  title={`Erstellt von ${chatSession.user_id}`}>
                              {getUserInitials(chatSession.user_id)}
                            </span>
                          )}
                        </div>
                      )}
                    </button>
                    <div className="ml-1 flex min-w-[60px] opacity-0 transition-opacity group-hover:opacity-100">
                      <button
                        onClick={(e) => startInlineEdit(chatSession, e)}
                        className="p-1 text-[#cccccc] hover:text-white"
                        title="Umbenennen"
                      >
                        <Edit size={14} />
                      </button>
                      <button
                        onClick={(e) => {
                          e.stopPropagation()
                          deleteChat(chatSession.id)
                        }}
                        className="p-1 text-[#cccccc] hover:text-red-500"
                        title="L√∂schen"
                      >
                        <Trash size={14} />
                      </button>
                    </div>
                  </div>
                ))}
                
                {unassignedChats.length === 0 && (
                  <div className="px-3 py-2 text-xs italic text-[#666666]">
                    Keine freien Chats
                  </div>
                )}
              </div>
              {/* Remove redundant "Neuer Chat" button since we already have one at the top of the sidebar */}
            </div>
            
            <div className="mt-6">
              <h2 className="mb-2 text-sm font-semibold uppercase text-[#999999]">Projekte</h2>
              <div className="space-y-1">
                {chatsByProject.map((project) => (
                  <div key={project.id} className="mb-1">
                    <div 
                      className="group flex items-center"
                      onDragOver={(e) => {
                        e.preventDefault();
                        setActiveDropTarget(project.id);
                      }}
                      onDragLeave={() => setActiveDropTarget(null)}
                      onDrop={(e) => {
                        e.preventDefault();
                        const chatId = e.dataTransfer.getData('chatId');
                        if (chatId) {
                          assignChatToProject(chatId, project.id);
                        }
                        setActiveDropTarget(null);
                      }}
                    >
                      <button
                        onClick={() => toggleProjectExpansion(project.id)}
                        className={cn(
                          "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                          selectedProject?.id === project.id
                            ? "bg-[#2d2d2d] text-white"
                            : "text-[#cccccc] hover:bg-[#222222]",
                          activeDropTarget === project.id && "border border-white/40 bg-[#2d2d2d]"
                        )}
                        style={{ maxWidth: "calc(100% - 40px)" }}
                      >
                        <span className="flex items-center">
                          {expandedProjects[project.id] ? (
                            <ChevronDown size={16} className="mr-2 min-w-4" />
                          ) : (
                            <ChevronRight size={16} className="mr-2 min-w-4" />
                          )}
                          <span className="block truncate" title={project.name}>{project.name}</span>
                          {project.chats.length > 0 && (
                            <span className="ml-2 text-xs text-gray-400">
                              ({project.chats.length})
                            </span>
                          )}
                        </span>
                      </button>
                      <div className="relative ml-1">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setProjectMenuOpen(project.id === projectMenuOpen ? null : project.id);
                          }}
                          className="p-1 text-[#cccccc] opacity-0 transition-opacity hover:text-white group-hover:opacity-100"
                          data-project-menu="trigger"
                        >
                          <MoreVertical size={16} />
                        </button>
                        {projectMenuOpen === project.id && (
                          <div 
                            className="absolute right-0 top-full z-10 mt-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg"
                            data-project-menu="content"
                          >
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                // Projekt-Bearbeitung implementieren
                                setProjectToRename(project);
                                setNewProjectName(project.name);
                                setNewProjectDescription(project.description || '');
                                setShowProjectModal(true);
                              }}
                              className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                            >
                              <Edit size={16} className="mr-2" />
                              Bearbeiten
                            </button>
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                deleteProject(project.id);
                              }}
                              className="flex w-full items-center px-4 py-2 text-sm text-red-500 hover:bg-[#2d2d2d]"
                            >
                              <Trash size={16} className="mr-2" />
                              L√∂schen
                            </button>
                          </div>
                        )}
                      </div>
                    </div>
                    
                    {/* Projektzugewiesene Chats anzeigen, wenn Projekt aufgeklappt ist */}
                    {expandedProjects[project.id] && project.chats.length > 0 && (
                      <div className="mt-1 space-y-1 pl-6">
                        {project.chats.map((chatSession) => (
                          <div key={chatSession.id} className="group flex items-center">
                            <button
                              onClick={() => handleSelectChat(chatSession.id)}
                              className={cn(
                                "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                                isActiveChat(chatSession.id)
                                  ? "bg-[#2d2d2d] text-white"
                                  : "text-[#cccccc] hover:bg-[#222222]"
                              )}
                              style={{ maxWidth: "calc(100% - 70px)" }}
                            >
                              {editingChatId === chatSession.id ? (
                                <input
                                  type="text"
                                  value={newChatName}
                                  onChange={(e) => setNewChatName(e.target.value)}
                                  onBlur={handleInlineEditBlur}
                                  onKeyDown={handleInlineEditKeyDown}
                                  className="w-full rounded border border-[#444444] bg-[#333333] px-2 py-0.5 text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                                  autoFocus
                                  onClick={(e) => e.stopPropagation()}
                                />
                              ) : (
                                <div className="flex items-center">
                                  <span className="block flex-1 truncate" title={chatSession.name}>{chatSession.name}</span>
                                  {chatSession.user_id && chatSession.user_id !== user?.id && (
                                    <span className="ml-2 flex size-5 items-center justify-center rounded-full bg-gray-700 text-xs text-gray-300" 
                                          title={`Erstellt von ${chatSession.user_id}`}>
                                      {getUserInitials(chatSession.user_id)}
                                    </span>
                                  )}
                                </div>
                              )}
                            </button>
                            <div className="ml-1 flex min-w-[60px] opacity-0 transition-opacity group-hover:opacity-100">
                              <button
                                onClick={(e) => startInlineEdit(chatSession, e)}
                                className="p-1 text-[#cccccc] hover:text-white"
                                title="Umbenennen"
                              >
                                <Edit size={14} />
                              </button>
                              <button
                                onClick={(e) => {
                                  e.stopPropagation();
                                  // Von Projekt entfernen
                                  assignChatToProject(chatSession.id, null);
                                }}
                                className="p-1 text-[#cccccc] hover:text-white"
                                title="Von Projekt entfernen"
                              >
                                <FileText size={14} />
                              </button>
                              <button
                                onClick={(e) => {
                                  e.stopPropagation()
                                  deleteChat(chatSession.id)
                                }}
                                className="p-1 text-[#cccccc] hover:text-red-500"
                                title="L√∂schen"
                              >
                                <Trash size={14} />
                              </button>
                            </div>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>
                ))}
                
                {chatsByProject.length === 0 && (
                  <div className="px-3 py-2 text-xs italic text-[#666666]">
                    Keine Projekte gefunden
                  </div>
                )}
              </div>
              <button 
                onClick={() => setShowProjectModal(true)}
                className="mt-2 flex w-full items-center rounded-lg px-3 py-2 text-sm text-[#cccccc] hover:bg-[#222222]"
              >
                <Plus size={16} className="mr-2" />
                Neues Projekt
              </button>
            </div>
          </div>
          
          {/* User Section */}
          <div className="mt-auto border-t border-[#333333] p-3">
            <button 
              onClick={() => setShowSettingsModal(true)} 
              className="flex w-full items-center rounded-lg px-3 py-2 text-sm text-[#cccccc] hover:bg-[#222222]"
            >
              <User size={16} className="mr-2" />
              <span className="grow truncate text-left text-xs">{user?.email || 'Kein Benutzer'}</span>
              <Settings size={16} />
            </button>
          </div>
        </aside>
      )}

      {/* Main Content Area */}
      <main className="flex flex-1 flex-col overflow-hidden">
        {/* Header */}
        <header className="flex h-14 items-center justify-between border-b border-neutral-700 bg-neutral-900 px-4">
          <div className="flex items-center space-x-4">
            {/* Back button is removed, H1 is the first item */}
            <h1 className="text-xl font-semibold text-white">
              {selectedTask ? selectedTask.title : (chatSessions.find(chat => chat.id === currentChatId)?.name || "Neuer Chat")}
            </h1>
          </div>
          <div className="flex items-center space-x-4">
            {/* Model Selection Dropdown */}
            <div className="relative" ref={modelDropdownRef} id="model-select-button">
                    <button 
              onClick={() => !selectedTask && setShowModelDropdown(!showModelDropdown)}
              className={`flex items-center space-x-2 rounded-lg border border-[#333333] px-3 py-1.5 text-sm ${
                selectedTask 
                  ? 'cursor-not-allowed text-[#666666]' 
                  : 'cursor-pointer text-[#cccccc] transition-all hover:border-[#444444] hover:text-white'
              }`}
            >
              <span>{selectedTask ? `${getModelLabel(selectedModel)} (in Task festgelegt)` : getModelLabel(selectedModel)}</span>
              {!selectedTask && <ChevronDown size={16} />}
                  </button>

              {showModelDropdown && !selectedTask && (
                <div className="absolute right-0 top-full z-10 mt-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg">
                    {/* Button for Basic - Verwende den Label-Namen "Basic" */}
                    <button 
                      onClick={() => {
                        setSelectedModel('Basic') 
                        setShowModelDropdown(false)
                      }}
                      className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                    >
                      Basic
                    </button>
                    {/* Button for Fast - Verwende den Label-Namen "Fast" */}
                    <button
                      onClick={() => {
                        setSelectedModel('Fast') 
                        setShowModelDropdown(false)
                      }}
                      className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                    >
                      Fast
                    </button>
                    {/* Button for Reason - Verwende den Label-Namen "Reason" */}
                    <button
                      onClick={() => {
                        setSelectedModel('Reason') 
                        setShowModelDropdown(false)
                      }}
                      className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                    >
                      Reason
                    </button>
                    {/* Button for Reason+ - Verwende den Label-Namen "Reason+" */}
                    <button
                      onClick={() => {
                        setSelectedModel('Reason+') 
                        setShowModelDropdown(false)
                      }}
                      className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                    >
                      Reason+
                    </button>
                </div>
              )}
            </div>

            {/* Task Selection Dropdown */}
            <div className="relative" ref={taskDropdownRef} id="task-select-button">
              <div className="flex items-center">
                  <button 
                  onClick={() => setShowTaskDropdown(!showTaskDropdown)}
                  disabled={isTaskSwitching}
                  className="flex items-center space-x-2 rounded-lg border border-[#333333] px-3 py-1.5 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white disabled:cursor-not-allowed disabled:opacity-50"
                >
              <span>{selectedTask ? selectedTask.title : "Task ausw√§hlen"}</span>
              <ChevronDown size={16} />
                  </button>
                
                {isTaskSwitching && (
                  <div className="ml-2">
                    <div className="size-4 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                  </div>
                )}
              </div>

                {showTaskDropdown && (
              <div className="absolute right-0 top-full z-10 mt-1 w-64 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg">
                            <button
                              onClick={() => {
                      setIsTaskSwitching(true)
                          setSelectedTask(null)
                          setShowTaskDropdown(false)
                        }}
                  className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                      >
                  Kein Task
                </button>
                <div className="my-1 border-t border-[#333333]"></div>
                      {tasks.map(task => (
                <button 
                          key={task.id}
                  onClick={() => {
                        setIsTaskSwitching(true)
                            setSelectedTask(task)
                            setShowTaskDropdown(false)
                          }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                        >
                          {task.title}
                </button>
                      ))}
                <div className="my-1 border-t border-[#333333]"></div>
                    <button 
                        onClick={() => {
                          setShowTaskModal(true)
                          setShowTaskDropdown(false)
                        }}
                  className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                      >
                  <Plus size={16} className="mr-2" />
                  Neuer Task
                    </button>
                </div>
              )}
          </div>
            </div>
        </header>

        {/* Message Area */}
        <div 
          id="message-area-wrapper"
            ref={chatBodyRef}
          className="flex w-full flex-1 justify-center overflow-y-auto p-4 pb-10"
          >
          <div className="space-y-4" style={{ maxWidth: "805px", width: "100%" }}>
            {/* Start Screen with Info Buttons */}
            {messages.length === 0 && !runTour && !showFakeMessagesForTour && (
              <div className="flex h-full flex-col items-center justify-center text-center">
                <h2 className="mb-4 text-2xl font-bold text-white">
                  Entdecken Sie die Funktionen dieses Chats
                </h2>
                <div className="grid max-w-2xl grid-cols-2 gap-4">
                  <button key="tour-tasks" className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]" onClick={() => startTourAt(0)}>{infoItems[0].title}</button>
                  <button key="tour-model" className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]" onClick={() => startTourAt(1)}>{infoItems[1].title}</button>
                  <button key="tour-messages" className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]" onClick={() => startTourAt(2)}>{infoItems[2].title}</button>
                  <button key="tour-chats" className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]" onClick={() => startTourAt(3)}>{infoItems[3].title}</button>
          </div>
        </div>
      )}
            
            {/* Real Messages */}
            {!showFakeMessagesForTour && messages
              .filter(message => message.role !== 'system')
              .map((message) => (
              <div
                key={message.id}
                  className={`group mb-4 flex flex-col ${ 
                    message.role === "user" ? "items-end" : "items-start"
                }`}
              >
                  {/* Sender and timestamp */}
                <div className={`mb-1 text-xs ${message.role === "user" ? "text-right" : "text-left"} text-gray-400`}>
                  {message.role === "user" 
                    ? (message.sentfrom 
                        ? message.sentfrom // Use sentfrom if available
                        : (message.user_id === user?.id 
                            ? userFullName 
                            : (message.user_id && userNamesMap && userNamesMap[message.user_id]) 
                              ? userNamesMap[message.user_id] 
                              : (message.user_id 
                                  ? `Benutzer ${message.user_id.substring(0, 4)}` 
                                  : "Anderer Benutzer"))) 
                    : (message.sentfrom 
                        ? message.sentfrom // Use sentfrom for assistant too
                        : "KI-Assistent")} {message.timestamp.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit', second: '2-digit'})}
                </div>
                
                  {/* Message content or edit box */}
                {editingMessageId === message.id ? (
                  <div 
                    ref={editBoxRef}
                      className="flex w-full max-w-[60%] flex-col items-end"
                  >
                    <textarea
                      value={editingContent}
                      onChange={(e) => setEditingContent(e.target.value)}
                      className="mb-2 w-full resize-none rounded-lg border border-[#444] bg-[#3a3a3a] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#555]"
                      rows={3}
                      autoFocus
                    />
                    <div className="self-end">
                      <button
                        onClick={handleSaveEdit}
                        disabled={!editingContent.trim()}
                        className={`rounded-lg px-4 py-2 text-sm ${
                          !editingContent.trim() 
                            ? 'cursor-not-allowed text-[#666666]' 
                            : 'border border-[#444] bg-[#2d2d2d] text-[#cccccc] hover:border-[#555] hover:text-white'
                        }`}
                      >
                        Senden
                      </button>
                    </div>
                  </div>
                ) : (
                    <div className={`max-w-[60%] ${message.role === "user" ? "user-message" : "assistant-message"}`}>
                      {message.role === 'assistant' && message.isTypewriting ? (
                        <TypewriterEffect 
                          content={message.content} 
                          onComplete={() => handleTypewriterComplete(message.id)} 
                        />
                      ) : (
                        <div className="prose prose-invert max-w-none prose-headings:mb-2 prose-headings:mt-4 prose-headings:font-semibold prose-p:my-1">
                  <ReactMarkdown
                    remarkPlugins={[remarkGfm]}
                    components={{
                      code: ({ node, inline, className, children, ...props }: CodeProps) => {
                                const match = /language-(\w+)/.exec(className || '');
                                const language = match ? match[1] : 'code';
                                const codeContent = String(children).replace(/\n$/, ''); // Extract code content

                                if (inline) {
                                  return <code className={`rounded bg-[#333] px-1 py-0.5 text-sm ${className}`} {...props}>{children}</code>;
                                }

                                // Handle block code
                                return (
                                  <div className="relative my-2 rounded bg-[#282c34] text-white">
                                    <div className="flex items-center justify-between bg-[#3c4043] px-4 py-1 text-xs text-gray-400">
                                      <span>{language}</span>
                                      <button
                                        onClick={() => navigator.clipboard.writeText(codeContent)}
                                        className="ml-2 text-gray-400 hover:text-white"
                                      >
                                        Kopieren
                                      </button>
                                    </div>
                                    <pre className="overflow-x-auto p-4">
                                      <code className={`language-${language}`}>{children}</code>
                          </pre>
                                  </div>
                                );
                              },
                              p: ({ node, children, ...props }) => {
                                const hasPreChild = React.Children.toArray(children).some(
                                  (child) => React.isValidElement(child) && child.type === 'pre'
                                );
                                return hasPreChild ? <div {...props}>{children}</div> : <p {...props}>{children}</p>;
                      }
                    }}
                  >
                    {message.content}
                  </ReactMarkdown>
              </div>
                      )}
                  </div>
                )}
                  
                  {/* Action buttons */}
                {editingMessageId !== message.id && (
                  <div className="mt-1 flex items-center space-x-2 opacity-0 transition-opacity duration-200 group-hover:opacity-100">
                    {message.role === 'user' && (
                      <>
                        <button 
                          onClick={() => copyToClipboard(message.content)}
                          className="p-1 text-[#aaa] hover:text-white"
                          title="Nachricht kopieren"
                        >
                          <Copy size={14} />
                        </button>
                        <button 
                          onClick={() => startEditMessage(message)}
                          className="p-1 text-[#aaa] hover:text-white"
                          title="Nachricht bearbeiten"
                        >
                          <Edit size={14} />
                        </button>
                      </>
                    )}
                    {message.role === 'assistant' && (
                      <>
                        <button 
                          onClick={() => copyToClipboard(message.content)}
                          className="p-1 text-[#aaa] hover:text-white"
                          title="Antwort kopieren"
                        >
                          <Copy size={14} />
                        </button>
                        <button 
                          onClick={() => regenerateResponse(message.id)} 
                          className="p-1 text-[#aaa] hover:text-white"
                          title="Antwort neu generieren"
                        >
                          <RotateCcw size={14} />
                        </button>
                      </>
                    )}
                  </div>
                )}
              </div>
            ))}

            {/* Tour Messages */}
            {showFakeMessagesForTour && fakeTourMessages.map((message) => (
              <div
                key={message.id}
                className={`group relative mb-8 flex flex-col ${
                  message.role === "user" ? "items-end" : "items-start"
                }`}
              >
                <div className={`mb-1 text-xs ${message.role === "user" ? "text-right" : "text-left"} text-gray-400`}>
                  {message.role === "user" ? "Beispiel User" : "Beispiel KI"} {message.timestamp.toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'})}
              </div>
                <div className={`max-w-[60%] ${message.role === "user" ? "user-message" : "assistant-message"}`}>
                  <div className="prose prose-invert max-w-none prose-headings:mb-2 prose-headings:mt-4 prose-headings:font-semibold prose-p:my-1">
                    <p>{message.content}</p>
              </div>
                </div>
                
                {/* Action buttons - made more prominent for the tour */}
                <div className={`mt-2 flex animate-pulse items-center space-x-3 rounded-md border border-[#444444] bg-[#333333] px-3 py-2 shadow-lg ${
                  message.role === 'user' ? 'self-end' : 'self-start'
                }`}>
                  {message.role === 'user' && (
                    <>
                      <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                        <Copy size={14} className="mr-1.5" />
                        <span className="text-sm font-medium">Kopieren</span>
                      </div>
                      <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                        <Edit size={14} className="mr-1.5" />
                        <span className="text-sm font-medium">Bearbeiten</span>
                      </div>
                    </>
                  )}
                  {message.role === 'assistant' && (
                    <>
                      <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                        <Copy size={14} className="mr-1.5" />
                        <span className="text-sm font-medium">Kopieren</span>
              </div>
                      <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                        <RotateCcw size={14} className="mr-1.5" />
                        <span className="text-sm font-medium">Neu generieren</span>
                      </div>
                    </>
                  )}
            </div>
              
                {/* Show message actions explanation for AI message during tour */}
                {showMessageActionsDialog && message.id === 'fake-ai-message' && (
                  <div className="mt-3 max-w-[80%] self-start rounded-md border border-[#444444] bg-[#222222] p-4 shadow-lg">
                    <div className="mb-2 flex items-center justify-between">
                      <h3 className="font-medium text-white">Nachrichtenaktionen</h3>
              <button
                        onClick={() => setShowMessageActionsDialog(false)}
                        className="text-gray-400 hover:text-white"
              >
                        <X size={16} />
              </button>
                    </div>
                    <p className="mb-2 text-sm text-gray-300">Bewegen Sie den Mauszeiger √ºber die Nachrichten, um folgende Aktionen zu nutzen:</p>
                    <ul className="mb-2 ml-2 list-inside list-disc space-y-1 text-xs text-gray-300">
                      <li><strong>Kopieren:</strong> Kopiert den Inhalt der Nachricht in die Zwischenablage</li>
                      <li><strong>Bearbeiten:</strong> √Ñndert Ihre bereits gesendeten Nachrichten</li>
                      <li><strong>Neu generieren:</strong> Erstellt eine neue KI-Antwort zur letzten Benutzernachricht</li>
                    </ul>
                    <p className="mt-3 text-xs italic text-gray-400">
                      Diese Optionen erscheinen unter jeder Nachricht, wenn Sie mit der Maus dar√ºber fahren.
                    </p>
                    <div className="mt-3 flex justify-end">
                      <button 
                        onClick={() => {
                          setShowMessageActionsDialog(false);
                          setRunTour(true);
                          setStepIndex(3); // Skip to the next step (chat sidebar)
                        }}
                        className="rounded-md bg-[#555555] px-3 py-1 text-sm text-white hover:bg-[#666666]"
                      >
                        Weiter
                      </button>
                    </div>
                  </div>
                )}
              </div>
            ))}

            {/* Typing Indicator - Use the new component */}
            {!showFakeMessagesForTour && isTyping && (
              <div className="mb-4 flex justify-start pl-4"> {/* Added bottom margin mb-4 */}
                {/* Replace the old indicator with the new one */}
                <LoadingIndicator />
              </div>
            )}
          </div>
        </div>
        
        {/* Chat Input Footer */}
        <div className="mt-auto flex w-full flex-col items-center bg-[#1e1e1e] px-4 pb-4 pt-2">
          <div className="relative flex items-center space-x-2 rounded-lg border border-[#333333] bg-[#2d2d2d] p-2" style={{ maxWidth: "805px", width: "100%" }}>
            <div className="flex shrink-0 items-center space-x-1">
               <button
                 onClick={handleDeepResearch}
                 disabled={!inputValue.trim() || isTyping || isSearching}
                 className="flex items-center space-x-1 rounded-lg px-2 py-1 text-xs text-[#cccccc] transition-colors hover:bg-[#444444] disabled:cursor-not-allowed disabled:opacity-50"
                 title="Web-Suche starten"
               >
                 {isSearching ? (
                   <Loader size={16} className="animate-spin" />
                 ) : (
                   <Search size={16} />
                 )}
                 <span>Web-Suche</span>
               </button>
               <div className="relative">
                 <button
                   ref={moreOptionsButtonRef}
                   onClick={() => setShowInputMenu(!showInputMenu)}
                   className="rounded-full p-1.5 text-[#cccccc] transition-colors hover:bg-[#444444]"
                   title="Weitere Optionen"
                 >
                   <MoreHorizontal size={20} />
                 </button>
                 
                 {showInputMenu && (
                   <div
                     ref={inputMenuRef}
                     className="absolute bottom-full left-0 z-20 mb-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg"
                   >
                     <button
                       onClick={() => {
                         handleGenerateSummary();
                         setShowInputMenu(false);
                       }}
                       className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                       disabled={messages.length < 2 || isTyping}
                     >
                       <BookOpen size={14} className="mr-2" />
                       Zusammenfassen
                     </button>
                     <button
                       onClick={() => {
                         setShowExportModal(true);
                         setShowInputMenu(false);
                       }}
                       className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                       disabled={messages.length === 0 || isTyping}
                     >
                       <FileDown size={14} className="mr-2" />
                       Exportieren
                     </button>
                     <div className="my-1 border-t border-[#333333]"></div>
                     <button
                       onClick={() => {
                         if(currentChatId && user) deleteChat(currentChatId);
                         setShowInputMenu(false);
                       }}
                       className="flex w-full items-center px-4 py-2 text-sm text-red-500 hover:bg-[#2d2d2d] disabled:cursor-not-allowed disabled:opacity-50"
                       disabled={!currentChatId || messages.length === 0}
                     >
                       <Trash size={14} className="mr-2" />
                       Chat l√∂schen
                     </button>
                   </div>
                 )}
               </div>
            </div>

            <div className="mx-4 flex grow items-center"> {/* Ensure parent uses flex and items-center */} 
                  <textarea
                id="chat-input-textarea"
                    ref={inputRef}
                    value={inputValue}
                    onChange={(e) => setInputValue(e.target.value)}
                    onKeyDown={(e) => {
                      if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                    handleSendMessage(inputValue, false);
                  }
                }}
                placeholder={isTaskSwitching ? "Task wird gewechselt..." : "Stelle irgendeine Frage ..."}
                disabled={isTaskSwitching}
                // Fine-tune vertical padding: pt-2 pb-1
                className={`min-h-10 w-full resize-none bg-transparent px-2 pb-1 pt-2 text-sm text-white placeholder-[#666666] focus:outline-none${isTaskSwitching ? 'cursor-not-allowed opacity-50' : ''}`}
                    rows={1}
                    style={{
                  // minHeight: '40px', // Still handled by Tailwind class
                  maxHeight: '400px'
                    }}
                  />
            </div>

            <div className="shrink-0">
              <button
                onClick={() => handleSendMessage(inputValue, false)}
                disabled={!inputValue.trim() || isTyping || isTaskSwitching}
                className="flex items-center space-x-1 rounded-lg bg-white px-3 py-1.5 text-sm text-black transition-colors hover:bg-gray-200 disabled:cursor-not-allowed disabled:opacity-50"
                title="Nachricht senden"
              >
                {isTaskSwitching ? (
                  <>
                    <div className="size-4 animate-spin rounded-full border-2 border-gray-800 border-t-transparent"></div>
                    <span>Wechseln...</span>
                  </>
                ) : (
                  <>
                <Send size={16} />
                <span>Senden</span>
                  </>
                )}
              </button>
              </div>
            </div>

          <div className="mt-2 text-center text-xs text-[#666666]" style={{ maxWidth: "805px", width: "100%" }}>
             ChatGPT kann Fehler machen. OpenAI verwendet keine Daten aus diesem Chat zum Trainieren seiner Modelle.
          </div>
        </div>
      </main>

      {/* Task Creation Modal */}
      {showTaskModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className="w-full max-w-md rounded-lg border border-[#333333] bg-[#1e1e1e] p-6">
            <h2 className="mb-4 text-xl font-semibold text-white">Neuen Task erstellen</h2>
            <div className="mb-4">
              <label htmlFor="taskName" className="mb-2 block text-sm font-medium text-[#cccccc]">
                Task-Name
              </label>
              <input
                id="taskName"
                type="text"
                value={newTaskName}
                onChange={(e) => setNewTaskName(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Task-Name eingeben"
              />
            </div>
            
            <div className="mb-4">
              <label htmlFor="taskDescription" className="mb-2 block text-sm font-medium text-[#cccccc]">
                Beschreibung
              </label>
              <textarea
                id="taskDescription"
                value={newTaskDescription}
                onChange={(e) => setNewTaskDescription(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Task beschreiben..."
                rows={3}
              />
            </div>
            
            <div className="mb-4">
              <label htmlFor="taskSystemPrompt" className="mb-2 block text-sm font-medium text-[#cccccc]">
                System-Prompt
              </label>
              <div className="relative">
                <textarea
                  id="taskSystemPrompt"
                  value={newTaskSystemPrompt}
                  onChange={(e) => setNewTaskSystemPrompt(e.target.value)}
                  className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 pr-10 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                  placeholder="Strukturiere deinen Prompt! Z.B.: ZIEL: [Dein Ziel...] FORMAT: [Gew√ºnschtes Format...] WARNUNGEN: [Was vermeiden?...] KONTEXT: [Hintergrundinfos...]"
                  rows={4}
                />
                <button
                  type="button"
                  onClick={handleImprovePrompt}
                  disabled={isImprovingPrompt || !newTaskSystemPrompt.trim()}
                  className="absolute right-3 top-3 rounded-md bg-[#333333] p-1.5 text-white/80 transition-colors hover:bg-[#444444] hover:text-white disabled:cursor-not-allowed disabled:opacity-50"
                  title="AI-Unterst√ºtzung f√ºr Prompt"
                >
                  {isImprovingPrompt ? (
                    <Loader size={18} className="animate-spin" />
                  ) : (
                    <Sparkles size={18} />
                  )}
                </button>
              </div>
            </div>
            
            <div className="mb-4">
              <label htmlFor="taskModel" className="mb-2 block text-sm font-medium text-[#cccccc]">
                KI-Modell
              </label>
              <select
                id="taskModel"
                value={newTaskModel}
                onChange={(e) => setNewTaskModel(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white focus:outline-none focus:ring-1 focus:ring-[#444444]"
              >
                <option value="gpt-4o">Basic</option>
                <option value="gpt-4o-mini">Fast</option>
                <option value="o3-mini">Reason</option>
                <option value="gpt-4.5-preview">Reason+</option>
              </select>
            </div>
            
            <div className="flex justify-end space-x-3">
              <button
                onClick={() => {
                  setShowTaskModal(false);
                  setNewTaskName('');
                  setNewTaskDescription('');
                  setNewTaskSystemPrompt('');
                  setNewTaskModel('gpt-4o');
                }}
                className="rounded-lg border border-[#333333] px-4 py-2 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white"
              >
                Abbrechen
              </button>
              <button
                onClick={handleCreateTask}
                disabled={!newTaskName.trim()}
                className={`rounded-lg px-4 py-2 text-sm ${
                  newTaskName.trim() 
                    ? 'border border-[#444444] bg-[#333333] text-white hover:bg-[#444444]' 
                    : 'cursor-not-allowed border border-[#444444]/50 bg-[#333333]/50 text-white/70'
                }`}
              >
                Erstellen
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Export Modal */}
      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        messages={messages}
        onExport={handleExportPdf}
      />
      
      {/* Summary Modal */}
      <SummaryModal
        isOpen={showSummaryModal}
        onClose={() => setShowSummaryModal(false)}
        summary={chatSummary}
        loading={false}
      />

      {/* Projekt Modal (Erstellen/Bearbeiten) */}
      {showProjectModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className="w-full max-w-md rounded-lg border border-[#333333] bg-[#1e1e1e] p-6">
            <h2 className="mb-4 text-xl font-semibold text-white">
              {projectToRename ? 'Projekt bearbeiten' : 'Neues Projekt erstellen'}
            </h2>
            
            <div className="mb-4">
              <label htmlFor="projectName" className="mb-2 block text-sm font-medium text-[#cccccc]">
                Projektname
              </label>
              <input
                id="projectName"
                type="text"
                value={newProjectName}
                onChange={(e) => setNewProjectName(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Projektname eingeben"
              />
            </div>
            
            <div className="mb-4">
              <label htmlFor="projectDescription" className="mb-2 block text-sm font-medium text-[#cccccc]">
                Beschreibung (optional)
              </label>
              <textarea
                id="projectDescription"
                value={newProjectDescription}
                onChange={(e) => setNewProjectDescription(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Projekt beschreiben..."
                rows={3}
              />
            </div>
            
            <div className="flex justify-end space-x-3">
              <button
                onClick={() => {
                  setShowProjectModal(false);
                  setProjectToRename(null);
                  setNewProjectName('');
                  setNewProjectDescription('');
                }}
                className="rounded-lg border border-[#333333] px-4 py-2 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white"
              >
                Abbrechen
              </button>
              <button
                onClick={() => {
                  if (projectToRename) {
                    // Projekt aktualisieren
                    updateProject();
                  } else {
                    // Neues Projekt erstellen
                    handleCreateProject();
                  }
                }}
                disabled={!newProjectName.trim()}
                className={`rounded-lg px-4 py-2 text-sm ${
                  newProjectName.trim() 
                    ? 'border border-[#444444] bg-[#333333] text-white hover:bg-[#444444]' 
                    : 'cursor-not-allowed border border-[#444444]/50 bg-[#333333]/50 text-white/70'
                }`}
              >
                {projectToRename ? 'Aktualisieren' : 'Erstellen'}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Settings Modal */}
      <SettingsModal 
        isOpen={showSettingsModal} 
        onClose={() => setShowSettingsModal(false)} 
        userId={user?.id || ''}
      />
    </div>
  );
}
