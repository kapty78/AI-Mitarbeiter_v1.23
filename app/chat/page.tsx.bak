"use client"

import React from "react"
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs"
import { useEffect, useRef, useState, useMemo, useCallback } from "react"
import { useSearchParams } from "next/navigation"
import Link from "next/link"
import {
  ChevronLeft,
  Menu,
  Plus,
  Send,
  ChevronDown,
  Copy,
  RotateCcw,
  Edit,
  Paperclip,
  Image,
  Search,
  MoreVertical,
  Trash,
  X,
  FlaskConical,
  MoreHorizontal,
  Mic,
  Loader,
  FileText,
  FileDown,
  BookOpen,
  User,
  Settings,
  Home,
  ChevronRight,
  MessageCircle,
  Sparkles,
  Check,
  Filter,
  Loader2
} from "lucide-react" // Added Icons
import ReactMarkdown from "react-markdown"
import remarkGfm from "remark-gfm"
import { v4 as uuidv4 } from "uuid"
import { TypewriterEffect } from "@/components/typewriter-effect"
import { RevealEffect } from "@/components/reveal-effect"; // Import RevealEffect
import { useRouter } from "next/navigation"
import { cn } from "@/lib/utils"
import Joyride, { Step, CallBackProps, STATUS } from "react-joyride" // Import Joyride
import dynamic from "next/dynamic" // Import dynamic
import {
  performSerpApiSearch,
  formatSearchResults,
  formatSearchResultsForAI
} from "../utils/serpApi"
import { downloadChatAsPdf } from "../utils/pdfExport"
import { generateChatSummary } from "../utils/chatSummary"
import ExportModal from "../components/ExportModal"
import SummaryModal from "../components/SummaryModal"
// Drag-and-Drop-Bibliotheken
import {
  DndContext,
  useDraggable,
  useDroppable,
  useSensors,
  useSensor,
  PointerSensor
} from "@dnd-kit/core"
import LoadingIndicator from "@/components/LoadingIndicator" // Corrected import path
import SettingsModal from "@/app/components/SettingsModal" // Import the SettingsModal component
import { KnowledgeBaseSelector } from "@/components/knowledge/KnowledgeBaseSelector"
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter"
import { oneDark } from "react-syntax-highlighter/dist/cjs/styles/prism"
import { MessageMarkdown } from "@/components/message-markdown"
import { MessageCodeBlock } from "@/components/message-code-block"
import { buildPrompt, DEFAULT_SYSTEM_PROMPT } from "@/lib/prompt-builder"

// Dynamically import Joyride with SSR disabled
const DynamicJoyride = dynamic(() => import("react-joyride"), { ssr: false })

// Define a simpler interface for CodeProps
interface CodeProps {
  node?: any
  inline?: boolean
  className?: string
  children?: React.ReactNode
}

interface Message {
  id: string
  role: "user" | "assistant" | "system"
  content: string
  timestamp: Date
  isTypewriting?: boolean
  user_id?: string // Add user_id to track message sender
  sentfrom?: string // Add sentfrom to store user name directly
}

interface ChatSession {
  id: string
  name: string
  created_at: string
  description?: string
  project_id?: string | null
  last_message_timestamp?: string
  user_id?: string
}

interface Task {
  id: string
  title: string
  description: string
  system_prompt: string
  ai_model: string
  created_at?: string
  updated_at?: string
  user_id?: string
  workspace_id?: string | null
  project_id?: string | null
  knowledge_base_ids?: string[]
}

interface Project {
  id: string
  name: string
  description?: string
  user_id: string
  workspace_id?: string | null
  chats?: ChatSession[] // Chats, die zu diesem Projekt geh√∂ren
}

// Define structure for info items (used for buttons, tour content can be different)
interface InfoItem {
  title: string
  // We'll define tour steps separately now
}

// Keep infoItems simple for the buttons
const infoItems: InfoItem[] = [
  { title: "Tasks nutzen" },
  { title: "KI-Modell wechseln" },
  { title: "Nachrichten bearbeiten & neu generieren" },
  { title: "Chats verwalten" }
]

const initialMessages: Message[] = []

// Define Tour Steps (Adjust step 3)
const tourSteps: Step[] = [
  {
    target: "#task-select-button",
    content: (
      <>
        <p className="mb-2">
          Mit Tasks k√∂nnen Sie der KI spezifische Anweisungen oder eine
          bestimmte Rolle f√ºr den gesamten Chat zuweisen.
        </p>
        <p>
          Klicken Sie hier, um einen vorhandenen Task zu w√§hlen oder einen neuen
          zu erstellen. Tasks √ºberschreiben die manuelle Modellauswahl.
        </p>
      </>
    ),
    placement: "bottom-end",
    title: "Tasks nutzen"
  },
  {
    target: "#model-select-button",
    content: (
      <>
        <p className="mb-2 text-sm">
          W√§hlen Sie hier das KI-Modell, wenn kein Task aktiv ist:
        </p>
        <ul className="mb-2 ml-4 list-inside list-disc space-y-1 text-sm">
          <li>
            <strong>Basic (GPT-4o):</strong> Ausgewogen.
          </li>
          <li>
            <strong>Fast (GPT-4o mini):</strong> Schnell & G√ºnstig.
          </li>
          <li>
            <strong>Reason (GPT-4 Vision):</strong> Leistungsstark.
          </li>
        </ul>
      </>
    ),
    placement: "bottom-end",
    title: "KI-Modell wechseln"
  },
  {
    target: "#chat-sidebar",
    content:
      "Hier verwalten Sie Ihre Chats: Neuen Chat erstellen (+), Chat ausw√§hlen, umbenennen oder l√∂schen (√ºber die drei Punkte).",
    placement: "right",
    title: "Chats verwalten"
  },
  {
    target: "#new-chat-button",
    content: "Klicken Sie hier, um einen neuen, leeren Chat zu beginnen.",
    placement: "left",
    title: "Neuer Chat",
    disableScrolling: true,
    disableOverlayClose: true,
    spotlightPadding: 5
  },
  {
    target: "#chat-input-textarea",
    content:
      "Geben Sie hier Ihre Nachricht ein und dr√ºcken Sie Enter oder klicken Sie auf den Senden-Button.",
    placement: "top",
    title: "Nachricht senden"
  }
]

// Helper function to fix the columns handling consistently
const getColumnNames = (columns: any[] | null): string[] => {
  return columns
    ? columns.map((col: { column_name: string }) => col.column_name)
    : []
}

// Detect and format HTML code
const formatCodeInMessage = (content: string): string => {
  // If content already has markdown code blocks, don't modify
  if (content.includes("```")) return content;
  
  // Check if the content appears to be HTML
  if (
    content.trim().startsWith("<") && 
    (content.includes("<!DOCTYPE") || 
     content.includes("<html") ||
     (content.includes("<body") && content.includes("</body>")) ||
     (content.includes("<head") && content.includes("</head>")))
  ) {
    return "```html\n" + content + "\n```";
  }
  
  return content;
};

// This is a standalone component for code blocks

// ---> HILFSFUNKTIONEN f√ºr V2 Prompt <--- 
function trimText(txt: string | null | undefined, maxWords = 60): string {
  if (!txt) return "";
  const words = txt.trim().split(/\s+/);
  if (words.length <= maxWords) return txt;
  return words.slice(0, maxWords).join(" ") + " ‚Ä¶";
}

// V2 System Prompt Definition - entfernt, da jetzt zentral in prompt-builder.ts definiert
// const systemPrompt = `...`.trim();
// ---> ENDE HILFSFUNKTIONEN f√ºr V2 Prompt <--- 

// Add debugging flag at the top of the file, after imports
const DEBUG_MODE = false; // Set to true to enable verbose logging

// Replace console.log with debug-aware logging function
const debugLog = (...args: any[]) => {
  if (DEBUG_MODE) {
    console.log(...args);
  }
};

// Add this custom hook for subscription management
// Place it outside the component, before export default function Chat()
const useSubscriptions = (supabase: any) => {
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const [subscriptionStatus, setSubscriptionStatus] = useState({
    chatsSubscribed: false,
    messagesSubscribed: false
  });

  // Setup chat subscription
  const setupChatSubscription = useCallback((userId: string) => {
    if (!supabase || !userId || chatsChannelRef.current) {
      return;
    }

    const channelId = `chats_updates_global`;
    debugLog(`Setting up realtime subscription for chats table: ${channelId}`);

    const chatsChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chats"
        },
        (payload: any) => {
          debugLog("Realtime chat update received:", payload);
          // Callback to update UI based on the payload would be passed
          // from the component when calling this function
        }
      )
      .subscribe((status: string) => {
        debugLog(`Subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, chatsSubscribed: status === "SUBSCRIBED"}));
      });
    
    chatsChannelRef.current = chatsChannel;
    return chatsChannel;
  }, [supabase]);

  // Setup message subscription
  const setupMessageSubscription = useCallback((chatId: string, userId: string, onMessageReceived: (msg: any) => void) => {
    if (!supabase || !chatId || !userId) {
      return;
    }

    // Cleanup previous subscription if exists
    if (messagesChannelRef.current) {
      debugLog("Cleaning up previous message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    const channelId = `chat_messages_${chatId}`;
    debugLog(`Setting up message subscription for chat: ${chatId}`);

    const messagesChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "chat_messages",
          filter: `chat_id=eq.${chatId}`
        },
        (payload: any) => {
          debugLog(`Realtime message update received for chat ${chatId}:`, payload.eventType);
          
          if (payload.eventType === "INSERT") {
            const newMsg = payload.new;
            // Check if message is from another user
            const msgSentByOtherUser = newMsg.user_id && newMsg.user_id !== userId;
            
            // Only notify if message is from another user or pass to the callback in any case
            onMessageReceived(payload);
          }
        }
      )
      .subscribe((status: string) => {
        debugLog(`Message subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, messagesSubscribed: status === "SUBSCRIBED"}));
      });

    messagesChannelRef.current = messagesChannel;
    return messagesChannel;
  }, [supabase]);

  // Cleanup all subscriptions
  const cleanupSubscriptions = useCallback(() => {
    if (chatsChannelRef.current && supabase) {
      debugLog("Cleaning up chats table subscription");
      supabase.removeChannel(chatsChannelRef.current);
      chatsChannelRef.current = null;
    }

    if (messagesChannelRef.current && supabase) {
      debugLog("Cleaning up message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    setSubscriptionStatus({
      chatsSubscribed: false,
      messagesSubscribed: false
    });
  }, [supabase]);

  return {
    setupChatSubscription,
    setupMessageSubscription,
    cleanupSubscriptions,
    subscriptionStatus
  };
};

// Add this component within the file before the Chat function
interface FunctionCallStatusProps {
  functionName: string;
  isActive: boolean;
}

const FunctionCallStatus: React.FC<FunctionCallStatusProps> = ({ functionName, isActive }) => {
  if (!isActive) return null;
  
  return (
    <div className="flex items-center rounded-lg bg-gray-800 p-2 text-sm text-white shadow-md">
      <Loader2 className="mr-2 h-4 w-4 animate-spin" />
      <span>
        {functionName === "search_document" 
          ? "Durchsuche Dokument f√ºr detaillierte Informationen..." 
          : functionName === "get_document_chunks" 
            ? "Lade vollst√§ndigen Dokumentinhalt..." 
            : "F√ºhre Funktion aus..."}
      </span>
    </div>
  );
};

export default function Chat() {
  const searchParams = useSearchParams()
  const rawWorkspaceId = searchParams.get("workspace")
  const taskId = searchParams.get("task")
  const chatId = searchParams.get("chat")
  const projectId = searchParams.get("project")

  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [user, setUser] = useState<any>(null)
  const [workspace, setWorkspace] = useState<any>(null)
  const [userFullName, setUserFullName] = useState<string>("Du")
  const [messages, setMessages] = useState<Message[]>(initialMessages)
  const [inputValue, setInputValue] = useState("")
  const [isTyping, setIsTyping] = useState(false)
  const [showIceBreakers, setShowIceBreakers] = useState(false)
  const [showModelDropdown, setShowModelDropdown] = useState(false)
  const [selectedModel, setSelectedModel] = useState("gpt-4o")
  const [chatSessions, setChatSessions] = useState<ChatSession[]>([])
  const [currentChatId, setCurrentChatId] = useState<string | null>(null)
  const [tasks, setTasks] = useState<Task[]>([])
  const [selectedTask, setSelectedTask] = useState<Task | null>(null)
  const [showTaskDropdown, setShowTaskDropdown] = useState(false)
  const [showTaskModal, setShowTaskModal] = useState(false)
  const [newTask, setNewTask] = useState<Task>({
    id: "",
    title: "",
    description: "",
    system_prompt: "",
    ai_model: ""
  })
  const [newTaskName, setNewTaskName] = useState("")
  const [newTaskDescription, setNewTaskDescription] = useState("")
  const [newTaskSystemPrompt, setNewTaskSystemPrompt] = useState("")
  const [newTaskModel, setNewTaskModel] = useState("gpt-4o")
  const [showSidebar, setShowSidebar] = useState(true)
  const [typingMessageId, setTypingMessageId] = useState<string | null>(null)
  const [personalWorkspaceId, setPersonalWorkspaceId] = useState<string | null>(
    null
  )
  const [previousSelectedTask, setPreviousSelectedTask] = useState<Task | null>(
    null
  )
  const [previousSelectedModel, setPreviousSelectedModel] = useState<
    string | null
  >(null)
  const [messageUpdatePending, setMessageUpdatePending] = useState(false)
  const [isTaskSwitching, setIsTaskSwitching] = useState(false)
  const [lastMessageUpdate, setLastMessageUpdate] = useState(Date.now())

  // State f√ºr Projekte
  const [projects, setProjects] = useState<Project[]>([])
  const [selectedProject, setSelectedProject] = useState<Project | null>(null)
  const [showProjectDropdown, setShowProjectDropdown] = useState(false)
  const [showProjectModal, setShowProjectModal] = useState(false)
  const [newProjectName, setNewProjectName] = useState("")
  const [newProjectDescription, setNewProjectDescription] = useState("")
  const [projectMenuOpen, setProjectMenuOpen] = useState<string | null>(null)
  const [projectToRename, setProjectToRename] = useState<Project | null>(null)

  // State f√ºr Drag & Drop
  const [draggedChatId, setDraggedChatId] = useState<string | null>(null)
  const [activeDropTarget, setActiveDropTarget] = useState<string | null>(null)

  // State f√ºr aufgeklappte Projekte
  const [expandedProjects, setExpandedProjects] = useState<
    Record<string, boolean>
  >({})

  // State for editing messages
  const [editingMessageId, setEditingMessageId] = useState<string | null>(null)
  const [editingContent, setEditingContent] = useState("")
  
  // State to store original messages during editing
  const [originalMessages, setOriginalMessages] = useState<Message[]>([])

  // Add searchDebounceTimeout ref
  const searchDebounceTimeout = useRef<any>(null)

  const chatBodyRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLTextAreaElement>(null)
  const modelDropdownRef = useRef<HTMLDivElement>(null)
  const taskDropdownRef = useRef<HTMLDivElement>(null)
  const projectDropdownRef = useRef<HTMLDivElement>(null)

  const supabase = createClientComponentClient()

  // Add state for chat menu and rename functionality
  const [chatMenuOpen, setChatMenuOpen] = useState<string | null>(null)
  const [renameModalOpen, setRenameModalOpen] = useState(false)
  const [chatToRename, setChatToRename] = useState<ChatSession | null>(null)
  const [newChatName, setNewChatName] = useState("")
  // Neuer State f√ºr inline edit
  const [editingChatId, setEditingChatId] = useState<string | null>(null)

  const router = useRouter()

  // Add state and refs for the input action menu
  const [showInputMenu, setShowInputMenu] = useState(false)
  const inputMenuRef = useRef<HTMLDivElement>(null)
  const moreOptionsButtonRef = useRef<HTMLButtonElement>(null)

  // F√ºge einen Ref f√ºr die Edit-Box hinzu
  const editBoxRef = useRef<HTMLDivElement>(null)

  // Add state for the new info modal
  // const [showInfoModal, setShowInfoModal] = useState(false)
  // const [modalContent, setModalContent] = useState<InfoItem | null>(null)

  // Add state for React Joyride
  const [runTour, setRunTour] = useState(false)
  const [stepIndex, setStepIndex] = useState(0)

  // State to control showing fake messages during the tour
  const [showFakeMessagesForTour, setShowFakeMessagesForTour] = useState(false)

  // Define fake messages for the tour demonstration
  const fakeTourMessages: Message[] = [
    {
      id: "fake-user-1",
      role: "user",
      content: "Das ist eine Beispiel-Nachricht des Benutzers.",
      timestamp: new Date(Date.now() - 120000) // 2 minutes ago
    },
    {
      id: "fake-ai-message",
      role: "assistant",
      content:
        "Und hier ist eine Beispiel-Antwort der KI. Wenn Sie den Mauszeiger √ºber diese Nachricht bewegen, werden Aktionsbuttons angezeigt.",
      timestamp: new Date(Date.now() - 60000) // 1 minute ago
    }
  ]

  // Add loading state specifically for search
  const [isSearching, setIsSearching] = useState(false)
  // Add chat message search state
  const [searchOpen, setSearchOpen] = useState(false)
  const [messageSearchQuery, setMessageSearchQuery] = useState("")
  const [messageSearchResults, setMessageSearchResults] = useState<any[]>([])

  // New state variables for the export and summary modals
  const [showExportModal, setShowExportModal] = useState(false)
  const [showSummaryModal, setShowSummaryModal] = useState(false)
  const [chatSummary, setChatSummary] = useState("")
  const [isSummarizing, setIsSummarizing] = useState(false)

  // State for showing the message actions dialog
  const [showMessageActionsDialog, setShowMessageActionsDialog] =
    useState(false)
  const [isImprovingPrompt, setIsImprovingPrompt] = useState(false)

  // Add the state for showing settings modal
  const [showSettingsModal, setShowSettingsModal] = useState(false) // Add state for settings modal

  // Add state for storing user names
  const [userNamesMap, setUserNamesMap] = useState<{ [key: string]: string }>(
    {}
  )

  // Neue State-Variable f√ºr die ausgew√§hlte Wissensdatenbank
  const [selectedKnowledgeBaseId, setSelectedKnowledgeBaseId] = useState<
    string[] | null
  >(null)

  // Online-Status-State
  const [isOnline, setIsOnline] = useState<boolean>(true); // Standardm√§√üig annehmen, dass wir online sind

  // Korrekte Typisierung des Refs am Anfang der Komponente
  const initialChatsLoadedRef = useRef(false);
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const isInitializingRef = useRef(false);
  const isStartingNewChatRef = useRef(false);

  // Improved state management for initialization with proper debouncing
  // Add this near the beginning of the component, around line 200-300
  const initializationTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const messageUpdateTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Event-Listener f√ºr Online/Offline-Status
  useEffect(() => {
    // Initialen Status setzen
    setIsOnline(navigator.onLine);
    
    // Handler f√ºr Online/Offline-Events
    const handleOnline = () => {
      console.log("üü¢ Internetverbindung wiederhergestellt");
      setIsOnline(true);
      
      // Optional: Beim Wiederherstellen der Verbindung Daten neu laden
      if (user) {
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        loadChatSessionsMemoized(user.id, workspaceContext);
        loadTasksMemoized(user.id, workspaceContext);
        loadProjectsMemoized(user.id, workspaceContext);
      }
    };
    
    const handleOffline = () => {
      console.log("üî¥ Internetverbindung verloren");
      setIsOnline(false);
    };
    
    // Event-Listener hinzuf√ºgen
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    // Event-Listener beim Unmount entfernen
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [user, rawWorkspaceId, personalWorkspaceId]);
  
  useEffect(() => {
    if (selectedTask && selectedTask.ai_model) {
      setSelectedModel(selectedTask.ai_model)
    }
  }, [selectedTask])

  // UI-Komponente f√ºr Offline-Status 
  const OfflineIndicator = () => {
    if (isOnline) return null;
    
    return (
      <div className="fixed bottom-4 right-4 z-50 rounded-md bg-yellow-600 px-4 py-2 text-white shadow-lg">
        <div className="flex items-center space-x-2">
          <div className="h-2 w-2 rounded-full bg-red-500"></div>
          <span>Offline-Modus - Einige Funktionen sind nicht verf√ºgbar</span>
        </div>
      </div>
    );
  };

  useEffect(() => {
    const fetchPersonalWorkspace = async () => {
      if (user) {
        console.log("Fetching personal workspace for user:", user.id)
        const { data, error } = await supabase
          .from("workspaces")
          .select("id")
          .eq("user_id", user.id)
          .eq("is_home", true)
          .single() // Annahme: Es gibt nur EINEN pers√∂nlichen Workspace

        if (error && error.code !== "PGRST116") {
          // Ignore ' esattamente uma linha esperada'
          console.error("Error fetching personal workspace:", error)
        } else if (data) {
          console.log("Personal workspace found:", data.id)
          setPersonalWorkspaceId(data.id)
        } else {
          console.warn("Personal workspace not found for user:", user.id)
          // Hier k√∂nnte man optional den Workspace erstellen, falls er fehlt
          // oder eine Fehlermeldung anzeigen.
        }
      }
    }
    if (user && !rawWorkspaceId) {
      // Nur laden, wenn kein Workspace in URL und User bekannt
      fetchPersonalWorkspace()
    }
  }, [user, supabase, rawWorkspaceId]) // Abh√§ngigkeiten

  // Optimierte Kontextauswahl mit Caching, besserer Priorisierung und Ausschluss aktueller Nachrichten
  // Cache f√ºr Chat-Sessions um redundante Ladevorg√§nge zu vermeiden
  const chatSessionsCache: {
    sessions: any[] | null
    timestamp: number
    maxAge: number
  } = {
    sessions: null,
    timestamp: 0,
    maxAge: 5000 // Cache ist f√ºr 5 Sekunden g√ºltig
  }

  // Cache f√ºr Projektberechnungen
  const projectsCache: {
    projectChats: Map<string, any[]> | null
    timestamp: number
    maxAge: number
  } = {
    projectChats: null,
    timestamp: 0,
    maxAge: 10000 // Cache ist f√ºr 10 Sekunden g√ºltig
  }

  // Optimierte Funktion zum Laden von Chat-Sessions mit Caching
  const loadChatSessionsWithCache = async (
    userId: string,
    workspaceId: string | null
  ) => {
    const now = Date.now()

    // Pr√ºfen, ob der Cache g√ºltig ist
    if (
      chatSessionsCache.sessions &&
      now - chatSessionsCache.timestamp < chatSessionsCache.maxAge
    ) {
      console.log("üì¶ Verwende gecachte Chat-Sessions")
      return chatSessionsCache.sessions
    }

    console.log(
      `üîÑ Loading chat sessions - userId: ${userId} workspaceId: ${workspaceId}`
    )

    // Lade Daten wie zuvor
    const { data, error } = await supabase
      .from("chats")
      .select("*")
      .eq("user_id", userId)
      .eq("workspace_id", workspaceId)
      .order("updated_at", { ascending: false })

    if (error) {
      console.error("‚ùå Fehler beim Laden der Chat-Sessions:", error)
      return []
    }

    console.log(`‚úÖ Loaded ${data.length} chat sessions`)

    // Verarbeite Daten und speichere sie im Cache
    const formattedSessions = data.map((chat: any) => ({
      id: chat.id,
      name: chat.name || "Neuer Chat",
      timestamp: chat.updated_at,
      message_count: chat.message_count || 0,
      project: chat.project || null,
      temperature: chat.temperature,
      model: chat.model || null
    }))

    // Cache aktualisieren
    chatSessionsCache.sessions = formattedSessions
    chatSessionsCache.timestamp = now

    return formattedSessions
  }

  // Optimierte Funktion zur Projektberechnung mit Caching
  const recalculateProjectsWithCache = (chats: any[]) => {
    const now = Date.now()

    // Pr√ºfen, ob der Cache g√ºltig ist
    if (
      projectsCache.projectChats &&
      now - projectsCache.timestamp < projectsCache.maxAge
    ) {
      return projectsCache.projectChats
    }

    console.log(
      `üî¢ Berechne Projekte neu aus ${chats.length} verf√ºgbaren Chats`
    )

    const projectChats = new Map()

    // Projekte berechnen wie zuvor
    const availableProjects = [
      ...new Set(chats.filter(c => c.project).map(c => c.project))
    ]

    availableProjects.forEach(project => {
      const chatsInProject = chats.filter(c => c.project === project)
      projectChats.set(project, chatsInProject)
      console.log(`üóÇÔ∏è Projekt ${project} hat ${chatsInProject.length} Chats`)
    })

    // Cache aktualisieren
    projectsCache.projectChats = projectChats
    projectsCache.timestamp = now

    return projectChats
  }

  // Hauptfunktion f√ºr die Kontext-Suche, verbessert mit Ausschluss der aktuellen Nachricht
  const findSimilarMessagesOptimized = async (
    userId: string,
    query: string,
    currentMessageId: string | null = null
  ) => {
    debugLog(`üîç Suche nach √§hnlichen Nachrichten f√ºr User ${userId}`);
    debugLog(`üìù Suchanfrage: "${query}"`);

    // Skip search for very short queries to reduce database load
    if (query.trim().length < 3) {
      debugLog("‚è© √úberspringe Suche f√ºr zu kurze Anfrage (weniger als 3 Zeichen)");
      return [];
    }

    // Validiere userId
    if (!userId || typeof userId !== "string" || userId.trim() === "") {
      console.error("‚ùå Ung√ºltige userId f√ºr die Suche:", userId);
      return [];
    }

    try {
      // Erstelle ein tempor√§res Nachrichtenobjekt f√ºr das Embedding
      const tempQueryMessage = {
        content: query,
        id: "query", // Diese ID wird nicht in der DB gespeichert
        role: "user" as "user", // Explizit typisieren
        timestamp: new Date()
      };

      // Erstelle Embedding f√ºr die Anfrage
      debugLog(`üß† Generiere Embedding f√ºr Suchanfrage...`);

      try {
        // Direkter Aufruf der Embedding-API als tempor√§rer Ersatz f√ºr createEmbedding
        debugLog("üì® Original Nachrichteninhalt:", tempQueryMessage.content);
        const currentDate = new Date().toISOString().split("T")[0];
        const contentWithDate = `[Datum: ${currentDate}]\n${tempQueryMessage.content}`;
        
        const response = await fetch("/api/embeddings", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            input: contentWithDate
          })
        });
        
        if (!response.ok) {
          throw new Error(`Embedding API responded with ${response.status}`);
        }
        
        const embeddingData = await response.json();
        const embedding = embeddingData.embedding;

        if (!embedding) {
          console.error("‚ùå Fehler beim Generieren des Embeddings f√ºr die Suche");
          return [];
        }

        debugLog(`‚úÖ Embedding f√ºr Abfrage erfolgreich generiert`);
        debugLog(`üìä Query-Embedding-Dimensionen: ${embedding.length}`);
        
        // Adjust similarity threshold based on query length
        const dynamicThreshold = query.length < 10 ? 0.75 : 0.65;
        const maxResults = query.length < 10 ? 10 : 20;
        
        debugLog(
          `üìû Rufe search_similar_messages RPC f√ºr User ${userId} auf (Schwellwert: ${dynamicThreshold}, Max Ergebnisse: ${maxResults})`
        );

        // RPC f√ºr die √Ñhnlichkeitssuche aufrufen
        const { data: results, error } = await supabase.rpc(
          "search_similar_messages",
          {
            p_user_id: userId,
            query_embedding: embedding,
            similarity_threshold: dynamicThreshold, // Use dynamic threshold
            max_results: maxResults
          }
        );

        if (error) {
          console.error("‚ùå Fehler bei der RPC-Suche nach √§hnlichen Nachrichten:", error);
          return [];
        }

        debugLog(`üîé RPC Ergebnis: ${results?.length || 0} Nachrichten gefunden`);
        
        if (!results || results.length === 0) {
          return [];
        }
        
        if (DEBUG_MODE) {
          debugLog(`üìã Erste Ergebnisse (Rohdaten): ${JSON.stringify(results?.slice(0, 2) || [])}`);
        }

        // Filtere die aktuelle Nachricht, falls vorhanden
        let filteredResults = results || [];
        if (currentMessageId) {
          const originalLength = filteredResults.length;
          filteredResults = filteredResults.filter(
            (msg: any) => msg.message_id !== currentMessageId
          );
          if (originalLength !== filteredResults.length) {
            debugLog(`üßπ Aktuelle Nachricht mit ID ${currentMessageId} aus Ergebnissen ausgeschlossen`);
          }
        }

        // Schnellere Verarbeitung der Datumsangaben ohne √ºberm√§√üiges Logging
        for (const msg of filteredResults) {
          // Generiere eine anzeigbare Version des Inhalts ohne Datum
          msg.displayContent = msg.content;
          if (msg.content && typeof msg.content === 'string' && msg.content.startsWith('[Datum:') && msg.content.includes(']\n')) {
            msg.displayContent = msg.content.replace(/^\[Datum:[^\]]+\]\n/, '');
          }
          
          // Extrahiere Datum aus dem Nachrichteninhalt, aber logge nicht jede Nachricht
          const dateMatch = msg.content?.match(/\[Datum: ([^\]]+)\]/);
          msg.dateInfo = dateMatch ? dateMatch[1] : null;
        }

        debugLog(`‚úÖ ${filteredResults.length} √§hnliche Nachrichten nach Filterung gefunden`);

        return filteredResults;
      } catch (error) {
        console.error("‚ùå Fehler beim Erstellen des Embeddings:", error);
        return [];
      }
    } catch (error) {
      console.error("‚ùå Fehler bei der Suche nach √§hnlichen Nachrichten:", error);
      return [];
    }
  };

  // Verbesserte Kontext-Auswahlfunktion mit optimierter Bewertung f√ºr neueste/√§lteste Nachrichten
  const prepareContextMessage = (contextContent: string) => {
    return {
      role: "system",
      content: `Relevanter Kontext aus fr√ºheren Gespr√§chen:\n\n${contextContent}\n\nDies sind Ausschnitte aus vorherigen Konversationen, die f√ºr die aktuelle Frage relevant sein k√∂nnten. Die mit "neueste Information" markierten Abschnitte enthalten den aktuellsten Stand zu diesem Thema, w√§hrend "erste Erw√§hnung" historischen Kontext bietet. Nutze diese Informationen, um eine informierte Antwort zu geben, besonders wenn der Benutzer sich auf bereits besprochene Themen bezieht.`
    }
  }

  const loadChatSessions = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      console.log(
        "üîÑ Loading chat sessions - userId:",
        userId,
        "workspaceId:",
        workspaceId
      )

      // Verwende personalWorkspaceId als Fallback, wenn keine workspaceId √ºbergeben wird
      const targetWorkspaceId = workspaceId || personalWorkspaceId

      // Build the query
      let query = supabase
        .from("chats")
        .select(
          "id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id"
        )

      // Properly handle null workspace IDs
      if (targetWorkspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Chats in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq("workspace_id", targetWorkspaceId)
      } else {
        // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is("workspace_id", null).eq("user_id", userId)
      }

      const { data, error } = await query.order("last_message_timestamp", {
        ascending: false
      })

      if (error) {
        console.error("‚ùå Error loading chat sessions:", error)
        setError(`Fehler beim Laden der Chats: ${error.message}`)
        throw error
      }

      if (data) {
        console.log("‚úÖ Loaded", data.length, "chat sessions")
        console.log("Chat data:", data) // Debug: Zeige die Chat-Daten

        const formattedSessions = data.map((chat: any) => ({
          id: chat.id || "",
          name: chat.name || "Unnamed Chat",
          created_at: chat.created_at || new Date().toISOString(),
          last_message_timestamp: chat.last_message_timestamp,
          user_id: chat.user_id, // Behalte user_id um den Ersteller anzuzeigen
          ...(chat.description && { description: chat.description }),
          project_id: chat.project_id
        }))

        console.log("Formatted sessions:", formattedSessions) // Debug: Zeige die formatierten Sessions
        setChatSessions(formattedSessions)
      } else {
        console.log("‚ÑπÔ∏è No chat sessions found")
        setChatSessions([])
      }
    } catch (err) {
      console.error("‚ùå Error in loadChatSessions:", err)
      setChatSessions([])
    }
  }

  const createNewChat = async () => {
    try {
      if (!user) {
        setError("Sie m√ºssen angemeldet sein, um einen Chat zu erstellen.")
        return null
      }

      // Determine the workspace ID to use - simplify this logic
      const workspaceId = rawWorkspaceId || personalWorkspaceId

      if (!workspaceId) {
        setError(
          "Konnte keinen g√ºltigen Arbeitsbereich zum Erstellen des Chats finden."
        )
        return null
      }

      console.log(`Creating new chat in workspace: ${workspaceId}`)

      // Create a new chat with a temporary name - we'll update it later
      const newChatId = uuidv4()
      const initialTitle = "Neuer Chat"

      // Create with retry to ensure it succeeds
      const { data: newChat, error } = await supabase
        .from("chats")
        .insert({
          id: newChatId,
          user_id: user.id,
          name: initialTitle,
          workspace_id: workspaceId,
          created_at: new Date().toISOString(),
          last_message_timestamp: new Date().toISOString()
        })
        .select()
        .single()

      if (error) {
        console.error(`‚ùå Error creating new chat: ${error.message}`)
        setError(`Fehler beim Erstellen des Chats: ${error.message}`)
        return null
      }

      if (!newChat) {
        console.error("‚ùå No chat data returned after creation")
        setError("Fehler beim Erstellen des Chats: Keine Daten zur√ºckgegeben")
        return null
      }

      console.log(`‚úÖ Successfully created new chat with ID: ${newChatId}`)

      // Set the current chat ID immediately
      setCurrentChatId(newChatId)

      // Wait for the database to properly register the new chat
      await new Promise(resolve => setTimeout(resolve, 300))

      // Reload chat sessions to update UI
      if (user) {
        await loadChatSessions(user.id, workspaceId)
      }

      return newChatId
    } catch (err) {
      console.error("Error in createNewChat:", err)
      setError(
        `Fehler beim Erstellen des Chats: ${err instanceof Error ? err.message : "Unbekannter Fehler"}`
      )
      return null
    }
  }

  const loadChat = async (chatId: string) => {
    try {
      setCurrentChatId(chatId)

      // Try to get chat details first to confirm it exists
      const { data: chatData, error: chatError } = await supabase
        .from("chats")
        .select("id, name")
        .eq("id", chatId)
        .single()

      if (chatError) {
        console.error("Error fetching chat details:", chatError)
        return
      }

      // Get chat messages - now only using chat_id
      const { data: messagesData, error: messagesError } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (messagesError) {
        console.error("Error fetching chat messages:", messagesError)
        setMessages([])
        return
      }

      if (messagesData && messagesData.length > 0) {
        // Transform to our Message format
        const transformedMessages = messagesData.map((msg: any) => ({
          id: uuidv4(),
          role: msg.role as "user" | "assistant" | "system",
          content: msg.content,
          timestamp: new Date(msg.created_at),
          user_id: msg.user_id, // Store user_id from database
          sentfrom: msg.sentfrom // Store sentfrom from database
        }))

        setMessages(transformedMessages)
        console.log(
          `Loaded ${transformedMessages.length} messages for chat ${chatId}`
        )

        // Fetch usernames for all unique user_ids in messages
        const userIds = [
          ...new Set(
            transformedMessages
              .filter(msg => msg.role === "user" && msg.user_id)
              .map(msg => msg.user_id)
          )
        ]

        if (userIds.length > 0) {
          const { data: profilesData, error: profilesError } = await supabase
            .from("profiles")
            .select("id, full_name")
            .in("id", userIds)

          if (profilesError) {
            console.error("Error fetching user profiles:", profilesError)
          } else if (profilesData) {
            // Create a map of user_id to full_name
            const userNames: { [key: string]: string } = {}
            profilesData.forEach(profile => {
              userNames[profile.id] = profile.full_name
            })
            setUserNamesMap(userNames)
          }
        }
      } else {
        console.log(`No messages found for chat ${chatId}`)
        setMessages([])
      }
    } catch (err) {
      console.error("Error loading chat:", err)
      setMessages([])
    }
  }

  const loadTasks = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status pr√ºfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - √úberspringe Laden der Tasks");
        return; // Fr√ºher Abbruch bei fehlender Internetverbindung
      }

      // Timeout f√ºr die Anfrage setzen, um lange h√§ngende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("tasks").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Tasks in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufr√§umen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedTasks = data.map(task => ({
            ...task,
            title: task.title || task.name,
            ai_model: task.ai_model || task.preferred_model || "gpt-4o"
          }));
          setTasks(formattedTasks);
        }
      } catch (fetchError: any) {
        // Timeout aufr√§umen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Pr√ºfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Task-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Tasks - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading tasks:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu √ºberfluten
      // Wenn die Seite neu geladen wird, wird ein neuer Versuch unternommen
    }
  };

  const loadProjects = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status pr√ºfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - √úberspringe Laden der Projekte");
        return; // Fr√ºher Abbruch bei fehlender Internetverbindung
      }

      // Timeout f√ºr die Anfrage setzen, um lange h√§ngende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("projects").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Projekte in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufr√§umen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedProjects = data.map(project => ({
            ...project,
            name: project.name || project.title,
            workspace_id:
              project.workspace_id || project.preferred_workspace_id || "gpt-4o"
          }));
          setProjects(formattedProjects);
        }
      } catch (fetchError: any) {
        // Timeout aufr√§umen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Pr√ºfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Project-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Projekte - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading projects:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu √ºberfluten
    }
  };

  // Wenn ein user (per Link Sharing) einen spezifischen Chat betritt, dann direkt laden
  useEffect(() => {
    // Lade alle verf√ºgbaren Tasks als Optionen
    if (user) {
      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
      loadTasks(user.id, workspaceContext)
    }

    // Wenn eine Task-ID in der URL ist, lade diese Task
    if (taskId) {
      console.log("Task ID in URL gefunden:", taskId)
      const fetchTask = async () => {
        if (!supabase) return

        const { data, error } = await supabase
          .from("tasks")
          .select("*")
          .eq("id", taskId)
          .single()

        if (error) {
          console.error("Fehler beim Laden der Task:", error)
          return
        }

        if (data) {
          console.log("Task geladen:", data)
          setSelectedTask(data)
          setSelectedModel(data.ai_model || "gpt-4o")
        }
      }

      fetchTask()
    }
  }, [user, taskId, supabase, rawWorkspaceId, personalWorkspaceId, loadTasks])

  // Effect f√ºr die Textareabehandlung
  useEffect(() => {
    const textarea = inputRef.current
    if (textarea) {
      // Reset height - wichtig, um zu verhindern, dass es nur nach oben w√§chst
      textarea.style.height = "auto"
      // Setze die neue H√∂he basierend auf dem Scroll-H√∂hen-Wert
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`
    }
  }, [inputValue])

  // Reduziere unn√∂tige Re-Renders durch Memoization der Lade-Funktionen
  const loadChatSessionsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadChatSessions(userId, workspaceId);
    },
    [supabase, setChatSessions]
  );
  
  const loadChatMemoized = useCallback(
    async (chatId: string) => {
      return await loadChat(chatId);
    },
    [supabase, user, setMessages, setUserNamesMap]
  );
  
  const loadTasksMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadTasks(userId, workspaceId);
    },
    [supabase, setTasks]
  );
  
  const loadProjectsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadProjects(userId, workspaceId);
    },
    [supabase, setProjects]
  );

  // Haupt-Initialisierungscode f√ºr den Chat
  useEffect(() => {
    // Zeitsperre, um zu h√§ufige Aufrufe zu verhindern
    const checkSession = async () => {
      // Vermeide mehrfache gleichzeitige Initialisierungen
      if (isInitializingRef.current) {
        debugLog("Initialization already in progress, skipping");
        return;
      }
      
      isInitializingRef.current = true;
      try {
        setLoading(true);

        // Pr√ºfe, ob der Benutzer angemeldet ist
        const {
          data: { session }
        } = await supabase.auth.getSession();

        if (!session) {
          console.log("No session found, redirecting to login");
          router.push("/login");
          return;
        }

        // Benutzer ist angemeldet
        setUser(session.user);

        // Profilnamen laden (nicht kritisch f√ºr Initialisierung)
        if (!userFullName || userFullName === "Du") {
          try {
            const { data: profileData } = await supabase
              .from("profiles")
              .select("full_name")
              .eq("id", session.user.id)
              .single();

            if (profileData?.full_name) {
              setUserFullName(profileData.full_name);
            }
          } catch (profileError) {
            console.error("Error loading user profile:", profileError);
          }
        }

        debugLog(`*** Session exists, user: ${session.user.id}`);

        // Workspace-Kontext bestimmen
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        debugLog("Current workspace context:", workspaceContext);

        // Chats nur laden, wenn n√∂tig
        if (workspaceContext && !initialChatsLoadedRef.current && chatSessions.length === 0) {
          debugLog("Loading chat sessions for the first time");
          // Use Promise.all to load data in parallel
          await Promise.all([
            loadChatSessionsMemoized(session.user.id, workspaceContext),
            loadProjectsMemoized(session.user.id, workspaceContext)
          ]);
          initialChatsLoadedRef.current = true;
        }

        // Check if project ID and chat ID are specified in URL
        const projectIdFromUrl = searchParams.get("project");
        const chatIdFromUrl = searchParams.get("chat");
        
        if (projectIdFromUrl) {
          // Set the project filter
          debugLog("Setting project filter from URL:", projectIdFromUrl);
          setActiveProjectFilter(projectIdFromUrl);
          setProjectFilterActive(true);
          
          // Also expand the project in the sidebar
          setExpandedProjects(prev => ({
            ...prev,
            [projectIdFromUrl]: true
          }));
          
          // Set the selected project
          const projectFromId = projects.find(p => p.id === projectIdFromUrl);
          if (projectFromId) {
            setSelectedProject(projectFromId);
          }
        }
        
        // If a specific chat is specified in the URL, load it
        if (chatIdFromUrl) {
          debugLog("Chat ID specified in URL:", chatIdFromUrl);
          setCurrentChatId(chatIdFromUrl);
          await loadChatMemoized(chatIdFromUrl);
          
          // No need to continue with other chat loading logic
          return;
        }

        // If no specific chat ID was provided in the URL, follow regular chat loading logic
        if (currentChatId) {
          debugLog("Chat ID in state bereits vorhanden:", currentChatId);
          await loadChatMemoized(currentChatId);
        } else if (chatSessions.length > 0 && !messages.length && !isStartingNewChatRef.current) {
          // Sonst lade den ersten Chat, aber nur wenn:
          // - keine Nachrichten bereits geladen sind 
          // - UND kein expliziter Neustart eines Chats angefordert wurde
          debugLog("Lade den ersten Chat aus vorhandenen Sessions:", chatSessions[0].id);
          setCurrentChatId(chatSessions[0].id);
          await loadChatMemoized(chatSessions[0].id);
        } else if (isStartingNewChatRef.current) {
          debugLog("Neuer Chat wurde explizit angefordert - lade keinen vorhandenen Chat");
          // Flag zur√ºcksetzen nach Verwendung
          isStartingNewChatRef.current = false;
        }

        // Tasks laden (wenn noch nicht geladen)
        if (tasks.length === 0 && workspaceContext) {
          await loadTasksMemoized(session.user.id, workspaceContext);
        }

        // Icebreakers zeigen, wenn keine Nachrichten vorhanden
        if (messages.length === 0) {
          setShowIceBreakers(true);
        }

        // Task laden, wenn eine ID √ºbergeben wurde
        if (taskId && (!selectedTask || selectedTask.id !== taskId)) {
          const { data: taskData, error } = await supabase
            .from("tasks")
            .select("*")
            .eq("id", taskId)
            .single();

          if (!error && taskData) {
            debugLog("Task geladen:", taskData);
            setSelectedTask(taskData);
            setSelectedModel(taskData.ai_model || selectedModel);
          }
        }
      } catch (err: any) {
        console.error("Chat init error:", err);
        setError(err.message);
      } finally {
        setLoading(false);
        
        // Use setTimeout to avoid race conditions when setting isInitializingRef
        if (initializationTimeoutRef.current) {
          clearTimeout(initializationTimeoutRef.current);
        }
        
        initializationTimeoutRef.current = setTimeout(() => {
          isInitializingRef.current = false;
          debugLog("Initialization flag reset to false");
          initializationTimeoutRef.current = null;
        }, 100);
      }
    };

    checkSession();
    
    // Cleanup function
    return () => {
      if (initializationTimeoutRef.current) {
        clearTimeout(initializationTimeoutRef.current);
      }
      if (messageUpdateTimeoutRef.current) {
        clearTimeout(messageUpdateTimeoutRef.current);
      }
    };
  }, [
    supabase,
    currentChatId,
    personalWorkspaceId,
    rawWorkspaceId,
    router,
    taskId,
    loadChat,
    loadChatSessions,
    loadProjects,
    loadTasks
  ]);

  /* eslint-disable react-hooks/rules-of-hooks */
  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        modelDropdownRef.current &&
        !modelDropdownRef.current.contains(event.target as Node)
      ) {
        setShowModelDropdown(false)
      }

      if (
        taskDropdownRef.current &&
        !taskDropdownRef.current.contains(event.target as Node)
      ) {
        setShowTaskDropdown(false)
      }

      // Schlie√üe Chat-Men√º bei Klick au√üerhalb
      const chatMenuTarget = (event.target as Element)?.closest(
        "[data-chat-menu]"
      )
      if (chatMenuOpen && !chatMenuTarget) {
        setChatMenuOpen(null)
      }

      // Schlie√üe Projekt-Men√º bei Klick au√üerhalb
      const projectMenuTarget = (event.target as Element)?.closest(
        "[data-project-menu]"
      )
      if (projectMenuOpen && !projectMenuTarget) {
        setProjectMenuOpen(null)
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [chatMenuOpen, projectMenuOpen])

  // Haupt-Funktion zum Senden einer Nachricht an die API
  const sendMessageToAPI = async (
    messages: Message[],
    model: string,
    chatId: string
  ) => {
    console.log(`üîÑ sendMessageToAPI aufgerufen mit Chat-ID: ${chatId}`);

    const userId = user?.id;
    if (!userId) {
      console.error("‚ùå User ID fehlt beim Senden an API.");
      throw new Error("User ID ist erforderlich");
    }

    // 1. DATEN SAMMELN
    // --------------------------------
    console.log(`üë§ Hole Benutzerprofil f√ºr User ID: ${userId}`);
    const { data: fetchedUserProfile, error: profileError } = await supabase
        .from("profiles")
        .select("*")
      .eq("id", userId)
      .single();
      
    if (profileError) console.error("Fehler beim Abrufen des Profils:", profileError);
    else console.log("‚úÖ Benutzerprofil erfolgreich abgerufen");

    const lastUserMessage = [...messages].reverse().find(m => m.role === "user");
    let knowledgeResults: any[] = [];
    let similarMessages: any[] = [];
    const currentSelectedTask = selectedTask;

    if (lastUserMessage) {
        const userQuery = lastUserMessage.content;
        
        // Wissensdatenbank-Suche (falls KB ausgew√§hlt)
        if (selectedKnowledgeBaseId && selectedKnowledgeBaseId.length > 0) { 
            try {
                console.log(`üß† Performing knowledge base search for KBs: ${selectedKnowledgeBaseId.join(', ')}...`);
                const { data: authData } = await supabase.auth.getSession();
                const authToken = authData?.session?.access_token;

                // Alle Ergebnisse aus allen ausgew√§hlten Wissensdatenbanken sammeln
                let allKnowledgeResults: any[] = [];
                
                // Sequentiell durch alle ausgew√§hlten Wissensdatenbanken gehen
                for (const kbId of selectedKnowledgeBaseId) {
                    const knowledgeResponse = await fetch("/api/knowledge/search", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            query: userQuery,
                            knowledge_base_id: kbId,
                            auth_token: authToken
                        })
                    });
                    
                    if (knowledgeResponse.ok) {
                        const knowledgeData = await knowledgeResponse.json();
                        const results = knowledgeData.results || [];
                        console.log(`üß† Found ${results.length} raw knowledge items from KB ${kbId}.`);
                        allKnowledgeResults.push(...results);
                    } else {
                        console.error(`‚ö†Ô∏è Knowledge base search failed for KB ${kbId}:`, knowledgeResponse.statusText);
                    }
                }
                
                // Sortiere alle Ergebnisse nach Relevanz (falls ein similarity-Feld existiert)
                knowledgeResults = allKnowledgeResults.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));
                console.log(`üß† Combined ${knowledgeResults.length} total knowledge items from all KBs.`);
          
            } catch (knowledgeError) {
                console.error("‚ùå Error during knowledge base search fetch:", knowledgeError);
            }
        } else {
            console.log("‚ÑπÔ∏è Keine Wissensdatenbank ausgew√§hlt, √ºberspringe Suche.");
        }
        
        // Suche nach √§hnlichen Nachrichten
        try {
            console.log(`üîç Suche nach User-weiten Kontext f√ºr User ${userId}, basierend auf: ${userQuery.substring(0, 30)}...`);
            similarMessages = await findSimilarMessagesOptimized(userId, userQuery, lastUserMessage.id) || [];
            console.log(`‚úÖ ${similarMessages.length} √§hnliche Nachrichten gefunden`);
        } catch (error) {
            console.error("‚ùå Fehler bei der Suche nach √§hnlichen Nachrichten:", error);
        }
    } else {
      console.warn("Keine letzte Benutzernachricht gefunden, kann keinen Kontext generieren.");
    }
    
    // KONSOLIDIERTE PROMPT-ERSTELLUNG MIT DEM PROMPT-BUILDER
    // -------------------------------------------
    const userInput = lastUserMessage ? lastUserMessage.content : "";
    
    // Verwende den buildPrompt statt manueller Zusammensetzung
    const finalPrompt = buildPrompt({
      userInput,
      chatId,
      taskPrompt: currentSelectedTask?.system_prompt || null,
      userProfile: fetchedUserProfile,
      knowledgeResults,
      pastMessages: similarMessages,
      allMessages: messages,
      modelType: "default", // Standard-Chat
      maxPastMessages: 4,
      maxKnowledgeResults: 3
    });
    
    console.log(`üì© Sende an API: ${messages.filter(m => m.role !== 'system').length} User/Assistant Nachrichten, ${finalPrompt.length - messages.filter(m => m.role !== 'system').length} System/Assistant Kontextobjekt(e)`);
    
    // 4. API CALL MIT KNOWLEDGE RESULTS
    // --------------------------------------------------
    try {
        const apiUrl = `/api/chat?model=${encodeURIComponent(model)}&chatId=${encodeURIComponent(chatId)}`;
        const apiResponse = await fetch(apiUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            messages: finalPrompt,
            knowledgeResults, // Explizit die Knowledge Results zum Body hinzuf√ºgen
            stream: true
          })
        });

        // Pr√ºfe, ob es ein Event-Stream ist
        if (apiResponse.headers.get('Content-Type')?.includes('text/event-stream')) {
          // Cleanup bestehender EventSource
          if (eventSource) {
            eventSource.close();
          }

          // Stream-Reader erstellen
          const reader = apiResponse.body?.getReader();
          const decoder = new TextDecoder();

          if (reader) {
            // Stream lesen
            while (true) {
              const { done, value } = await reader.read();

              if (done) {
                console.log("Stream ended");
                setActiveFunctionCall(null);
                break;
              }

              const chunk = decoder.decode(value);
              const lines = chunk.split("\n").filter(line => line.trim());

              for (const line of lines) {
                try {
                  const data = JSON.parse(line);
                  
                  if (data.type === 'tool_call' && data.tool_call) {
                    // UI-Update f√ºr Tool-Aufruf anzeigen
                    console.log(`‚öôÔ∏è Tool call detected:`, data.tool_call);
                    
                    // Funktionsnamen aus dem Tool-Aufruf extrahieren
                    if (data.tool_call.length > 0 && data.tool_call[0]?.function?.name) {
                      const functionName = data.tool_call[0].function.name;
                      setActiveFunctionCall(functionName);
                    }
                  }
                  else if (data.type === 'content' && data.content) {
                    // Funktionsaufruf-Status zur√ºcksetzen, wenn Inhalte kommen
                    setActiveFunctionCall(null);
                    appendStreamToLastMessage(data.content);
                  }
                  else if (data.type === 'finish') {
                    setActiveFunctionCall(null);
                  }
                } catch (e) {
                  console.error("Error parsing stream data:", e);
                }
              }
            }
          }
          
          return { content: "Streaming response completed" };
        }

        // Nicht-gestreamte Antwort verarbeiten
        if (!apiResponse.ok) {
          // Antwortk√∂rper protokollieren, falls verf√ºgbar
          const errorBody = await apiResponse.text();
          console.error("API Error Response Body:", errorBody);
          throw new Error(`API responded with ${apiResponse.status}`);
        }

        const data = await apiResponse.json();
        return data; // R√ºckgabe an den Aufrufer (handleSendMessage)

    } catch (error) {
      console.error("‚ùå Fehler beim API-Aufruf in sendMessageToAPI:", error);
      setActiveFunctionCall(null); // Funktionsaufrufstatus im Fehlerfall zur√ºcksetzen
      throw error; // Fehler weitergeben
    }
  }

  const handleTypewriterComplete = (messageId: string) => {
    console.log("Animation effect completed for message:", messageId)
    
    // Get message details
    const message = messages.find(m => m.id === messageId);
    if (message) {
      console.log(`Message length: ${message.content.length} characters`);
      
      // For very long messages, add a small delay before removing the typing effect
      // This ensures the animation completes smoothly
      const contentLength = message.content.length;
      if (contentLength > 2000) {
        console.log("Long message detected, adding delay before finalizing animation");
        // Add a delay proportional to the content length, with a maximum
        const delay = Math.min(500, contentLength / 10);
        
        setTimeout(() => {
          // Update message to mark animation as complete after delay
          setMessages(prevMessages => 
            prevMessages.map(m =>
              m.id === messageId ? { ...m, isTypewriting: false } : m
            )
          );
          setTypingMessageId(null);
        }, delay);
        
        return;
      }
    }
    
    // For normal-length messages, complete immediately
    const updatedMessages = messages.map(m =>
      m.id === messageId ? { ...m, isTypewriting: false } : m
    );
    setMessages(updatedMessages);
    setTypingMessageId(null);
  }

  const handleCreateTask = async () => {
    if (!newTaskName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || null

      const { data, error } = await supabase
        .from("tasks")
        .insert({
          title: newTaskName,
          description: newTaskDescription,
          system_prompt: newTaskSystemPrompt,
          ai_model: newTaskModel,
          status: "todo",
          priority: "medium",
          user_id: user.id,
          workspace_id: workspaceContext,
          knowledge_base_ids: newTaskKnowledgeBaseId.length > 0 ? newTaskKnowledgeBaseId : null
        })
        .select()

      if (error) throw error

      await loadTasks(user.id, workspaceContext)

      setShowTaskModal(false)
      setNewTaskName("")
      setNewTaskDescription("")
      setNewTaskSystemPrompt("")
      setNewTaskModel("gpt-4o")
      setNewTaskKnowledgeBaseId([]) // Reset knowledge base IDs
    } catch (err) {
      console.error("Error creating task:", err)
    } finally {
      setLoading(false)
    }
  }

  const handleCreateProject = async () => {
    if (!newProjectName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null

      // ---> START DEBUG LOG <---
      console.log("--- Creating Project --- ")
      console.log("User ID to send:", user?.id)
      console.log("Raw Workspace ID from URL:", rawWorkspaceId)
      console.log("Personal Workspace ID state:", personalWorkspaceId)
      console.log("Workspace Context to send:", workspaceContext)
      // ---> END DEBUG LOG <---

      // ---> ADDED AUTH CHECK <---
      const { data: authData, error: authError } =
        await supabase.auth.getSession()
      console.log("--- Auth Check Before Insert ---")
      console.log("Current Session:", authData?.session)
      console.log("Session User ID:", authData?.session?.user?.id)
      console.log("Auth Error:", authError)
      if (authError || !authData?.session) {
        console.error("CRITICAL: No valid session before insert!")
        // Optionally: Prevent the insert or show an error to the user
        // return;
      }
      // ---> END AUTH CHECK <---

      // ---> ADDED DIAGNOSTIC FUNCTION <---
      // This immediately runs when you click "Create Project" in the UI
      // It helps diagnose why the workspace membership check fails
      console.log("--- Running Diagnostic Function ---")
      const diagResult = await supabase.rpc("diagnose_workspace_membership", {
        p_user_id: user.id,
        p_workspace_id: workspaceContext
      })
      console.log("Diagnosis Result:", diagResult)
      // Explicit logging of the important diagnostic data
      console.log("MEMBERSHIP DATA:", JSON.stringify(diagResult.data, null, 2))
      if (diagResult.data) {
        console.log("User ID Input:", diagResult.data.user_id_input)
        console.log("Workspace ID Input:", diagResult.data.workspace_id_input)
        console.log("Membership Exists:", diagResult.data.membership_exists)
        console.log("Membership Count:", diagResult.data.membership_count)
        console.log("All User Workspaces:", diagResult.data.all_user_workspaces)
        console.log(
          "All Workspace Members:",
          diagResult.data.all_workspace_members
        )
      }
      // ---> END DIAGNOSTIC FUNCTION <---

      // Use the database function instead of direct table access
      // This bypasses RLS issues while maintaining security checks in the function
      const { data, error } = await supabase.rpc("create_project", {
        p_name: newProjectName,
        p_description: newProjectDescription,
        p_user_id: user.id,
        p_workspace_id: workspaceContext,
        p_color: "#4c4cff",
        p_status: "active"
      })

      if (error) throw error

      await loadProjects(user.id, workspaceContext)
      setShowProjectModal(false)
      setNewProjectName("")
      setNewProjectDescription("")
    } catch (err) {
      console.error("Error creating project:", err)
    } finally {
      setLoading(false)
    }
  }

  // Generate a chat name from the first user message
  const generateChatName = (message: string): string => {
    // Split the message into words
    const words = message.trim().split(/\s+/)

    // Get up to the first 3 words
    const firstThreeWords = words.slice(0, 3).join(" ")

    // If the result is too short, use "Neuer Chat"
    return firstThreeWords.length >= 3 ? firstThreeWords : "Neuer Chat"
  }

  // Modifiziere den useEffect f√ºr Task-Wechsel
  useEffect(() => {
    // Only perform task change operations if no message update is pending
    // And ensure at least 500ms has passed since the last message update
    const timeSinceLastUpdate = Date.now() - lastMessageUpdate
    if (messageUpdatePending || timeSinceLastUpdate < 500) {
      console.log(
        "Message update in progress or too recent, deferring task change handling"
      )
      return
    }

    const handleTaskOrModelChange = async () => {
      // Pr√ºfen, ob es sich um einen Task- oder Modellwechsel handelt
      const isTaskChange = selectedTask?.id !== previousSelectedTask?.id
      
      // When a task is selected, update the knowledge base selection
      if (isTaskChange && selectedTask) {
        // Set selected knowledge base IDs from task if available
        if (selectedTask.knowledge_base_ids) {
          setSelectedKnowledgeBaseId(selectedTask.knowledge_base_ids)
        } else {
          setSelectedKnowledgeBaseId(null)
        }
      }

      // Run this logic ONLY on task change, not on simple model selection
      if (isTaskChange && messages.length > 0) {
        // Wenn eine Task oder ein Modell gewechselt wurde und es Nachrichten gibt

        console.log("Task wurde gewechselt, erstelle Zusammenfassung...")

        try {
          // Pr√ºfe, ob bereits eine Zusammenfassung im Chat existiert
          const lastSummaryMessage = [...messages]
            .reverse()
            .find(
              msg =>
                msg.role === "assistant" &&
                (msg.content.includes("Chat-Zusammenfassung") ||
                  msg.content.includes("Hauptpunkte:") ||
                  msg.content.includes("Zusammenfassung des Chats"))
            )

          let summary: string

          if (lastSummaryMessage) {
            // Verwende die vorhandene Zusammenfassung
            console.log("Verwende vorhandene Zusammenfassung")
            summary = lastSummaryMessage.content
          } else {
            // Erstelle eine neue Zusammenfassung, da keine vorhanden ist
            console.log("√úberspringe Zusammenfassung f√ºr Task-Wechsel (DEBUG)")
            summary = "" // Tempor√§r deaktiviert
          }

          if (summary) {
            // Erstelle eine neue System-Nachricht mit der Zusammenfassung
            const summarySystemMessage: Message = {
              id: uuidv4(),
              role: "system",
              content: `Zusammenfassung des bisherigen Gespr√§chs: ${summary}

${selectedTask ? selectedTask.system_prompt : "Fahre mit dem Gespr√§ch fort, basierend auf dieser Zusammenfassung."}`,
              timestamp: new Date()
            }

            // Entferne alle bisherigen System-Nachrichten
            const filteredMessages = messages.filter(m => m.role !== "system")

            // F√ºge die neue System-Nachricht am Anfang hinzu
            setMessages([summarySystemMessage, ...filteredMessages])

            console.log(
              "Zusammenfassung wurde als System-Nachricht hinzugef√ºgt."
            )

            // Task-switching notification message is REMOVED
          }
        } catch (error) {
          console.error("Error in task change handling:", error)
        } finally {
          // Always set isTaskSwitching to false when complete
          setIsTaskSwitching(false)
        }
      } else {
        // If there's no task change or no messages, just reset the switching state
        setIsTaskSwitching(false)
      }

      // Aktuelle Task und Modell f√ºr den n√§chsten Vergleich speichern
      setPreviousSelectedTask(selectedTask)
      setPreviousSelectedModel(selectedModel)
    }

    handleTaskOrModelChange()
  }, [selectedTask, previousSelectedTask, messages.length, messageUpdatePending, lastMessageUpdate])

  // Add this function to sync messages with the database when needed
  const syncMessagesWithDatabase = async (chatId: string) => {
    if (!chatId) return

    try {
      console.log("Syncing messages with database for chat:", chatId)
      const { data, error } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (error) {
        console.error("Error syncing messages:", error)
        return
      }

      if (data) {
        // Convert database messages to app message format
        const formattedMessages: Message[] = data.map(dbMsg => ({
          id: dbMsg.id || uuidv4(),
          role: dbMsg.role as "user" | "assistant" | "system",
          content: dbMsg.content,
          timestamp: new Date(dbMsg.created_at)
        }))

        console.log(`Synced ${formattedMessages.length} messages from database`)
        setMessages(formattedMessages)
      }
    } catch (error) {
      console.error("Error in syncMessagesWithDatabase:", error)
    }
  }

  // Modify handleSendMessage to optionally include web search results
  const handleSendMessage = async (
    message: string,
    includeWebSearch: boolean = false
  ) => {
    if (message.trim().length === 0) return
    if (isTyping || messageUpdatePending || isTaskSwitching) return

    // Markieren, dass der Benutzer mit dem Tippen begonnen hat
    setHasStartedTyping(true)

    const userMessageId = uuidv4()
    const newMessage: Message = {
      id: userMessageId,
      role: "user",
      content: message,
      timestamp: new Date(),
      user_id: user?.id,
      sentfrom: userFullName
    }

    console.log("Creating new message with user_id:", user?.id)

    try {
      // Prevent task switching effects during message sending
      setMessageUpdatePending(true)
      setLastMessageUpdate(Date.now())

      // Create the new array *before* setting state
      const newMessagesArray = [...messages, newMessage]

      // Add user message to state immediately for better UX
      setMessages(newMessagesArray) // Use the new array
      setInputValue("") // Eingabefeld leeren

      // Show typing indicator
      setIsTyping(true)

      // If web search is requested, perform it before sending to API
      let webSearchResults = null
      if (includeWebSearch) {
        setIsSearching(true)
        try {
          webSearchResults = await performSerpApiSearch(message)
          console.log("Web search results:", webSearchResults.length)
        } catch (searchError) {
          console.error("Error during web search:", searchError)
        } finally {
          setIsSearching(false)
        }
      }

      let chatIdToUse = currentChatId

      // If no current chat exists, create a new one before proceeding
      if (!chatIdToUse) {
        console.log(
          "No current chat, creating new one before sending message..."
        )
        chatIdToUse = await createNewChat()
        if (!chatIdToUse) {
          throw new Error("Failed to create a new chat")
        }
        console.log(`Successfully created new chat with ID: ${chatIdToUse}`)
        // Set current chat ID immediately to ensure context is maintained
        setCurrentChatId(chatIdToUse)
      }

      // Speichern der Benutzernachricht in der Datenbank
      console.log(`Saving message to chat ID: ${chatIdToUse}`)

      // Wichtig: Wir ben√∂tigen diese Nachrichts-ID f√ºr Embedding
      let dbMessageId = null;

      try {
      const { data: messageData, error: messageError } = await retryOperation(
        async () => {
          return await supabase
            .from("chat_messages")
            .insert({
              chat_id: chatIdToUse,
              role: "user",
                content: message,
              user_id: user?.id,
              sentfrom: userFullName,
              created_at: newMessage.timestamp.toISOString()
            })
            .select()
        },
        3,
        1000
        );

      if (messageError) {
        console.error("‚ùå Error saving message:", messageError)
      } else {
        console.log("‚úÖ Message saved successfully to database", messageData)
          // Speichere die ID f√ºr sp√§tere Verwendung
        if (messageData && messageData.length > 0) {
            dbMessageId = messageData[0].id;
          }
        }
      } catch (saveError) {
        console.error("Error saving user message:", saveError);
        // Wir setzen den Prozess fort, auch wenn die Nachricht nicht gespeichert werden konnte
      }

      // Vorbereiten und Senden der Anfrage an die API
      try {
        const modelToUse = selectedTask?.ai_model || selectedModel
        console.log("üì£ Sende Nachricht an API mit Chat-ID:", chatIdToUse)
        console.log("üîÑ Ausgew√§hltes Modell f√ºr diese Anfrage:", modelToUse);

        // Streaming-Response
        const response = await sendMessageToAPI(
          newMessagesArray,
          modelToUse,
          chatIdToUse
        )

        // Assistentennachricht erstellen und anzeigen (vorerst leer)
        const assistantMessageId = uuidv4()
        const assistantMessage: Message = {
          id: assistantMessageId,
          role: "assistant",
          content: "", // Startinhalt ist leer, wird nach und nach gef√ºllt
          timestamp: new Date(),
          isTypewriting: true // Ensure this is set to true
        }

        // Sofort hinzuf√ºgen, um den Platzhalter anzuzeigen
        setMessages(prevMessages => [...prevMessages, assistantMessage])
        setTypingMessageId(assistantMessageId) // Make sure to set the typing message ID

        // Wenn Streaming-Antwort verf√ºgbar ist, nutze diese
        if (response.streamContent) {
          try {
            console.log("üé¨ Starte Streaming-Verarbeitung...");
            // Sammle Nachrichteninhalt w√§hrend des Streamings
            let collectedContent = "";
            
            // Hole den Generator f√ºr die Stream-Verarbeitung
            const contentGenerator = response.streamContent();
            
            // Schreibe die assistantMessageId in eine konstante Variable
            // f√ºr die asynchronen Funktionen
            const messageIdToUpdate = assistantMessageId;
            
            // Verarbeite jeden Chunk aus dem Stream
            for await (const chunk of contentGenerator) {
              // Try to process chunk if it's JSON
              let processedChunk = chunk;
              let shouldApplyEffect = false;
              
              try {
                if (chunk.trim().startsWith('{') && chunk.trim().endsWith('}')) {
                  const jsonChunk = JSON.parse(chunk);
                  if (jsonChunk && typeof jsonChunk.content === 'string') {
                    processedChunk = jsonChunk.content;
                    // Check for the effect flag in the JSON
                    shouldApplyEffect = !!jsonChunk.applyEffect;
                  } else if (jsonChunk && jsonChunk.type === 'content' && typeof jsonChunk.content === 'string') {
                    processedChunk = jsonChunk.content;
                    shouldApplyEffect = !!jsonChunk.applyEffect;
                  }
                }
              } catch (e) {
                // Use original chunk if JSON parsing fails
                processedChunk = chunk;
              }
              
              collectedContent += processedChunk;
              
              // Aktualisiere die Nachricht in der UI mit jedem Chunk
              setMessages(prevMessages => 
                prevMessages.map(msg => 
                  msg.id === messageIdToUpdate 
                    ? { 
                        ...msg, 
                        content: collectedContent, 
                        isTypewriting: true // Always ensure typing effect during streaming
                      }
                    : msg
                )
              );
            }
            
            // Nach Ende des Streams: endg√ºltigen Inhalt speichern
            assistantMessage.content = collectedContent || response.content;
            
            // Aktualisiere mit dem endg√ºltigen Inhalt f√ºr den Fall von Metadaten
            setMessages(prevMessages => 
              prevMessages.map(msg => 
                msg.id === messageIdToUpdate 
                  ? { 
                      ...msg, 
                      content: assistantMessage.content,
                      isTypewriting: true // Keep typewriting effect active
                    }
                  : msg
              )
            );
            
            // Log message length to help with debugging
            const messageLength = assistantMessage.content.length;
            console.log(`‚úÖ Streaming abgeschlossen, Gesamtl√§nge: ${messageLength} Zeichen`);
            
            // For very long messages, add a dynamic buffer delay before animations can complete
            if (messageLength > 5000) {
              console.log("Sehr lange Nachricht erkannt, stellen sicher dass Animation vollst√§ndig abl√§uft");
            }
          } catch (streamingError) {
            console.error("‚ùå Fehler bei der Stream-Verarbeitung:", streamingError);
            // Fallback: Verwende das content-Feld, wenn verf√ºgbar
            if (response.content) {
              assistantMessage.content = response.content;
              setMessages(prevMessages => 
                prevMessages.map(msg => 
                  msg.id === assistantMessageId 
                    ? { ...msg, content: response.content }
                    : msg
                )
              );
            }
          }
        } else {
          // Fallback f√ºr nicht-Streaming-Antworten
          assistantMessage.content = response.content;
          setMessages(prevMessages => 
            prevMessages.map(msg => 
              msg.id === assistantMessageId 
                ? { ...msg, content: response.content }
                : msg
            )
          );
        }

        // Speichern der Assistentennachricht in der Datenbank
        let dbAssistantId = null;
        try {
          const { data: assistantData, error: assistantError } = await supabase
            .from("chat_messages")
            .insert({
              chat_id: chatIdToUse,
              role: "assistant",
              content: assistantMessage.content,
              created_at: assistantMessage.timestamp.toISOString()
            })
            .select();

          if (assistantError) {
            console.error("‚ùå Error saving assistant message:", assistantError)
          } else {
            console.log("‚úÖ AI message saved to database", assistantData)
            if (assistantData && assistantData.length > 0) {
              dbAssistantId = assistantData[0].id;
            }
          }
        } catch (saveError) {
          console.error("Error saving assistant message:", saveError);
        }

        // Nach erfolgreicher Kommunikation, starte asynchrone Aufgaben
        // Embedding f√ºr Benutzernachricht
        if (dbMessageId) {
          const dbMessage = { ...newMessage, id: dbMessageId };
          const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
          createEmbedding(dbMessage, chatIdToUse, workspaceIdToUse)
            .catch(err => console.error("User embedding failed:", err));
        }

        // Embedding f√ºr Assistentennachricht
        if (dbAssistantId) {
          const dbAssistantMessage = { ...assistantMessage, id: dbAssistantId };
          const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
          createEmbedding(dbAssistantMessage, chatIdToUse, workspaceIdToUse)
            .catch(err => console.error("Assistant embedding failed:", err));
        }

        // Titelgenerierung f√ºr neue Chats
        if (!currentChatId && chatIdToUse) {
          generateAndSetChatTitle(chatIdToUse, message)
            .catch(err => console.error("Title generation failed:", err));
        }

        // Chat-Liste aktualisieren
        if (user) {
          loadChatSessions(user.id, rawWorkspaceId || null)
            .catch(err => console.error("Chat session loading failed:", err));
        }
      } catch (apiError) {
        console.error("Error getting AI response:", apiError)
        setIsTyping(false)

        // Fehlermeldung hinzuf√ºgen
        const errorMessageId = uuidv4()
        const errorMessage: Message = {
          id: errorMessageId,
          role: "assistant",
          content: "Die Verbindung zum AI-Service konnte nicht hergestellt werden. Bitte versuche es sp√§ter noch einmal.",
          timestamp: new Date()
        }
        setMessages(prevMessages => [...prevMessages, errorMessage])
      } finally {
        // In jedem Fall Typing-Status zur√ºcksetzen
        setIsTyping(false)
        setMessageUpdatePending(false)
      }
    } catch (error) {
      console.error("Error in handleSendMessage:", error)
      setIsTyping(false)
      setMessageUpdatePending(false)
    }
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    handleSendMessage(inputValue)
  }

  const getModelLabel = (modelId: string | null): string => {
    // Map actual model IDs back to friendly names
    switch (modelId) {
      // Direkte Namen (keine Umwandlung n√∂tig)
      case "Basic":
        return "Basic"
      case "Fast":
        return "Fast"
      case "Reason":
        return "Reason"
      case "Reason+":
        return "Reason+"

      // Alte technische IDs f√ºr Abw√§rtskompatibilit√§t
      case "gpt-4o-2024-11-20":
        return "Basic"
      case "gpt-4o-mini-2024-07-18":
        return "Fast"
      case "o3-mini-2025-01-31":
        return "Reason"
      case "gpt-4.5-preview-2025-02-27":
        return "Reason+"

      // Sehr alte IDs f√ºr Abw√§rtskompatibilit√§t
      case "gpt-4o":
        return "Basic"
      case "gpt-4o-mini":
        return "Fast"
      case "gpt-4-vision-preview":
        return "Reason"
      default:
        // Standardwert
        return modelId || "Basic"
    }
  }

  // Function to copy message content to clipboard
  const copyToClipboard = (text: string) => {
    navigator.clipboard
      .writeText(text)
      .then(() => {
        // Could show a toast notification here
        console.log("Copied to clipboard")
      })
      .catch(err => {
        console.error("Failed to copy: ", err)
      })
  }

  // Function to start editing a user message
  const startEditMessage = (message: Message) => {
    // Save the current state of all messages for potential restoration
    setOriginalMessages([...messages]);
    
    // Find the index of the message to edit
    const messageIndex = messages.findIndex(m => m.id === message.id);
    if (messageIndex === -1) return;
    
    // Keep only messages up to and including the one being edited
    const visibleMessages = messages.slice(0, messageIndex + 1);
    setMessages(visibleMessages);
    
    // Set editing state
    setEditingMessageId(message.id);
    setEditingContent(message.content);
  }

  // Function to cancel editing
  const cancelEditMessage = () => {
    // Restore messages to their original state
    if (originalMessages.length > 0) {
      setMessages(originalMessages);
    }
    
    // Reset editing state
    setEditingMessageId(null);
    setEditingContent("");
    setOriginalMessages([]);
  }

  // Add this helper function to track processed messages
  const processedMessageIds = new Set<string>();

  // Add the saveAssistantMessage helper function before the handleSaveEdit function
  const saveAssistantMessage = async (assistantMessage: Message, chatId: string) => {
    try {
      debugLog("Saving AI response for chat:", chatId);
      
      // Get current date in YYYY-MM-DD format
      const currentDate = new Date().toISOString().split("T")[0];
      
      // Store date directly in content field but in a way that can be filtered out in UI
      const contentWithDate = `[Datum: ${currentDate}]\n${assistantMessage.content}`;
      
      const { error: aiInsertError, data: aiInsertData } = await supabase
          .from("chat_messages")
        .insert({
          id: assistantMessage.id, // Use specific ID to help with deduplication
          chat_id: chatId,
          role: "assistant",
          // Store content with date prefix - we'll strip it when displaying
          content: contentWithDate,
          user_id: null, // AI responses don't have a user ID
          created_at: new Date().toISOString()
        })
        .select();

      if (aiInsertError) {
        console.error("Error saving AI response:", aiInsertError);
        return false;
      }
      
      debugLog("AI response saved successfully:", aiInsertData);
      return true;
    } catch (aiInsertErr) {
      console.error("Error during AI message insertion:", aiInsertErr);
      return false;
    }
  };

  // Function to handle saving edited messages
  const handleSaveEdit = async () => {
    if (!editingMessageId || !editingContent.trim()) return;

    try {
      // Use a copy of original messages to work with
      const originalMessagesCopy = [...originalMessages];
      const messageIndex = originalMessagesCopy.findIndex(m => m.id === editingMessageId);

      if (messageIndex === -1) {
        console.error("Message to edit not found in original messages");
        return;
      }

      const messageToEdit = originalMessagesCopy[messageIndex]; // Get the original message object

      // Create the updated message object
      const updatedMessage = {
        ...messageToEdit,
        content: editingContent,
        timestamp: new Date() // Use new timestamp for the edited message
      };

      // Determine if AI messages after the edited one need removal
      const hasAssistantMessagesAfter = originalMessagesCopy
        .slice(messageIndex + 1)
        .some(m => m.role === "assistant");

      // Prepare the new messages array for the UI
      let newMessagesForUI;
      
      if (hasAssistantMessagesAfter) {
        // Keep messages before the edited one, then add the updated message
        newMessagesForUI = [
          ...originalMessagesCopy.slice(0, messageIndex),
          updatedMessage
        ];
      } else {
        // Create a new array excluding the original, then add the updated one
        newMessagesForUI = [
            ...originalMessagesCopy.filter(msg => msg.id !== editingMessageId),
            updatedMessage
        ];
      }

      // Update UI state *before* database operations
      setMessages(newMessagesForUI);

      // Reset editing state immediately after UI update
      const savedEditingMessageId = editingMessageId; // Save for DB ops
      setEditingMessageId(null);
      setEditingContent("");
      setOriginalMessages([]); // Clear the saved original state

      // Database Operations: Delete original, Insert new
      if (currentChatId) {
        try {
          // 1. Delete subsequent AI messages if necessary
          if (hasAssistantMessagesAfter) {
            console.log("DB: Deleting subsequent AI messages after", messageToEdit.timestamp.toISOString());
            const { error: deleteSubsequentError } = await supabase
              .from("chat_messages")
              .delete()
              .eq("chat_id", currentChatId)
              .gt("created_at", messageToEdit.timestamp.toISOString()); // Match based on original timestamp
            if (deleteSubsequentError) console.error("DB: Error deleting subsequent messages:", deleteSubsequentError);
            else console.log("DB: Subsequent AI messages deleted.");
          }

          // 2. Delete the *original* message from the database
          console.log(`DB: Deleting original message (created at ${messageToEdit.timestamp.toISOString()})`);
          const { error: deleteOriginalError } = await supabase
            .from("chat_messages")
            .delete()
            .eq("chat_id", currentChatId)
            .eq("created_at", messageToEdit.timestamp.toISOString()); // Match original by timestamp
          
          if (deleteOriginalError) {
            console.error("DB: Error deleting original message:", deleteOriginalError);
            // Consider handling this error more gracefully, maybe revert UI?
          } else {
            console.log("DB: Original message deleted successfully.");

            // 3. Insert the *new* edited message
            console.log("DB: Inserting edited message");
            const { data: insertData, error: insertError } = await supabase
              .from("chat_messages")
              .insert({
                chat_id: currentChatId,
                role: updatedMessage.role,
                content: updatedMessage.content,
                user_id: updatedMessage.user_id,
                sentfrom: updatedMessage.sentfrom,
                created_at: updatedMessage.timestamp.toISOString() // Use the new timestamp
              })
              .select(); // Select the inserted row to get its DB ID if needed
            
            if (insertError) {
              console.error("DB: Error inserting edited message:", insertError);
              // Consider reverting UI or showing error
            } else {
              console.log("DB: Edited message inserted successfully.");
              const insertedDbMessageId = insertData?.[0]?.id; // Get DB ID if available
              
              // Create embedding for the newly inserted edited message
              if (insertedDbMessageId) {
                // We need the full Message object with the DB ID for embedding potentially
                 const embeddingMessage = { ...updatedMessage, id: insertedDbMessageId }; // Use DB id if needed by embedding
                 const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
                 createEmbedding(embeddingMessage, currentChatId, workspaceIdToUse)
                  .catch(err => console.error("Edited message embedding failed:", err));
              }

              // 4. Regenerate AI response if necessary (only after successful insert)
              if (hasAssistantMessagesAfter) {
                console.log("Regenerating AI response after edit...");
                setIsTyping(true); // Show typing indicator for regeneration
                setMessageUpdatePending(true); // Prevent other actions during regen
                try {
                    const modelToUse = selectedTask?.ai_model || selectedModel
                    const response = await sendMessageToAPI(
                        newMessagesForUI, // Use the corrected message list for the API
                        modelToUse,
                        currentChatId
                    );

                    // Handle streaming response for the regenerated message
                    const assistantMessageId = uuidv4();
                    const assistantMessage: Message = {
                        id: assistantMessageId,
                        role: "assistant",
                        content: "",
                        timestamp: new Date(),
                        isTypewriting: true
                    };
                    
                    setMessages(prev => [...prev, assistantMessage]);
                    setTypingMessageId(assistantMessageId);

                    if (response.streamContent) {
                      let collectedContent = "";
                      const contentGenerator = response.streamContent();
                      const messageIdToUpdate = assistantMessageId;
                      
                      for await (const chunk of contentGenerator) {
                        let processedChunk = chunk;
                        try {
                          if (chunk.trim().startsWith('{') && chunk.trim().endsWith('}')) {
                            const jsonChunk = JSON.parse(chunk);
                            if (jsonChunk && typeof jsonChunk.content === 'string') {
                              processedChunk = jsonChunk.content;
                            }
                          }
                        } catch (e) { /* Ignore parsing errors, use chunk */ }
                        
                        collectedContent += processedChunk;
                        setMessages(prev => prev.map(msg => msg.id === messageIdToUpdate ? { ...msg, content: collectedContent, isTypewriting: true } : msg));
                      }
                      assistantMessage.content = collectedContent || response.content;
                       setMessages(prev => prev.map(msg => msg.id === messageIdToUpdate ? { ...msg, content: assistantMessage.content } : msg)); // Final update
                      
                    } else {
                       assistantMessage.content = response.content;
                       setMessages(prev => prev.map(msg => msg.id === assistantMessageId ? { ...msg, content: assistantMessage.content } : msg)); // Use assistantMessageId here
                    }
                    
                   // Save regenerated AI message to DB & create embedding
                    let dbAssistantId = null;
                    try {
                      const { data: assistantData, error: assistantError } = await supabase
                        .from("chat_messages")
                        .insert({
                          chat_id: currentChatId,
                          role: "assistant",
                          content: assistantMessage.content,
                          created_at: assistantMessage.timestamp.toISOString()
                        })
                        .select();

                      if (assistantError) console.error("‚ùå Error saving regenerated assistant message:", assistantError)
                      else {
                         console.log("‚úÖ Regenerated AI message saved to database", assistantData)
                         dbAssistantId = assistantData?.[0]?.id;
                         if (dbAssistantId) {
                             const dbAssistantMessage = { ...assistantMessage, id: dbAssistantId };
                             const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
                             createEmbedding(dbAssistantMessage, currentChatId, workspaceIdToUse)
                               .catch(err => console.error("Regenerated assistant embedding failed:", err));
                         }
                      }
                    } catch (saveError) { console.error("Error saving regenerated assistant message:", saveError); }

                } catch (regenError) {
                    console.error("Error regenerating AI response:", regenError);
                    // Add error message to UI?
                } finally {
                    setIsTyping(false);
                    setMessageUpdatePending(false);
                    // Reset typing state for all messages
                    setTypingMessageId(null);
                    setMessages(prevMessages => 
                      prevMessages.map(msg => ({ ...msg, isTypewriting: false }))
                    );
                }
              }
            }
          }
        } catch (dbError) {
          console.error("DB: Operation failed:", dbError);
        }
      }
    } catch (err) {
      console.error("Error in handleSaveEdit:", err);
      // Ensure UI state is reset even if there's an error
       if (editingMessageId) {
          cancelEditMessage(); // Attempt to restore original state if possible
       }
    }
  };

  // Updated function to regenerate AI response
  const regenerateResponse = async (aiMessageId: string) => {
    setTypingMessageId(null)

    const aiMessageIndex = messages.findIndex(m => m.id === aiMessageId)
    if (aiMessageIndex === -1 || aiMessageIndex === 0) return // Cannot regenerate if it's the first message or not found

    const userMessageIndex = aiMessageIndex - 1
    if (messages[userMessageIndex].role !== "user") return // Should be preceded by a user message

    const userMessageToResend = messages[userMessageIndex]

    // Keep messages up to the preceding user message
    const messagesToKeep = messages.slice(0, userMessageIndex + 1)

    // Update UI state
    setMessages(messagesToKeep)

    // Delete the AI message and subsequent ones from DB
    if (currentChatId) {
      supabase
        .from("chat_messages")
        .delete()
        .eq("chat_id", currentChatId)
        .gte("created_at", messages[aiMessageIndex].timestamp.toISOString())
        .then(({ error }) => {
          if (error) {
            console.error("Error deleting messages for regeneration:", error)
          } else {
            console.log("Messages deleted for regeneration from DB")
          }
        })
    }

    // Resend the user message that led to this AI response
    await handleSendMessage(userMessageToResend.content)
  }

  // Add another function to retry failed database operations with logging
  const retryOperation = async (
    operation: () => Promise<any>,
    maxRetries = 3,
    delay = 500
  ) => {
    let lastError
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation()
      } catch (err) {
        lastError = err
        console.error(
          `Operation failed (attempt ${attempt}/${maxRetries}):`,
          err
        )

        if (attempt < maxRetries) {
          console.log(`Retrying in ${delay}ms...`)
          await new Promise(resolve => setTimeout(resolve, delay))
          delay *= 2 // Exponential backoff
        }
      }
    }
    throw lastError
  }

  // Simplified deleteChat function that works with the consolidated database structure
  const deleteChat = async (chatId: string) => {
    try {
      // Close any open menus
      setChatMenuOpen(null)

      console.log("Starting delete process for chat:", chatId)

      // With the ON DELETE CASCADE constraint, we only need to delete the chat
      // All associated messages will be automatically deleted
      const { error } = await supabase
        .from("chats")
        .delete()
        .eq("id", chatId)
        .eq("user_id", user.id)

      if (error) {
        console.error("Error deleting chat:", error)
        return
      }

      console.log("Chat and all associated messages deleted successfully")

      // Remove from state
      setChatSessions(prevSessions =>
        prevSessions.filter(chat => chat.id !== chatId)
      )

      // If the deleted chat was the current one, load another chat
      if (currentChatId === chatId) {
        // Get a fresh list of remaining chats after removing the deleted one
        const remainingChats = [...chatSessions].filter(
          chat => chat.id !== chatId
        )

        if (remainingChats.length > 0) {
          const nextChatId = remainingChats[0].id
          console.log("Switching to next chat:", nextChatId)
          setCurrentChatId(nextChatId)
        } else {
          console.log("No chats remaining, clearing state")
          setCurrentChatId(null)
          setMessages([])
        }
      }

      // Reload chats from database to ensure we have fresh data
      await loadChatSessions(user.id, rawWorkspaceId || null)

      console.log("Chat successfully deleted:", chatId)
    } catch (err) {
      console.error("Error in deleteChat:", err)
    }
  }

  // Add function to open rename modal
  const openRenameModal = (chat: ChatSession) => {
    setChatToRename(chat)
    setNewChatName(chat.name)
    setRenameModalOpen(true)
    setChatMenuOpen(null)
  }

  // Start inline edit for a chat
  const startInlineEdit = (chat: ChatSession, e: React.MouseEvent) => {
    e.stopPropagation() // Verhindere Bubble-Up zum Button
    setEditingChatId(chat.id)
    setNewChatName(chat.name)
    setChatMenuOpen(null)
  }

  // Handle focus loss on inline edit
  const handleInlineEditBlur = async () => {
    if (editingChatId && newChatName.trim()) {
      // Finde den Chat
      const chatToUpdate = chatSessions.find(chat => chat.id === editingChatId)
      if (chatToUpdate) {
        try {
          // Update in DB
          const { error } = await supabase
            .from("chats")
            .update({ name: newChatName })
            .eq("id", editingChatId)
            .eq("user_id", user.id)

          if (error) {
            console.error("Error renaming chat:", error)
          } else {
            // Update local state
            setChatSessions(prevSessions =>
              prevSessions.map(chat =>
                chat.id === editingChatId
                  ? { ...chat, name: newChatName }
                  : chat
              )
            )
          }
        } catch (err) {
          console.error("Error in inline chat rename:", err)
        }
      }
    }
    // Reset edit state
    setEditingChatId(null)
    setNewChatName("")
  }

  // Submit inline edit with enter key
  const handleInlineEditKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault()
      handleInlineEditBlur()
    } else if (e.key === "Escape") {
      e.preventDefault()
      setEditingChatId(null)
      setNewChatName("")
    }
  }

  // Simplified function to handle chat renaming
  const handleRenameChat = async () => {
    if (!chatToRename || !newChatName.trim()) return

    try {
      const { error } = await supabase
        .from("chats")
        .update({ name: newChatName })
        .eq("id", chatToRename.id)
        .eq("user_id", user.id)

      if (error) {
        console.error("Error renaming chat:", error)
        return
      }

      console.log("Chat renamed successfully")

      // Update in state
      setChatSessions(prevSessions =>
        prevSessions.map(chat =>
          chat.id === chatToRename.id ? { ...chat, name: newChatName } : chat
        )
      )

      // Close modal
      setRenameModalOpen(false)
      setChatToRename(null)
      setNewChatName("")

      // Reload chats to ensure state is in sync
      await loadChatSessions(user.id, rawWorkspaceId || null)
    } catch (err) {
      console.error("Error in handleRenameChat:", err)
    }
  }

  const deleteProject = async (projectId: string) => {
    try {
      setError(null)
      setProjectMenuOpen(null)

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null

      // --- BERECHTIGUNGSPR√úFUNG ---
      // Diese Pr√ºfung schl√§gt aktuell fehl (PGRST116) und muss behoben werden!
      const { data: memberData, error: memberError } = await supabase
        .from("workspace_members")
        .select("role")
        .eq("workspace_id", workspaceContext)
        .eq("user_id", user.id)
        .single() // <- Findet 0 Zeilen!

      if (memberError) {
        console.error("Fehler beim Pr√ºfen der Berechtigung:", memberError)
        // Zeige den Fehler an, aber kehre *noch nicht* zur√ºck,
        // damit der Rest der Funktion f√ºr den Fall ausgef√ºhrt wird, dass die Pr√ºfung *korrekt* w√§re.
        // In der finalen Version sollte hier ein `return` stehen.
        setError(`Berechtigungsfehler: ${memberError.message}`)
        return // <-- Wichtig: Reaktiviert!
      } else if (!memberData || !["admin", "owner"].includes(memberData.role)) {
        setError(
          "Nur Workspace-Administratoren oder Eigent√ºmer k√∂nnen Projekte l√∂schen."
        )
        return // Hier ist der Return OK.
      }
      // --- ENDE BERECHTIGUNGSPR√úFUNG ---

      if (
        !confirm(
          `Projekt "${projects.find(p => p.id === projectId)?.name}" wirklich l√∂schen?`
        )
      ) {
        return
      }

      // L√∂sche das Projekt
      const { error: deleteError } = await supabase
        .from("projects")
        .delete()
        .eq("id", projectId)

      if (deleteError) {
        console.error("Error deleting project:", deleteError)
        setError(`Fehler beim L√∂schen des Projekts: ${deleteError.message}`)
        return // Beende bei L√∂schfehler
      }

      console.log("‚úÖ Projekt erfolgreich gel√∂scht. Lade Daten neu...")

      // --- DATEN NEU LADEN statt lokalen State zu patchen ---
      setLoading(true) // Ladeindikator anzeigen
      try {
        // Lade Projekte und Chats neu
        if (user) {
          await loadProjects(user.id, workspaceContext)
          await loadChatSessions(user.id, workspaceContext)
        }

        // Setze abh√§ngige Zust√§nde zur√ºck
        if (selectedProject?.id === projectId) {
          setSelectedProject(null)
        }
        // Finde Chats, die zu diesem Projekt geh√∂ren (basierend auf dem *alten* State vor dem Reload)
        const chatsInProjectToDelete = chatSessions.filter(
          chat => chat.project_id === projectId
        )
        if (
          editingChatId &&
          chatsInProjectToDelete.some(chat => chat.id === editingChatId)
        ) {
          setEditingChatId(null)
          setNewChatName("")
        }
        // expandedProjects muss nicht manuell bereinigt werden, da es von 'projects' abh√§ngt
      } catch (reloadError) {
        console.error(
          "Fehler beim Neuladen der Daten nach Projektl√∂schung:",
          reloadError
        )
        setError(
          "Projekt gel√∂scht, aber Fehler beim Aktualisieren der Ansicht."
        )
      } finally {
        setLoading(false)
      }
    } catch (err) {
      // Dieser Catch ist jetzt haupts√§chlich f√ºr unerwartete Fehler
      console.error("Unexpected error in deleteProject:", err)
      setError("Ein unerwarteter Fehler ist aufgetreten.")
    }
  }

  const updateProject = async () => {
    if (!projectToRename || !newProjectName.trim()) return

    try {
      setLoading(true)

      const { data, error } = await supabase
        .from("projects")
        .update({
          name: newProjectName,
          description: newProjectDescription,
          updated_at: new Date().toISOString()
        })
        .eq("id", projectToRename.id)
        .select()

      if (error) throw error

      // Aktualisiere Projektliste
      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
      await loadProjects(user.id, workspaceContext)

      // Wenn das bearbeitete Projekt ausgew√§hlt war, aktualisiere die Auswahl
      if (selectedProject?.id === projectToRename.id && data?.[0]) {
        setSelectedProject(data[0])
      }

      // Modal schlie√üen
      setShowProjectModal(false)
      setProjectToRename(null)
      setNewProjectName("")
      setNewProjectDescription("")
    } catch (err) {
      console.error("Error updating project:", err)
    } finally {
      setLoading(false)
    }
  }

  // Chat einem Projekt zuweisen
  const assignChatToProject = async (
    chatId: string,
    projectId: string | null
  ) => {
    try {
      console.log(
        `Zuweisen von Chat ${chatId} zu Projekt ${projectId || "none"}`
      )

      // Update in der Datenbank
      const { error } = await supabase
        .from("chats")
        .update({
          project_id: projectId,
          // Auch last_message_timestamp aktualisieren, damit die Sortierung korrekt bleibt
          last_message_timestamp: new Date().toISOString()
        })
        .eq("id", chatId)

      if (error) throw error

      // Update im lokalen State
      setChatSessions(prev =>
        prev.map(chat =>
          chat.id === chatId ? { ...chat, project_id: projectId } : chat
        )
      )

      // Lade Chats neu, um sicherzustellen, dass die UI korrekt aktualisiert wird
      if (user) {
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
        // Verz√∂gerung einbauen, damit die Datenbank Zeit hat, die √Ñnderung zu verarbeiten
        setTimeout(async () => {
          await loadChatSessions(user.id, workspaceContext)
        }, 300)
      }

      console.log(
        `Chat ${chatId} wurde ${projectId ? `Projekt ${projectId}` : "keinem Projekt"} zugewiesen`
      )
    } catch (err) {
      console.error("Fehler beim Zuweisen des Chats:", err)
      setError("Fehler beim Zuweisen des Chats zu einem Projekt")
    }
  }

  // Erg√§nze die Message-Komponente
  const Message = ({
    message,
    isTyping
  }: {
    message: Message
    isTyping?: boolean
  }) => {
    // Format code in message content
    const formatCodeInMessage = (content: string): string => {
      return content
        .replace(
          /```(\w+)?\s([\s\S]*?)```/g,
          (_, language, code) =>
            `<pre><code class="${language || ""}">${code}</code></pre>`
        )
        .replace(/`([^`]+)`/g, "<code>$1</code>")
    }

    // Format message content using MessageMarkdown component
    const formattedContent = message.content

    return (
      <div
        className={`w-full fade-check-parent ${
          message.role === "user" ? "bg-[#1e1e1e]" : "bg-transparent"
        }`}
      >
        <div
          className={`max-w-3xl mx-auto px-4 py-4 relative message-container ${
            message.role === "user" ? "user-message" : "assistant-message"
          }`}
        >
          <div className="flex items-start space-x-4">
            <div className="w-8 h-8 rounded-full flex items-center justify-center shrink-0">
              {message.role === "user" ? (
                // User Avatar (Initials)
                <div className="w-full h-full bg-gray-700 rounded-full flex items-center justify-center text-white">
                  {message.sentfrom ? message.sentfrom.charAt(0).toUpperCase() : "U"}
                </div>
              ) : (
                // Bot Avatar
                <div className="w-full h-full bg-blue-600 rounded-full flex items-center justify-center text-white">
                  <Sparkles size={16} />
                </div>
              )}
            </div>

            <div className="flex-1 space-y-2 overflow-hidden">
              {/* Sender Name */}
              <div className="text-sm font-medium">
                {message.role === "user" ? (message.sentfrom || "Du") : "KI-Assistent"}
                {message.role === "assistant" && (
                  <span className="text-xs text-gray-400 ml-2">{selectedModel}</span>
                )}
              </div>

              {/* Message Content */}
              <div className="message-content prose prose-invert max-w-none">
                {isTyping ? (
                  <TypewriterEffect
                    content={formattedContent}
                    speed={20}
                    onComplete={() => handleTypewriterComplete(message.id)}
                  />
                ) : (
                  <div className="message-fade-container">
                    <MessageMarkdown content={formattedContent} />
                  </div>
                )}
              </div>

              {/* Message Actions */}
              {message.role === "assistant" && !isTyping && (
                <div className="flex mt-2 space-x-2 message-actions opacity-0 transition-opacity group-hover:opacity-100">
                  <button
                    onClick={() => copyToClipboard(message.content)}
                    className="p-1 text-gray-400 hover:text-white"
                    aria-label="Copy to clipboard"
                  >
                    <Copy size={14} />
                  </button>
                  <button
                    onClick={() => regenerateResponse(message.id)}
                    className="p-1 text-gray-400 hover:text-white"
                    aria-label="Regenerate response"
                  >
                    <RotateCcw size={14} />
                  </button>
                  <button
                    onClick={() => startEditMessage(message)}
                    className="p-1 text-gray-400 hover:text-white"
                    aria-label="Edit message"
                  >
                    <Edit size={14} />
                  </button>
                </div>
              )}
            </div>
          </div>
        </div>
      </div>
    )
  }

  // Add this new useEffect to listen for changes to personalWorkspaceId
  useEffect(() => {
    // Skip if no personal workspace or if we already have chat sessions
    if (!personalWorkspaceId || initialChatsLoadedRef.current || !user) {
      return;
    }
    
    console.log("Personal workspace ID available, loading initial data:", personalWorkspaceId);
    
    // Mark as loaded to prevent multiple executions
    initialChatsLoadedRef.current = true;
    
    const loadInitialData = async () => {
      try {
        // Use the direct query approach to ensure we get the latest data
        let query = supabase
          .from("chats")
          .select(
            "id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id"
          )
          .eq("workspace_id", personalWorkspaceId)
          .order("last_message_timestamp", { ascending: false });

        const { data, error } = await query;

        if (error) {
          console.error("Error loading initial chats:", error);
          return;
        }

        if (data && data.length > 0) {
          console.log("Found existing chats:", data.length);
          const formattedSessions = data.map((chat: any) => ({
            id: chat.id || "",
            name: chat.name || "Unnamed Chat",
            created_at: chat.created_at || new Date().toISOString(),
            project_id: chat.project_id,
            user_id: chat.user_id,
            last_message_timestamp: chat.last_message_timestamp,
            ...(chat.description && { description: chat.description })
          }));

          setChatSessions(formattedSessions);

          // Set current chat if not already set
          if (!currentChatId) {
            console.log("Setting current chat to:", data[0].id);
            setCurrentChatId(data[0].id);
            await loadChat(data[0].id);
          }
        } else {
          console.log("No chats found for personal workspace, will create one on first message");
        }
      } catch (err) {
        console.error("Error in loadInitialData:", err);
      }
    };

    loadInitialData();
  }, [personalWorkspaceId, user, supabase]); // Removed currentChatId and chatSessions dependencies

  // Funktion zum Generieren und Setzen des Chat-Titels via AI
  const generateAndSetChatTitle = async (
    chatId: string,
    firstUserMessage: string
  ) => {
    console.log(
      `‚ú® Generating title for chat ${chatId} based on: "${firstUserMessage}"`
    )
    try {
      // NEUE DIREKTE IMPLEMENTATION:
      // Statt sendMessageToAPI zu nutzen, machen wir den API Call direkt hier
      // um Fehler durch komplexe State-Handling-Logic in sendMessageToAPI zu vermeiden

      const prompt = `Analysiere die folgende Benutzernachricht und generiere einen kurzen, pr√§gnanten Titel (maximal 4 W√∂rter) f√ºr diesen Chat. Gib NUR den Titel zur√ºck, ohne Anf√ºhrungszeichen oder zus√§tzliche Erkl√§rungen:\n\nNachricht: "${firstUserMessage}"\n\nTitel:`

      // Direkte Anfrage an unsere API-Route
      const response = await fetch("/api/chat", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [{ role: "user", content: prompt }],
          model: "Fast", // Schnelles Modell verwenden
          stream: false // Wichtig: kein Streaming, damit wir direkt die Antwort bekommen
        })
      })

      if (!response.ok) {
        throw new Error(`API request failed: ${response.status}`)
      }

      // Als Text behandeln, nicht als JSON
      const generatedTitle = await response.text();
      console.log(`üëã API raw text response for title generation:`, generatedTitle);

      if (generatedTitle) {
        // Bereinige den Titel
        let cleanTitle = generatedTitle
          .replace(/^["']|["']$/g, "") // Entferne Anf√ºhrungszeichen am Anfang und Ende
          .replace(/^#\s+/gm, "") // Entferne Markdown-√úberschriften
          .trim(); // Entferne Leerzeichen
        
        console.log(`‚ú® AI generated title (cleaned): "${cleanTitle}"`);

        // Kurzen Fallback, falls Titel leer wird
        if (!cleanTitle || cleanTitle.length === 0) {
          cleanTitle = generateChatName(firstUserMessage); // Fallback zur alten Methode
          console.log(
            `‚ú® AI title was empty, using fallback: "${cleanTitle}"`
          );
        }

        // Begrenze Titel auf maximal 50 Zeichen
        if (cleanTitle.length > 50) {
          cleanTitle = cleanTitle.substring(0, 47) + "...";
        }

        // Update Datenbank
        const { error: updateError } = await supabase
          .from("chats")
          .update({ name: cleanTitle })
          .eq("id", chatId);

        if (updateError) {
          console.error("‚ùå Error updating chat name in DB:", updateError);
        } else {
          console.log(
            `‚úÖ Chat ${chatId} name updated in DB to: "${cleanTitle}"`
          );
          // Update UI State
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: cleanTitle } : chat
            )
          );
        }
      } else {
        console.warn("‚ö†Ô∏è AI did not return a valid title.");
        // Optional: Fallback zur alten Methode, wenn AI versagt
        const fallbackTitle = generateChatName(firstUserMessage);
        const { error: updateError } = await supabase
          .from("chats")
          .update({ name: fallbackTitle })
          .eq("id", chatId);
        if (!updateError) {
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: fallbackTitle } : chat
            )
          );
        }
      }
    } catch (error) {
      console.error("‚ùå Error generating or setting chat title:", error);
      // Hier nicht abbrechen, Chat funktioniert trotzdem weiter

      // Fallback zur einfachen Methode bei Fehlern
      try {
        const fallbackTitle = generateChatName(firstUserMessage);
        console.log(`‚ö†Ô∏è Using fallback title due to error: "${fallbackTitle}"`);

        const { error: updateError } = await supabase
          .from("chats")
          .update({ name: fallbackTitle })
          .eq("id", chatId);

        if (!updateError) {
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: fallbackTitle } : chat
            )
          );
        }
      } catch (fbError) {
        console.error("‚ùå Even fallback title setting failed:", fbError);
      }
    }
  }

  // F√ºge Event-Listener f√ºr Klicks au√üerhalb der Edit-Box hinzu
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        editBoxRef.current &&
        !editBoxRef.current.contains(event.target as Node) &&
        editingMessageId
      ) {
        cancelEditMessage()
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [editingMessageId])

  // Handle Joyride callback
  const handleJoyrideCallback = (data: CallBackProps) => {
    const { action, index, status, type } = data

    if (type === "step:before" && index === 2) {
      // Show fake messages for message actions
      setShowFakeMessagesForTour(true)
      // Instead of continuing with the tour, show our custom dialog
      setShowMessageActionsDialog(true)
      // Pause the tour
      setRunTour(false)
    } else if (type === "step:after" && index === 2) {
      // Clear fake messages after the step
      setShowFakeMessagesForTour(false)
    }

    if (action === "reset" || status === STATUS.FINISHED) {
      setRunTour(false)
      setShowFakeMessagesForTour(false)
      setShowMessageActionsDialog(false)
    }

    if (type === "step:after") {
      setStepIndex(index + 1)
    }
  }

  // Function to start the tour at a specific step
  const startTourAt = (index: number) => {
    setStepIndex(index)
    // Use timeout to ensure UI elements are rendered, especially if sidebar visibility changes
    setTimeout(() => {
      setRunTour(true)
    }, 100) // Small delay might be needed
  }

  // Function to handle "Deep Research" button click
  const handleDeepResearch = async () => {
    if (!inputValue.trim()) return // Do nothing if input is empty

    // Use the enhanced handleSendMessage with web search enabled
    await handleSendMessage(inputValue.trim(), true)
  }

  // Handle PDF export with message selection
  const handleExportPdf = (
    selection: "all" | "last5" | "last10" | number[]
  ) => {
    try {
      const chatName =
        chatSessions.find(chat => chat.id === currentChatId)?.name || "Chat"
      downloadChatAsPdf(messages, chatName, selection)
    } catch (error) {
      console.error("Error exporting chat:", error)
      // You could add an error state and show a notification here
    }
  }

  // Handle chat summary generation
  const handleGenerateSummary = async () => {
    if (messages.length < 2) {
      // F√ºge eine Nachricht hinzu, wenn nicht genug Nachrichten vorhanden sind
      const errorMessage: Message = {
        id: uuidv4(),
        role: "assistant",
        content: "Es gibt nicht gen√ºgend Nachrichten f√ºr eine Zusammenfassung.",
        timestamp: new Date()
      }
      setMessages(prevMessages => [...prevMessages, errorMessage])
      return
    }

    // Zeige einen Ladeindikator im Chat
    const loadingMessage: Message = {
      id: uuidv4(),
      role: "assistant",
      content: "Erstelle eine Zusammenfassung des bisherigen Chats...",
      timestamp: new Date(),
      isTypewriting: true
    }

    const loadingMessageId = loadingMessage.id
    setMessages(prevMessages => [...prevMessages, loadingMessage])
    setIsTyping(true)

    try {
      // Direkter API-Aufruf mit speziellen Optionen f√ºr die Zusammenfassung
      const chatMessages = messages.filter(m => m.role === "user" || m.role === "assistant");
      
      // Erstelle einen speziellen Prompt f√ºr die Zusammenfassung
      const summaryPrompt = `
        Erstelle eine kurze, pr√§gnante Zusammenfassung dieses Gespr√§chs. 
        WICHTIG: Verwende KEINE Markdown-√úberschriften (kein #, ## usw.). 
        Beginne direkt mit einem einleitenden Absatz, gefolgt von den wichtigsten Punkten als einfache Liste.
        
        Hier ist der Chatverlauf:
        ${chatMessages.map(m => `${m.role.toUpperCase()}: ${m.content}`).join("\n\n")}
      `;
      
      // Manueller API-Aufruf, um mehr Kontrolle √ºber das Format zu haben
      const response = await fetch("/api/chat", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [{ role: "user", content: summaryPrompt }],
          model: "gpt-4o", // Verwende neuestes Modell
          stream: false // Wichtig: kein Streaming f√ºr diesen Anwendungsfall
        })
      });
      
      if (!response.ok) {
        throw new Error(`API-Fehler: ${response.status}`);
      }
      
      // Als Text behandeln, nicht als JSON
      const summaryText = await response.text();
      
      // Bereinige den Text von m√∂glichen Markdown-Formatierungen
      const cleanedSummary = summaryText
        .replace(/^#+\s+/gm, '') // Entferne Markdown-√úberschriften
        .replace(/```[\s\S]*?```/g, '') // Entferne Code-Bl√∂cke
        .trim();

      // Ersetze die Lade-Nachricht mit der tats√§chlichen Zusammenfassung
      setMessages(prevMessages =>
        prevMessages.map(msg =>
          msg.id === loadingMessageId
            ? { ...msg, content: cleanedSummary, isTypewriting: false }
            : msg
        )
      )

      // Speichere die Nachricht in der Datenbank, wenn ein Chat aktiv ist
      if (currentChatId) {
        try {
          const { error: messageError } = await supabase
            .from("chat_messages")
            .insert({
              chat_id: currentChatId,
              role: "assistant",
              content: cleanedSummary,
              user_id: user?.id,
              created_at: new Date().toISOString()
            })

          if (messageError) {
            console.error("‚ùå Error saving summary message:", messageError)
          } else {
            console.log("‚úÖ Summary message saved")
          }
        } catch (dbError) {
          console.error("Database error saving summary:", dbError)
        }
      }
    } catch (error) {
      console.error("Error generating summary:", error)

      // Erstelle eine aussagekr√§ftigere Fehlermeldung
      let errorMessage = "Bei der Erstellung der Zusammenfassung ist ein Fehler aufgetreten. Bitte versuche es sp√§ter erneut."
      
      // Spezifische Fehlermeldung je nach Fehlertyp
      if (error instanceof Error) {
        if (process.env.NODE_ENV === "development") {
          errorMessage += ` (${error.name}: ${error.message})`
        }
      }

      // Ersetze die Lade-Nachricht mit einer Fehlermeldung
      setMessages(prevMessages =>
        prevMessages.map(msg =>
          msg.id === loadingMessageId
            ? {
                ...msg,
                content: errorMessage,
                isTypewriting: false
              }
            : msg
        )
      )
    } finally {
      setIsTyping(false)
    }
  }

  const chatSessionsWithProjectInfo = chatSessions.map(chat => {
    const assignedProject = projects.find(
      project => chat.project_id === project.id
    )
    return {
      ...chat,
      assignedProjectName: assignedProject?.name || null
    }
  })

  // Nicht zugewiesene Chats filtern - Optimize with proper memoization
  const unassignedChats = useMemo(() => {
    console.debug("Calculating unassigned chats from", chatSessions.length, "available chats");
    return chatSessions.filter(chat => chat.project_id === null);
  }, [chatSessions]); // Only recalculate when chatSessions changes

  // Chats nach Projekten gruppieren - Optimize with proper dependencies
  const chatsByProject = useMemo(() => {
    console.debug("Calculating chats by project from", chatSessions.length, "available chats");
    // Kopiere die Projekte und f√ºge die zugeh√∂rigen Chats hinzu
    return projects.map(project => {
      const projectChats = chatSessions.filter(
        chat => chat.project_id === project.id
      );
      console.debug(`Project ${project.name} has ${projectChats.length} chats`);
      return {
        ...project,
        chats: projectChats
      };
    });
  }, [projects, chatSessions]); // Only recalculate when projects or chatSessions change

  // Toggle Funktion f√ºr das Aufklappen der Projekte
  const toggleProjectExpansion = (projectId: string) => {
    console.log("Toggling project expansion for", projectId)
    setExpandedProjects(prev => ({
      ...prev,
      [projectId]: !prev[projectId]
    }))

    // Wenn ein Projekt ausgew√§hlt wird, setzen wir es auch als aktives Projekt
    setSelectedProject(projects.find(p => p.id === projectId) || null)
  }

  // Hinzuf√ºgen einer Funktion, um anzuzeigen, ob ein Chat geladen ist
  const isActiveChat = (chatId: string): boolean => {
    return currentChatId === chatId
  }

  // Verbesserte Funktion zum Laden eines Chats
  const handleSelectChat = async (chatId: string) => {
    console.log(`Selecting chat: ${chatId}`)

    // Check if it's a valid chat
    const selectedChat = chatSessions.find(chat => chat.id === chatId)
    if (!selectedChat) {
      console.error(`Chat ${chatId} not found in current chat sessions!`)
      return
    }

    // Set current chat
    setCurrentChatId(chatId)

    // Load chat contents
    await loadChat(chatId)

    // If the chat belongs to a project, ensure the project is expanded and set as filter
    if (selectedChat.project_id) {
      console.log(`Chat belongs to project ${selectedChat.project_id}, expanding and filtering`)
      setExpandedProjects(prev => ({
        ...prev,
        [selectedChat.project_id!]: true
      }))
      
      // Set project filter if not already set
      setActiveProjectFilter(selectedChat.project_id)
      setProjectFilterActive(true)
    }
  }

  // Add new states for project filtering
  const [projectFilterActive, setProjectFilterActive] = useState(false)
  const [activeProjectFilter, setActiveProjectFilter] = useState<string | null>(null)
  const [showProjectFilterDropdown, setShowProjectFilterDropdown] = useState(false)
  
  // Add a new function to handle project filtering
  const toggleProjectFilter = () => {
    setShowProjectFilterDropdown(!showProjectFilterDropdown)
  }
  
  const setProjectFilter = (projectId: string | null) => {
    setActiveProjectFilter(projectId)
    setProjectFilterActive(!!projectId)
    setShowProjectFilterDropdown(false)
  }
  
  // Filter chats based on activeProjectFilter
  const filteredChatSessions = useMemo(() => {
    if (!projectFilterActive || !activeProjectFilter) {
      return chatSessions
    }
    return chatSessions.filter(chat => chat.project_id === activeProjectFilter)
  }, [chatSessions, projectFilterActive, activeProjectFilter])
  

  if (error) {
    return (
      <div className="flex h-screen items-center justify-center bg-[var(--bg-primary)]">
        <div className="max-w-md rounded-lg border border-[var(--border-light)] bg-[var(--bg-tertiary)] p-6 text-center">
          <h2 className="mb-4 text-xl font-medium text-[var(--text-primary)]">
            Fehler
          </h2>
          <p className="mb-4 text-[var(--text-secondary)]">{error}</p>
          <Link
            href="/login"
            className="inline-flex rounded-md bg-[var(--accent-primary)] px-4 py-2 text-sm font-medium text-white hover:bg-[var(--accent-primary-hover)]"
          >
            Zum Login
          </Link>
        </div>
      </div>
    )
  }

  // Funktion, um einen neuen Chat zu beginnen (ohne ihn sofort zu erstellen)
  const startNewChat = () => {
    // Zur√ºcksetzen des Typing-Status f√ºr den neuen Chat
    setHasStartedTyping(false)
    
    // Bisheriger Code
    setMessages([])
    setCurrentChatId(null)
    setEditingMessageId(null)
    setEditingContent("")
    setSelectedTask(null)
    setInputValue("")
    
    // Ensure we're not showing fake messages
    setShowFakeMessagesForTour(false)
    
    // Set isStartingNewChat flag to prevent re-rendering
    isStartingNewChatRef.current = true;
    
    // URL aktualisieren
    const currentPath = window.location.pathname;
    const workspaceQuery = rawWorkspaceId ? `?workspace=${rawWorkspaceId}` : "";
    router.push(`${currentPath}${workspaceQuery}`);
    
    // Fokus auf Inputfeld
    setTimeout(() => {
      if (inputRef.current) {
        inputRef.current.focus();
      }
    }, 100);
  }

  // Add message search functionality
  const handleMessageSearch = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!messageSearchQuery.trim()) return

    try {
      setIsSearching(true)

      // Search in message content - fixed table name from messages to chat_messages
      const { data: messagesData, error: messagesError } = await supabase
        .from("chat_messages")
        .select("id, content, chat_id, created_at, chats(name)")
        .ilike("content", `%${messageSearchQuery}%`)
        .order("created_at", { ascending: false })
        .limit(20)

      if (messagesError) {
        console.error("Fehler bei der Suche in Nachrichten:", messagesError)
      }

      // Combine client-side chat results with server-side message results
      const messageResults = messagesData || []

      // Format message results
      const formattedResults = messageResults.map(result => ({
        id: `message-${result.id}`,
        content: result.content,
        chat_id: result.chat_id,
        created_at: result.created_at,
        chats: result.chats,
        type: "message"
      }))

      // Add any existing client-side filtered chat results
      const existingChatResults = messageSearchResults
        .filter(result => result.id?.startsWith("local-"))
        .map(result => ({ ...result, type: "chat" }))

      // Combine both types of results
      setMessageSearchResults([...formattedResults, ...existingChatResults])
      console.log(
        "Search results:",
        [...formattedResults, ...existingChatResults].length
      )
    } catch (err) {
      console.error("Fehler bei der Suche:", err)
    } finally {
      setIsSearching(false)
    }
  }

  // Update handleSearchInputChange to trigger search automatically after 3+ characters
  const handleSearchInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const query = e.target.value
    setMessageSearchQuery(query)

    // Client-side filtering of visible chats list when typing
    if (query.trim() === "") {
      setMessageSearchResults([])
    } else {
      // Filter chat sessions that match the query and convert to search result format
      const filteredChats = chatSessions
        .filter(chat => chat.name.toLowerCase().includes(query.toLowerCase()))
        .map(chat => ({
          id: `local-${chat.id}`,
          content: "Chat gefunden",
          chat_id: chat.id,
          created_at: chat.created_at,
          chats: { name: chat.name },
          type: "chat"
        }))

      setMessageSearchResults(filteredChats)

      // If query is 3+ characters, automatically trigger the full search
      if (query.trim().length >= 3) {
        // Create a debounced search function to avoid too many API calls
        clearTimeout(searchDebounceTimeout.current)
        searchDebounceTimeout.current = setTimeout(async () => {
          try {
            setIsSearching(true)

            // Search in message content - fixed table name from messages to chat_messages
            const { data: messagesData, error: messagesError } = await supabase
              .from("chat_messages")
              .select("id, content, chat_id, created_at, chats(name)")
              .ilike("content", `%${query}%`)
              .order("created_at", { ascending: false })
              .limit(20)

            if (messagesError) {
              console.error(
                "Fehler bei der Suche in Nachrichten:",
                messagesError
              )
            }

            // Combine client-side chat results with server-side message results
            const messageResults = messagesData || []

            // Format message results
            const formattedResults = messageResults.map(result => ({
              id: `message-${result.id}`,
              content: result.content,
              chat_id: result.chat_id,
              created_at: result.created_at,
              chats: result.chats,
              type: "message"
            }))

            // Combine both types of results
            setMessageSearchResults([...formattedResults, ...filteredChats])
          } catch (err) {
            console.error("Fehler bei der Suche:", err)
          } finally {
            setIsSearching(false)
          }
        }, 300) // 300ms debounce
      }
    }
  }

  const toggleMessageSearch = () => {
    setSearchOpen(!searchOpen)
    if (!searchOpen) {
      setMessageSearchQuery("")
      setMessageSearchResults([])
    }
  }

  const handleImprovePrompt = async () => {
    if (!newTaskSystemPrompt.trim()) return

    try {
      setIsImprovingPrompt(true)

      // Make API call to your reasoning model to improve the prompt
      const response = await fetch("/api/improve-prompt", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          prompt: newTaskSystemPrompt,
          userId: user.id
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => null)
        const errorMessage =
          errorData?.error || "Fehler beim Verbessern des Prompts"
        console.error("API Error:", errorData)
        throw new Error(errorMessage)
      }

      const data = await response.json()
      setNewTaskSystemPrompt(data.improvedPrompt)

      // Show success message -- Removed alert
      // alert(`Prompt erfolgreich verbessert! (Verwendet: ${data.modelUsed || 'GPT-Modell'})`);
    } catch (error: any) {
      console.error("Error improving prompt:", error)
      alert(
        `Fehler beim Verbessern des Prompts: ${error.message || "Unbekannter Fehler"}`
      )
    } finally {
      setIsImprovingPrompt(false)
    }
  }

  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])

  // Finde und ersetze das useEffect f√ºr die Nachrichten-Subscription
  useEffect(() => {
    // Wenn kein Chat ausgew√§hlt ist, nichts tun
    if (!currentChatId) {
      return;
    }
    
    debugLog(`Setting up message subscription for chat: ${currentChatId}`);
    
    // Cleanup function for the channel
    const cleanupChannel = () => {
      if (messagesChannelRef.current && supabase) {
        debugLog("Cleaning up previous message subscription");
        supabase.removeChannel(messagesChannelRef.current);
        messagesChannelRef.current = null;
      }
    };

    // Clean up previous channel before creating a new one
    cleanupChannel();
    
    // Configure realtime channel for chat_messages
    const channelId = `chat_messages_${currentChatId}`;
    const messagesChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "*", // INSERT, UPDATE, DELETE
          schema: "public",
          table: "chat_messages",
          filter: `chat_id=eq.${currentChatId}`
        },
        payload => {
          debugLog(`Realtime message update received for chat ${currentChatId}:`, payload.eventType);

          // Only handle new message insertions
          if (payload.eventType === "INSERT") {
            const newMsg = payload.new;
            
            // *** CRITICAL: Prevent duplicate messages by checking if we've processed this ID already
            if (processedMessageIds.has(newMsg.id)) {
              debugLog(`Skipping already processed message with ID: ${newMsg.id}`);
              return;
            }
            
            // Add to processed set
            processedMessageIds.add(newMsg.id);
            
            // Check if message from another user (not from this client)
            const msgSentByOtherUser = newMsg.user_id && newMsg.user_id !== user?.id;
            
            setMessages(prevMessages => {
              // Double-check for duplicate messages by content and timestamp
              const exists = prevMessages.some(
                msg =>
                  (msg.id === newMsg.id) || // Same ID 
                  (msg.content === newMsg.content &&
                  msg.role === newMsg.role &&
                  new Date(msg.timestamp).getTime() > Date.now() - 5000) // Recent similar message
              );

              if (!exists) {
                debugLog("Adding new message from realtime subscription");
                
                // Process content - strip date prefix if present
                let messageContent = newMsg.content;
                if (messageContent && typeof messageContent === 'string' && messageContent.startsWith('[Datum:') && messageContent.includes(']\n')) {
                  messageContent = messageContent.replace(/^\[Datum:[^\]]+\]\n/, '');
                }
                
                return [
                  ...prevMessages,
                  {
                    id: newMsg.id || uuidv4(),
                    role: newMsg.role as "user" | "assistant" | "system",
                    content: messageContent,
                    timestamp: new Date(newMsg.created_at),
                    user_id: newMsg.user_id,
                    sentfrom: newMsg.sentfrom
                  }
                ];
              }
              return prevMessages;
            });
          }
        }
      )
      .subscribe((status) => {
        debugLog(`Message subscription status for ${channelId}: ${status}`);
      });
    
    // Store the channel in the ref
    messagesChannelRef.current = messagesChannel;

    // Cleanup on unmount or when currentChatId changes
    return cleanupChannel;
  }, [currentChatId, supabase, user?.id]);

  // Realtime subscription f√ºr √Ñnderungen an Chats (insbesondere Projekt-Zuordnungen)
  useEffect(() => {
    // Wenn bereits eine Subscription existiert, nichts tun
    if (chatsChannelRef.current) {
      console.log("Chats subscription already exists, skipping creation");
      return;
    }

    if (user && supabase) {
      // Verwende einen konsistenten Namen
      const channelId = `chats_updates_global`;
      console.log(`Setting up realtime subscription for chats table: ${channelId}`);

      // Konfiguriere den Realtime-Channel f√ºr die chats Tabelle
      const chatsChannel = supabase
        .channel(channelId)
        .on(
          "postgres_changes",
          {
            event: "UPDATE", // Nur Updates √ºberwachen
            schema: "public",
            table: "chats"
          },
          payload => {
            console.log("Realtime chat update received:", payload);

            // Aktualisiere den lokalen State, wenn sich ein Chat √§ndert
            if (payload.eventType === "UPDATE") {
              const updatedChat = payload.new;

              // Aktualisiere den chatSessions-State
              setChatSessions(prevSessions => {
                // Avoid state updates if nothing changed
                const chatNeedsUpdate = prevSessions.some(
                  chat => 
                    chat.id === updatedChat.id && 
                    (chat.name !== updatedChat.name || chat.project_id !== updatedChat.project_id)
                );
                
                if (!chatNeedsUpdate) {
                  return prevSessions;
                }
                
                return prevSessions.map(chat =>
                  chat.id === updatedChat.id
                    ? {
                        ...chat,
                        name: updatedChat.name,
                        project_id: updatedChat.project_id
                      }
                    : chat
                );
              });
            }
          }
        )
        .subscribe((status) => {
          console.log(`Subscription status for ${channelId}:`, status);
        });
      
      // Speichere den Channel in der Ref
      chatsChannelRef.current = chatsChannel;

      // Cleanup beim Unmount oder wenn der Komponent neu geladen wird
      return () => {
        if (chatsChannelRef.current && supabase) {
          console.log("Cleaning up chats table subscription");
          supabase.removeChannel(chatsChannelRef.current);
          chatsChannelRef.current = null;
        }
      };
    }
    
    // Leere Cleanup-Funktion zur√ºckgeben, wenn keine Subscription erstellt wurde
    return () => {};
  }, [user, supabase]);  // Reduzierte Abh√§ngigkeiten

  // Hilfsfunktion, um Initialen aus User-ID oder E-Mail zu extrahieren
  const getUserInitials = (userId: string | undefined): string => {
    if (!userId) return "?"

    // Einfache Extraktionslogik - nimmt die ersten 2 Zeichen der userId
    // In einer realen Anwendung w√ºrde man hier den Namen des Benutzers abrufen
    return userId.substring(0, 2).toUpperCase()
  }

  // Funktion zum Erstellen und Speichern von Embeddings
  const createEmbedding = async (
    message: Message,
    chatId: string | null,
    workspaceId: string | null = null
  ) => {
    try {
      console.log("üîÑ Erstelle Embedding f√ºr Nachricht:", message.id)

      // UUID-Validierung: √úberpr√ºfe, ob message.id ein g√ºltiger String ist
      if (
        !message.id ||
        typeof message.id !== "string" ||
        message.id.trim() === ""
      ) {
        console.error("‚ùå Ung√ºltige message.id f√ºr Embedding:", message.id)
        console.error("Message Objekt:", JSON.stringify(message, null, 2))
        return null // Fr√ºher Abbruch bei ung√ºltiger ID
      }

      console.log("üì® Original Nachrichteninhalt:", message.content)

      // Current date formatted for embedding
      const currentDate = new Date().toISOString().split("T")[0] // Format: YYYY-MM-DD

      // Append date information to the content for embedding
      const contentWithDate = `[Datum: ${currentDate}]\n${message.content}`
      console.log(
        "üìÖ Nachrichteninhalt mit Datum f√ºr Embedding:",
        contentWithDate
      )

      // Wenn dies nur ein Embedding f√ºr die Suche ist (chatId ist null),
      // dann erstellen wir nur das Embedding ohne es zu speichern
      const isSearchOnly = chatId === null

      // OpenAI API f√ºr Embedding aufrufen
      console.log(
        "üß† Embedding wird generiert f√ºr Inhalt mit L√§nge:",
        contentWithDate.length
      )
      const response = await fetch("/api/embeddings", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          input: contentWithDate
        })
      })

      if (!response.ok) {
        throw new Error(`Embedding API responded with ${response.status}`)
      }

      const embeddingData = await response.json()
      console.log("‚úÖ Embedding erfolgreich generiert:")
      console.log("üìä Embedding-Dimensionen:", embeddingData.embedding.length)
      console.log(
        "üîç Embedding-Vorschau (erste 5 Werte):",
        embeddingData.embedding.slice(0, 5)
      )
      console.log(
        "üîç Embedding-Vorschau (letzte 5 Werte):",
        embeddingData.embedding.slice(-5)
      )

      // F√ºr Suchanfragen fr√ºhzeitig zur√ºckkehren, ohne zu speichern
      if (isSearchOnly) {
        console.log(
          "‚ÑπÔ∏è Suchmodus: Embedding wird nur generiert, nicht gespeichert"
        )
        return embeddingData.embedding
      }

      // Validiere chatId
      if (!chatId || typeof chatId !== "string" || chatId.trim() === "") {
        console.error("‚ùå Ung√ºltige chatId f√ºr Embedding:", chatId)
        return null // Fr√ºher Abbruch bei ung√ºltiger chatId
      }

      // In der Datenbank speichern
      const dbPayload = {
        message_id: message.id,
        chat_id: chatId,
        workspace_id: workspaceId || null, // Stelle sicher, dass null und nicht Leerstring gespeichert wird
        role: message.role,
        embedding: embeddingData.embedding,
        content_with_date: contentWithDate // Store the content with date in the new column
      }

      console.log("üíæ Speichere in DB mit Payload:", {
        message_id: dbPayload.message_id,
        chat_id: dbPayload.chat_id,
        workspace_id: dbPayload.workspace_id,
        role: dbPayload.role,
        content_with_date: contentWithDate.substring(0, 50) + "...", // Log truncated for readability
        embedding_length: embeddingData.embedding.length
      })

      const { data, error } = await supabase
        .from("message_embeddings")
        .insert(dbPayload)
        .select()

      if (error) {
        console.error("‚ùå Fehler beim Speichern des Embeddings:", error)
        throw error
      }
      console.log("‚úÖ Embedding gespeichert f√ºr Nachricht:", message.id)
      if (data) {
        console.log("üìù DB-Eintrag erstellt mit ID:", data[0]?.id)
      }

      return embeddingData.embedding
    } catch (error) {
      console.error("‚ùå Fehler beim Erstellen des Embeddings:", error)
      return null
    }
  }

  // Funktion zum Finden √§hnlicher Nachrichten f√ºr einen *Benutzer*
  const findSimilarMessages = async (query: string, userId: string) => {
    // Stelle sicher, dass eine userId vorhanden ist
    if (!userId) {
      console.error(
        "‚ùå User ID fehlt f√ºr die Suche nach √§hnlichen Nachrichten."
      )
      return []
    }

    try {
      console.log(`üîç Suche nach √§hnlichen Nachrichten f√ºr User ${userId}`)
      console.log(`üìù Suchanfrage: "${query}"`)

      // Embedding f√ºr die Abfrage erstellen
      console.log("üß† Generiere Embedding f√ºr Suchanfrage...")
      const response = await fetch("/api/embeddings", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          input: query
        })
      })

      if (!response.ok) {
        throw new Error(`Embedding API responded with ${response.status}`)
      }

      const embeddingData = await response.json()
      console.log("‚úÖ Embedding f√ºr Abfrage erfolgreich generiert")
      console.log(
        "üìä Query-Embedding-Dimensionen:",
        embeddingData.embedding.length
      )
      console.log(
        "üîç Query-Embedding-Vorschau (erste 5 Werte):",
        embeddingData.embedding.slice(0, 5)
      )

      // √Ñhnliche Nachrichten mit *neuer* Stored Procedure finden
      console.log(
        `üìû Rufe search_similar_messages RPC f√ºr User ${userId} auf (Schwellwert: 0.7, Max Ergebnisse: 10)`
      )
      const { data, error } = await supabase.rpc("search_similar_messages", {
        query_embedding: embeddingData.embedding,
        p_user_id: userId, // √úbergabe der User ID
        similarity_threshold: 0.7, // Erh√∂ht von 0.3 auf 0.7 f√ºr pr√§zisere Ergebnisse
        max_results: 10
      })

      if (error) {
        console.error("‚ùå Fehler in search_similar_messages RPC:", error)
        throw error
      }

      console.log(`üîé RPC Ergebnis: ${data?.length || 0} Nachrichten gefunden`)
      if (data && data.length > 0) {
        console.log("üìã Erste Ergebnisse (Rohdaten):", data.slice(0, 2))
      }

      // Filtere die Ergebnisse: Behalte Kontext-Nachrichten und ignoriere zu √§hnliche prim√§re Nachrichten
      const filteredData =
        data?.filter(
          (m: any) =>
            m.is_context || // immer Kontext-Nachrichten behalten
            m.similarity < 0.99 // Nur Hauptnachrichten filtern, nicht Kontext
        ) || []

      console.log(`üßπ Nach Filterung: ${filteredData.length} Nachrichten √ºbrig`)

      // Process messages to extract date information if present
      console.log(
        "üîÑ Verarbeite Nachrichten, um Datumsinformationen zu extrahieren..."
      )
      const processedData = filteredData.map((m: any) => {
        let displayContent = m.content
        let dateInfo = null

        // Extract date information if it's included in the format [Datum: YYYY-MM-DD]
        const dateMatch = m.content.match(/\[Datum: (\d{4}-\d{2}-\d{2})\]/)
        if (dateMatch) {
          dateInfo = dateMatch[1]
          // Remove the date prefix for display
          displayContent = m.content.replace(
            /\[Datum: \d{4}-\d{2}-\d{2}\]\n/,
            ""
          )
          console.log(
            `üìÖ Datum gefunden in Nachricht ${m.message_id}: ${dateInfo}`
          )
        } else {
          console.log(`‚ö†Ô∏è Kein Datum gefunden in Nachricht ${m.message_id}`)
        }

        return {
          ...m,
          displayContent,
          dateInfo,
          isContext: m.is_context || false // √úbernehme das Kontext-Flag
        }
      })

      console.log(
        `‚úÖ ${processedData.length} √§hnliche Nachrichten nach Filterung gefunden`
      )

      // Gruppiere zusammengeh√∂rige Nachrichten f√ºr bessere √úbersicht in Logs
      const contextGroups = new Map()

      processedData.forEach((m: any, index: number) => {
        const contextKey = m.isContext ? "context" : `main-${index}`

        console.log(
          `üîπ ${m.isContext ? "Kontext-Nachricht" : "Ergebnis"} #${index + 1}:`
        )
        console.log(`  ‚Ä¢ ID: ${m.message_id}`)
        console.log(`  ‚Ä¢ Chat: ${m.chat_id}`)
        console.log(`  ‚Ä¢ Rolle: ${m.role}`)
        console.log(`  ‚Ä¢ Datum: ${m.dateInfo || "Keines"}`)
        console.log(
          `  ‚Ä¢ √Ñhnlichkeit: ${m.similarity.toFixed(4)}${m.isContext ? " (Kontext)" : ""}`
        )
        console.log(
          `  ‚Ä¢ Inhalt: ${(m.displayContent || m.content).substring(0, 100)}${(m.displayContent || m.content).length > 100 ? "..." : ""}`
        )
      })

      // Sortiere die Ergebnisse: Prim√§re Nachricht, dann Kontext
      processedData.sort((a: any, b: any) => {
        // Behalte die bestehende Sortierung bei
        return a.isContext === b.isContext
          ? b.similarity - a.similarity // Bei gleichem Typ: Nach √Ñhnlichkeit absteigend
          : a.isContext
            ? 1
            : -1 // Prim√§re Nachrichten zuerst
      })

      return processedData
    } catch (error) {
      console.error("‚ùå Fehler beim Suchen √§hnlicher Nachrichten:", error)
      return []
    }
  }

  // Neue state-Variable, um zu verfolgen, ob der Benutzer bereits angefangen hat zu tippen
  const [hasStartedTyping, setHasStartedTyping] = useState(false)

  // ... existing code - add after newTaskModel state ...
  const [newTaskKnowledgeBaseId, setNewTaskKnowledgeBaseId] = useState<string[]>([])
  // ... existing code ...

  // Add the knowledgeBases state
  const [knowledgeBases, setKnowledgeBases] = useState<any[]>([])
  // ... existing code ...

  // Add this useEffect to fetch knowledge bases when opening the task modal
  useEffect(() => {
    const fetchKnowledgeBases = async () => {
      if (!showTaskModal || !user) return;
      
      try {
        // 1. Fetch all knowledge bases
        const { data: allKBs, error: kbError } = await supabase
          .from("knowledge_bases")
          .select("*")
          .order("name", { ascending: true });

        if (kbError) throw kbError;
        if (!allKBs || allKBs.length === 0) {
          setKnowledgeBases([]);
          return;
        }

        // 2. Fetch the user's group memberships
        const { data: groupMembers, error: groupMembersError } = await supabase
          .from("knowledge_group_members")
          .select("group_id")
          .eq("user_id", user.id);

        if (groupMembersError) throw groupMembersError;

        const userGroupIds = groupMembers?.map(member => member.group_id) || [];
        
        if (userGroupIds.length === 0) {
          setKnowledgeBases(allKBs.map(kb => ({ ...kb, hasAccess: false })));
          return;
        }

        // 3. Fetch which knowledge bases are linked to the user's groups
        const { data: accessibleKBsLinks, error: accessibleError } = await supabase
          .from("knowledge_base_groups")
          .select("knowledge_base_id")
          .in("group_id", userGroupIds);

        if (accessibleError) throw accessibleError;

        const accessibleKbIds = new Set(accessibleKBsLinks?.map(link => link.knowledge_base_id) || []);

        // 4. Combine the data: Mark each KB with access status
        const kbsWithAccess = allKBs.map(kb => ({
          ...kb,
          hasAccess: accessibleKbIds.has(kb.id)
        }));

        setKnowledgeBases(kbsWithAccess);
      } catch (err) {
        console.error("Error fetching knowledge bases:", err);
        setKnowledgeBases([]);
      }
    };

    fetchKnowledgeBases();
  }, [showTaskModal, user, supabase]);

  // Add this state to track active function calls
  const [activeFunctionCall, setActiveFunctionCall] = useState<string | null>(null);
  
  // Define the missing variables
  const [eventSource, setEventSource] = useState<EventSource | null>(null);
  
  // ... existing code ...
  
  // Define appendStreamToLastMessage function before sendMessageToAPI
  const appendStreamToLastMessage = (content: string) => {
    setMessages(prevMessages => {
      const lastAssistantIndex = [...prevMessages]
        .reverse()
        .findIndex(m => m.role === "assistant");
      
      if (lastAssistantIndex === -1) return prevMessages;
      
      const actualIndex = prevMessages.length - 1 - lastAssistantIndex;
      const updatedMessages = [...prevMessages];
      
      // Update content by appending the new chunk
      updatedMessages[actualIndex] = {
        ...updatedMessages[actualIndex],
        content: updatedMessages[actualIndex].content + content
      };
      
      return updatedMessages;
    });
  };
  
  // ... existing code ...
  
  // Update the sendMessageToAPI function
  const sendMessageToAPI = async (
    messages: Message[],
    model: string,
    chatId: string
  ) => {
    // ... rest of the function ...
}
