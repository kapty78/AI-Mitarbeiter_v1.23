"use client"

import React from "react"
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs"
import { useEffect, useRef, useState, useMemo, useCallback } from "react"
import { useSearchParams } from "next/navigation"
import Link from "next/link"
import {
  ChevronLeft,
  Menu,
  Plus,
  Send,
  ChevronDown,
  Copy,
  RotateCcw,
  Edit,
  Paperclip,
  Image,
  Search,
  MoreVertical,
  Trash,
  X,
  FlaskConical,
  MoreHorizontal,
  Mic,
  Loader,
  FileText,
  FileDown,
  BookOpen,
  User,
  Settings,
  Home,
  ChevronRight,
  MessageCircle,
  Sparkles,
  Check
} from "lucide-react" // Added Icons
import ReactMarkdown from "react-markdown"
import remarkGfm from "remark-gfm"
import { v4 as uuidv4 } from "uuid"
import { TypewriterEffect } from "@/components/typewriter-effect"
import { RevealEffect } from "@/components/reveal-effect"; // Import RevealEffect
import { useRouter } from "next/navigation"
import { cn } from "@/lib/utils"
import Joyride, { Step, CallBackProps, STATUS } from "react-joyride" // Import Joyride
import dynamic from "next/dynamic" // Import dynamic
import {
  performSerpApiSearch,
  formatSearchResults,
  formatSearchResultsForAI
} from "../utils/serpApi"
import { downloadChatAsPdf } from "../utils/pdfExport"
import { generateChatSummary } from "../utils/chatSummary"
import ExportModal from "../components/ExportModal"
import SummaryModal from "../components/SummaryModal"
// Drag-and-Drop-Bibliotheken
import {
  DndContext,
  useDraggable,
  useDroppable,
  useSensors,
  useSensor,
  PointerSensor
} from "@dnd-kit/core"
import LoadingIndicator from "@/components/LoadingIndicator" // Corrected import path
import SettingsModal from "@/app/components/SettingsModal" // Import the SettingsModal component
import { KnowledgeBaseSelector } from "@/components/knowledge/KnowledgeBaseSelector"
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter"
import { oneDark } from "react-syntax-highlighter/dist/cjs/styles/prism"
import { MessageMarkdown } from "@/components/message-markdown"
import { MessageCodeBlock } from "@/components/message-code-block"
import { buildPrompt, DEFAULT_SYSTEM_PROMPT } from "@/lib/prompt-builder"

// Dynamically import Joyride with SSR disabled
const DynamicJoyride = dynamic(() => import("react-joyride"), { ssr: false })

// Define a simpler interface for CodeProps
interface CodeProps {
  node?: any
  inline?: boolean
  className?: string
  children?: React.ReactNode
}

interface Message {
  id: string
  role: "user" | "assistant" | "system"
  content: string
  timestamp: Date
  isTypewriting?: boolean
  user_id?: string // Add user_id to track message sender
  sentfrom?: string // Add sentfrom to store user name directly
}

interface ChatSession {
  id: string
  name: string
  created_at: string
  description?: string
  project_id?: string | null
  last_message_timestamp?: string
  user_id?: string
}

interface Task {
  id: string
  title: string
  description: string
  system_prompt: string
  ai_model: string
  created_at?: string
  updated_at?: string
  user_id?: string
  workspace_id?: string | null
  project_id?: string | null
}

interface Project {
  id: string
  name: string
  description?: string
  user_id: string
  workspace_id?: string | null
  chats?: ChatSession[] // Chats, die zu diesem Projekt geh√∂ren
}

// Define structure for info items (used for buttons, tour content can be different)
interface InfoItem {
  title: string
  // We'll define tour steps separately now
}

// Keep infoItems simple for the buttons
const infoItems: InfoItem[] = [
  { title: "Tasks nutzen" },
  { title: "KI-Modell wechseln" },
  { title: "Nachrichten bearbeiten & neu generieren" },
  { title: "Chats verwalten" }
]

const initialMessages: Message[] = []

// Define Tour Steps (Adjust step 3)
const tourSteps: Step[] = [
  {
    target: "#task-select-button",
    content: (
      <>
        <p className="mb-2">
          Mit Tasks k√∂nnen Sie der KI spezifische Anweisungen oder eine
          bestimmte Rolle f√ºr den gesamten Chat zuweisen.
        </p>
        <p>
          Klicken Sie hier, um einen vorhandenen Task zu w√§hlen oder einen neuen
          zu erstellen. Tasks √ºberschreiben die manuelle Modellauswahl.
        </p>
      </>
    ),
    placement: "bottom-end",
    title: "Tasks nutzen"
  },
  {
    target: "#model-select-button",
    content: (
      <>
        <p className="mb-2 text-sm">
          W√§hlen Sie hier das KI-Modell, wenn kein Task aktiv ist:
        </p>
        <ul className="mb-2 ml-4 list-inside list-disc space-y-1 text-sm">
          <li>
            <strong>Basic (GPT-4o):</strong> Ausgewogen.
          </li>
          <li>
            <strong>Fast (GPT-4o mini):</strong> Schnell & G√ºnstig.
          </li>
          <li>
            <strong>Reason (GPT-4 Vision):</strong> Leistungsstark.
          </li>
        </ul>
      </>
    ),
    placement: "bottom-end",
    title: "KI-Modell wechseln"
  },
  {
    target: "#chat-sidebar",
    content:
      "Hier verwalten Sie Ihre Chats: Neuen Chat erstellen (+), Chat ausw√§hlen, umbenennen oder l√∂schen (√ºber die drei Punkte).",
    placement: "right",
    title: "Chats verwalten"
  },
  {
    target: "#new-chat-button",
    content: "Klicken Sie hier, um einen neuen, leeren Chat zu beginnen.",
    placement: "left",
    title: "Neuer Chat",
    disableScrolling: true,
    disableOverlayClose: true,
    spotlightPadding: 5
  },
  {
    target: "#chat-input-textarea",
    content:
      "Geben Sie hier Ihre Nachricht ein und dr√ºcken Sie Enter oder klicken Sie auf den Senden-Button.",
    placement: "top",
    title: "Nachricht senden"
  }
]

// Helper function to fix the columns handling consistently
const getColumnNames = (columns: any[] | null): string[] => {
  return columns
    ? columns.map((col: { column_name: string }) => col.column_name)
    : []
}

// Detect and format HTML code
const formatCodeInMessage = (content: string): string => {
  // If content already has markdown code blocks, don't modify
  if (content.includes("```")) return content;
  
  // Check if the content appears to be HTML
  if (
    content.trim().startsWith("<") && 
    (content.includes("<!DOCTYPE") || 
     content.includes("<html") ||
     (content.includes("<body") && content.includes("</body>")) ||
     (content.includes("<head") && content.includes("</head>")))
  ) {
    return "```html\n" + content + "\n```";
  }
  
  return content;
};

// This is a standalone component for code blocks

// ---> HILFSFUNKTIONEN f√ºr V2 Prompt <--- 
function trimText(txt: string | null | undefined, maxWords = 60): string {
  if (!txt) return "";
  const words = txt.trim().split(/\s+/);
  if (words.length <= maxWords) return txt;
  return words.slice(0, maxWords).join(" ") + " ‚Ä¶";
}

// V2 System Prompt Definition - entfernt, da jetzt zentral in prompt-builder.ts definiert
// const systemPrompt = `...`.trim();
// ---> ENDE HILFSFUNKTIONEN f√ºr V2 Prompt <--- 

// Add debugging flag at the top of the file, after imports
const DEBUG_MODE = false; // Set to true to enable verbose logging

// Replace console.log with debug-aware logging function
const debugLog = (...args: any[]) => {
  if (DEBUG_MODE) {
    console.log(...args);
  }
};

// Add this custom hook for subscription management
// Place it outside the component, before export default function Chat()
const useSubscriptions = (supabase: any) => {
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const [subscriptionStatus, setSubscriptionStatus] = useState({
    chatsSubscribed: false,
    messagesSubscribed: false
  });

  // Setup chat subscription
  const setupChatSubscription = useCallback((userId: string) => {
    if (!supabase || !userId || chatsChannelRef.current) {
      return;
    }

    const channelId = `chats_updates_global`;
    debugLog(`Setting up realtime subscription for chats table: ${channelId}`);

    const chatsChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chats"
        },
        (payload: any) => {
          debugLog("Realtime chat update received:", payload);
          // Callback to update UI based on the payload would be passed
          // from the component when calling this function
        }
      )
      .subscribe((status: string) => {
        debugLog(`Subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, chatsSubscribed: status === "SUBSCRIBED"}));
      });
    
    chatsChannelRef.current = chatsChannel;
    return chatsChannel;
  }, [supabase]);

  // Setup message subscription
  const setupMessageSubscription = useCallback((chatId: string, userId: string, onMessageReceived: (msg: any) => void) => {
    if (!supabase || !chatId || !userId) {
      return;
    }

    // Cleanup previous subscription if exists
    if (messagesChannelRef.current) {
      debugLog("Cleaning up previous message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    const channelId = `chat_messages_${chatId}`;
    debugLog(`Setting up message subscription for chat: ${chatId}`);

    const messagesChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "chat_messages",
          filter: `chat_id=eq.${chatId}`
        },
        (payload: any) => {
          debugLog(`Realtime message update received for chat ${chatId}:`, payload.eventType);
          
          if (payload.eventType === "INSERT") {
            const newMsg = payload.new;
            // Check if message is from another user
            const msgSentByOtherUser = newMsg.user_id && newMsg.user_id !== userId;
            
            // Only notify if message is from another user or pass to the callback in any case
            onMessageReceived(payload);
          }
        }
      )
      .subscribe((status: string) => {
        debugLog(`Message subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, messagesSubscribed: status === "SUBSCRIBED"}));
      });

    messagesChannelRef.current = messagesChannel;
    return messagesChannel;
  }, [supabase]);

  // Cleanup all subscriptions
  const cleanupSubscriptions = useCallback(() => {
    if (chatsChannelRef.current && supabase) {
      debugLog("Cleaning up chats table subscription");
      supabase.removeChannel(chatsChannelRef.current);
      chatsChannelRef.current = null;
    }

    if (messagesChannelRef.current && supabase) {
      debugLog("Cleaning up message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    setSubscriptionStatus({
      chatsSubscribed: false,
      messagesSubscribed: false
    });
  }, [supabase]);

  return {
    setupChatSubscription,
    setupMessageSubscription,
    cleanupSubscriptions,
    subscriptionStatus
  };
};

export default function Chat() {
  const searchParams = useSearchParams()
  const rawWorkspaceId = searchParams.get("workspace")
  const taskId = searchParams.get("task")

  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [user, setUser] = useState<any>(null)
  const [workspace, setWorkspace] = useState<any>(null)
  const [userFullName, setUserFullName] = useState<string>("Du")
  const [messages, setMessages] = useState<Message[]>(initialMessages)
  const [inputValue, setInputValue] = useState("")
  const [isTyping, setIsTyping] = useState(false)
  const [showIceBreakers, setShowIceBreakers] = useState(false)
  const [showModelDropdown, setShowModelDropdown] = useState(false)
  const [selectedModel, setSelectedModel] = useState("gpt-4o")
  const [chatSessions, setChatSessions] = useState<ChatSession[]>([])
  const [currentChatId, setCurrentChatId] = useState<string | null>(null)
  const [tasks, setTasks] = useState<Task[]>([])
  const [selectedTask, setSelectedTask] = useState<Task | null>(null)
  const [showTaskDropdown, setShowTaskDropdown] = useState(false)
  const [showTaskModal, setShowTaskModal] = useState(false)
  const [newTask, setNewTask] = useState<Task>({
    id: "",
    title: "",
    description: "",
    system_prompt: "",
    ai_model: ""
  })
  const [newTaskName, setNewTaskName] = useState("")
  const [newTaskDescription, setNewTaskDescription] = useState("")
  const [newTaskSystemPrompt, setNewTaskSystemPrompt] = useState("")
  const [newTaskModel, setNewTaskModel] = useState("gpt-4o")
  const [showSidebar, setShowSidebar] = useState(true)
  const [typingMessageId, setTypingMessageId] = useState<string | null>(null)
  const [personalWorkspaceId, setPersonalWorkspaceId] = useState<string | null>(
    null
  )
  const [previousSelectedTask, setPreviousSelectedTask] = useState<Task | null>(
    null
  )
  const [previousSelectedModel, setPreviousSelectedModel] = useState<
    string | null
  >(null)
  const [messageUpdatePending, setMessageUpdatePending] = useState(false)
  const [isTaskSwitching, setIsTaskSwitching] = useState(false)
  const [lastMessageUpdate, setLastMessageUpdate] = useState(Date.now())

  // State f√ºr Projekte
  const [projects, setProjects] = useState<Project[]>([])
  const [selectedProject, setSelectedProject] = useState<Project | null>(null)
  const [showProjectDropdown, setShowProjectDropdown] = useState(false)
  const [showProjectModal, setShowProjectModal] = useState(false)
  const [newProjectName, setNewProjectName] = useState("")
  const [newProjectDescription, setNewProjectDescription] = useState("")
  const [projectMenuOpen, setProjectMenuOpen] = useState<string | null>(null)
  const [projectToRename, setProjectToRename] = useState<Project | null>(null)

  // State f√ºr Drag & Drop
  const [draggedChatId, setDraggedChatId] = useState<string | null>(null)
  const [activeDropTarget, setActiveDropTarget] = useState<string | null>(null)

  // State f√ºr aufgeklappte Projekte
  const [expandedProjects, setExpandedProjects] = useState<
    Record<string, boolean>
  >({})

  // State for editing messages
  const [editingMessageId, setEditingMessageId] = useState<string | null>(null)
  const [editingContent, setEditingContent] = useState("")
  
  // State to store original messages during editing
  const [originalMessages, setOriginalMessages] = useState<Message[]>([])

  // Add searchDebounceTimeout ref
  const searchDebounceTimeout = useRef<any>(null)

  const chatBodyRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLTextAreaElement>(null)
  const modelDropdownRef = useRef<HTMLDivElement>(null)
  const taskDropdownRef = useRef<HTMLDivElement>(null)
  const projectDropdownRef = useRef<HTMLDivElement>(null)

  const supabase = createClientComponentClient()

  // Add state for chat menu and rename functionality
  const [chatMenuOpen, setChatMenuOpen] = useState<string | null>(null)
  const [renameModalOpen, setRenameModalOpen] = useState(false)
  const [chatToRename, setChatToRename] = useState<ChatSession | null>(null)
  const [newChatName, setNewChatName] = useState("")
  // Neuer State f√ºr inline edit
  const [editingChatId, setEditingChatId] = useState<string | null>(null)

  const router = useRouter()

  // Add state and refs for the input action menu
  const [showInputMenu, setShowInputMenu] = useState(false)
  const inputMenuRef = useRef<HTMLDivElement>(null)
  const moreOptionsButtonRef = useRef<HTMLButtonElement>(null)

  // F√ºge einen Ref f√ºr die Edit-Box hinzu
  const editBoxRef = useRef<HTMLDivElement>(null)

  // Add state for the new info modal
  // const [showInfoModal, setShowInfoModal] = useState(false)
  // const [modalContent, setModalContent] = useState<InfoItem | null>(null)

  // Add state for React Joyride
  const [runTour, setRunTour] = useState(false)
  const [stepIndex, setStepIndex] = useState(0)

  // State to control showing fake messages during the tour
  const [showFakeMessagesForTour, setShowFakeMessagesForTour] = useState(false)

  // Define fake messages for the tour demonstration
  const fakeTourMessages: Message[] = [
    {
      id: "fake-user-1",
      role: "user",
      content: "Das ist eine Beispiel-Nachricht des Benutzers.",
      timestamp: new Date(Date.now() - 120000) // 2 minutes ago
    },
    {
      id: "fake-ai-message",
      role: "assistant",
      content:
        "Und hier ist eine Beispiel-Antwort der KI. Wenn Sie den Mauszeiger √ºber diese Nachricht bewegen, werden Aktionsbuttons angezeigt.",
      timestamp: new Date(Date.now() - 60000) // 1 minute ago
    }
  ]

  // Add loading state specifically for search
  const [isSearching, setIsSearching] = useState(false)
  // Add chat message search state
  const [searchOpen, setSearchOpen] = useState(false)
  const [messageSearchQuery, setMessageSearchQuery] = useState("")
  const [messageSearchResults, setMessageSearchResults] = useState<any[]>([])

  // New state variables for the export and summary modals
  const [showExportModal, setShowExportModal] = useState(false)
  const [showSummaryModal, setShowSummaryModal] = useState(false)
  const [chatSummary, setChatSummary] = useState("")
  const [isSummarizing, setIsSummarizing] = useState(false)

  // State for showing the message actions dialog
  const [showMessageActionsDialog, setShowMessageActionsDialog] =
    useState(false)
  const [isImprovingPrompt, setIsImprovingPrompt] = useState(false)

  // Add the state for showing settings modal
  const [showSettingsModal, setShowSettingsModal] = useState(false) // Add state for settings modal

  // Add state for storing user names
  const [userNamesMap, setUserNamesMap] = useState<{ [key: string]: string }>(
    {}
  )

  // Neue State-Variable f√ºr die ausgew√§hlte Wissensdatenbank
  const [selectedKnowledgeBaseId, setSelectedKnowledgeBaseId] = useState<
    string[] | null
  >(null)

  // Online-Status-State
  const [isOnline, setIsOnline] = useState<boolean>(true); // Standardm√§√üig annehmen, dass wir online sind

  // Korrekte Typisierung des Refs am Anfang der Komponente
  const initialChatsLoadedRef = useRef(false);
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const isInitializingRef = useRef(false);
  const isStartingNewChatRef = useRef(false);

  // Improved state management for initialization with proper debouncing
  // Add this near the beginning of the component, around line 200-300
  const initializationTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const messageUpdateTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Event-Listener f√ºr Online/Offline-Status
  useEffect(() => {
    // Initialen Status setzen
    setIsOnline(navigator.onLine);
    
    // Handler f√ºr Online/Offline-Events
    const handleOnline = () => {
      console.log("üü¢ Internetverbindung wiederhergestellt");
      setIsOnline(true);
      
      // Optional: Beim Wiederherstellen der Verbindung Daten neu laden
      if (user) {
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        loadChatSessionsMemoized(user.id, workspaceContext);
        loadTasksMemoized(user.id, workspaceContext);
        loadProjectsMemoized(user.id, workspaceContext);
      }
    };
    
    const handleOffline = () => {
      console.log("üî¥ Internetverbindung verloren");
      setIsOnline(false);
    };
    
    // Event-Listener hinzuf√ºgen
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    // Event-Listener beim Unmount entfernen
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [user, rawWorkspaceId, personalWorkspaceId]);
  
  useEffect(() => {
    if (selectedTask && selectedTask.ai_model) {
      setSelectedModel(selectedTask.ai_model)
    }
  }, [selectedTask])

  // UI-Komponente f√ºr Offline-Status 
  const OfflineIndicator = () => {
    if (isOnline) return null;
    
    return (
      <div className="fixed bottom-4 right-4 z-50 rounded-md bg-yellow-600 px-4 py-2 text-white shadow-lg">
        <div className="flex items-center space-x-2">
          <div className="h-2 w-2 rounded-full bg-red-500"></div>
          <span>Offline-Modus - Einige Funktionen sind nicht verf√ºgbar</span>
        </div>
      </div>
    );
  };

  useEffect(() => {
    const fetchPersonalWorkspace = async () => {
      if (user) {
        console.log("Fetching personal workspace for user:", user.id)
        const { data, error } = await supabase
          .from("workspaces")
          .select("id")
          .eq("user_id", user.id)
          .eq("is_home", true)
          .single() // Annahme: Es gibt nur EINEN pers√∂nlichen Workspace

        if (error && error.code !== "PGRST116") {
          // Ignore ' esattamente uma linha esperada'
          console.error("Error fetching personal workspace:", error)
        } else if (data) {
          console.log("Personal workspace found:", data.id)
          setPersonalWorkspaceId(data.id)
        } else {
          console.warn("Personal workspace not found for user:", user.id)
          // Hier k√∂nnte man optional den Workspace erstellen, falls er fehlt
          // oder eine Fehlermeldung anzeigen.
        }
      }
    }
    if (user && !rawWorkspaceId) {
      // Nur laden, wenn kein Workspace in URL und User bekannt
      fetchPersonalWorkspace()
    }
  }, [user, supabase, rawWorkspaceId]) // Abh√§ngigkeiten

  // Optimierte Kontextauswahl mit Caching, besserer Priorisierung und Ausschluss aktueller Nachrichten
  // Cache f√ºr Chat-Sessions um redundante Ladevorg√§nge zu vermeiden
  const chatSessionsCache: {
    sessions: any[] | null
    timestamp: number
    maxAge: number
  } = {
    sessions: null,
    timestamp: 0,
    maxAge: 5000 // Cache ist f√ºr 5 Sekunden g√ºltig
  }

  // Cache f√ºr Projektberechnungen
  const projectsCache: {
    projectChats: Map<string, any[]> | null
    timestamp: number
    maxAge: number
  } = {
    projectChats: null,
    timestamp: 0,
    maxAge: 10000 // Cache ist f√ºr 10 Sekunden g√ºltig
  }

  // Optimierte Funktion zum Laden von Chat-Sessions mit Caching
  const loadChatSessionsWithCache = async (
    userId: string,
    workspaceId: string | null
  ) => {
    const now = Date.now()

    // Pr√ºfen, ob der Cache g√ºltig ist
    if (
      chatSessionsCache.sessions &&
      now - chatSessionsCache.timestamp < chatSessionsCache.maxAge
    ) {
      console.log("üì¶ Verwende gecachte Chat-Sessions")
      return chatSessionsCache.sessions
    }

    console.log(
      `üîÑ Loading chat sessions - userId: ${userId} workspaceId: ${workspaceId}`
    )

    // Lade Daten wie zuvor
    const { data, error } = await supabase
      .from("chats")
      .select("*")
      .eq("user_id", userId)
      .eq("workspace_id", workspaceId)
      .order("updated_at", { ascending: false })

    if (error) {
      console.error("‚ùå Fehler beim Laden der Chat-Sessions:", error)
      return []
    }

    console.log(`‚úÖ Loaded ${data.length} chat sessions`)

    // Verarbeite Daten und speichere sie im Cache
    const formattedSessions = data.map((chat: any) => ({
      id: chat.id,
      name: chat.name || "Neuer Chat",
      timestamp: chat.updated_at,
      message_count: chat.message_count || 0,
      project: chat.project || null,
      temperature: chat.temperature,
      model: chat.model || null
    }))

    // Cache aktualisieren
    chatSessionsCache.sessions = formattedSessions
    chatSessionsCache.timestamp = now

    return formattedSessions
  }

  // Optimierte Funktion zur Projektberechnung mit Caching
  const recalculateProjectsWithCache = (chats: any[]) => {
    const now = Date.now()

    // Pr√ºfen, ob der Cache g√ºltig ist
    if (
      projectsCache.projectChats &&
      now - projectsCache.timestamp < projectsCache.maxAge
    ) {
      return projectsCache.projectChats
    }

    console.log(
      `üî¢ Berechne Projekte neu aus ${chats.length} verf√ºgbaren Chats`
    )

    const projectChats = new Map()

    // Projekte berechnen wie zuvor
    const availableProjects = [
      ...new Set(chats.filter(c => c.project).map(c => c.project))
    ]

    availableProjects.forEach(project => {
      const chatsInProject = chats.filter(c => c.project === project)
      projectChats.set(project, chatsInProject)
      console.log(`üóÇÔ∏è Projekt ${project} hat ${chatsInProject.length} Chats`)
    })

    // Cache aktualisieren
    projectsCache.projectChats = projectChats
    projectsCache.timestamp = now

    return projectChats
  }

  // Hauptfunktion f√ºr die Kontext-Suche, verbessert mit Ausschluss der aktuellen Nachricht
  const findSimilarMessagesOptimized = async (
    userId: string,
    query: string,
    currentMessageId: string | null = null
  ) => {
    debugLog(`üîç Suche nach √§hnlichen Nachrichten f√ºr User ${userId}`);
    debugLog(`üìù Suchanfrage: "${query}"`);

    // Skip search for very short queries to reduce database load
    if (query.trim().length < 3) {
      debugLog("‚è© √úberspringe Suche f√ºr zu kurze Anfrage (weniger als 3 Zeichen)");
      return [];
    }

    // Validiere userId
    if (!userId || typeof userId !== "string" || userId.trim() === "") {
      console.error("‚ùå Ung√ºltige userId f√ºr die Suche:", userId);
      return [];
    }

    try {
      // Erstelle ein tempor√§res Nachrichtenobjekt f√ºr das Embedding
      const tempQueryMessage = {
        content: query,
        id: "query", // Diese ID wird nicht in der DB gespeichert
        role: "user" as "user", // Explizit typisieren
        timestamp: new Date()
      };

      // Erstelle Embedding f√ºr die Anfrage
      debugLog(`üß† Generiere Embedding f√ºr Suchanfrage...`);

      try {
        // Direkter Aufruf der Embedding-API als tempor√§rer Ersatz f√ºr createEmbedding
        debugLog("üì® Original Nachrichteninhalt:", tempQueryMessage.content);
        const currentDate = new Date().toISOString().split("T")[0];
        const contentWithDate = `[Datum: ${currentDate}]\n${tempQueryMessage.content}`;
        
        const response = await fetch("/api/embeddings", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            input: contentWithDate
          })
        });
        
        if (!response.ok) {
          throw new Error(`Embedding API responded with ${response.status}`);
        }
        
        const embeddingData = await response.json();
        const embedding = embeddingData.embedding;

        if (!embedding) {
          console.error("‚ùå Fehler beim Generieren des Embeddings f√ºr die Suche");
          return [];
        }

        debugLog(`‚úÖ Embedding f√ºr Abfrage erfolgreich generiert`);
        debugLog(`üìä Query-Embedding-Dimensionen: ${embedding.length}`);
        
        // Adjust similarity threshold based on query length
        const dynamicThreshold = query.length < 10 ? 0.75 : 0.65;
        const maxResults = query.length < 10 ? 10 : 20;
        
        debugLog(
          `üìû Rufe search_similar_messages RPC f√ºr User ${userId} auf (Schwellwert: ${dynamicThreshold}, Max Ergebnisse: ${maxResults})`
        );

        // RPC f√ºr die √Ñhnlichkeitssuche aufrufen
        const { data: results, error } = await supabase.rpc(
          "search_similar_messages",
          {
            p_user_id: userId,
            query_embedding: embedding,
            similarity_threshold: dynamicThreshold, // Use dynamic threshold
            max_results: maxResults
          }
        );

        if (error) {
          console.error("‚ùå Fehler bei der RPC-Suche nach √§hnlichen Nachrichten:", error);
          return [];
        }

        debugLog(`üîé RPC Ergebnis: ${results?.length || 0} Nachrichten gefunden`);
        
        if (!results || results.length === 0) {
          return [];
        }
        
        if (DEBUG_MODE) {
          debugLog(`üìã Erste Ergebnisse (Rohdaten): ${JSON.stringify(results?.slice(0, 2) || [])}`);
        }

        // Filtere die aktuelle Nachricht, falls vorhanden
        let filteredResults = results || [];
        if (currentMessageId) {
          const originalLength = filteredResults.length;
          filteredResults = filteredResults.filter(
            (msg: any) => msg.message_id !== currentMessageId
          );
          if (originalLength !== filteredResults.length) {
            debugLog(`üßπ Aktuelle Nachricht mit ID ${currentMessageId} aus Ergebnissen ausgeschlossen`);
          }
        }

        // Schnellere Verarbeitung der Datumsangaben ohne √ºberm√§√üiges Logging
        for (const msg of filteredResults) {
          // Generiere eine anzeigbare Version des Inhalts ohne Datum
          msg.displayContent = msg.content;
          if (msg.content && typeof msg.content === 'string' && msg.content.startsWith('[Datum:') && msg.content.includes(']\n')) {
            msg.displayContent = msg.content.replace(/^\[Datum:[^\]]+\]\n/, '');
          }
          
          // Extrahiere Datum aus dem Nachrichteninhalt, aber logge nicht jede Nachricht
          const dateMatch = msg.content?.match(/\[Datum: ([^\]]+)\]/);
          msg.dateInfo = dateMatch ? dateMatch[1] : null;
        }

        debugLog(`‚úÖ ${filteredResults.length} √§hnliche Nachrichten nach Filterung gefunden`);

        return filteredResults;
      } catch (error) {
        console.error("‚ùå Fehler beim Erstellen des Embeddings:", error);
        return [];
      }
    } catch (error) {
      console.error("‚ùå Fehler bei der Suche nach √§hnlichen Nachrichten:", error);
      return [];
    }
  };

  // Verbesserte Kontext-Auswahlfunktion mit optimierter Bewertung f√ºr neueste/√§lteste Nachrichten
  const prepareContextMessage = (contextContent: string) => {
    return {
      role: "system",
      content: `Relevanter Kontext aus fr√ºheren Gespr√§chen:\n\n${contextContent}\n\nDies sind Ausschnitte aus vorherigen Konversationen, die f√ºr die aktuelle Frage relevant sein k√∂nnten. Die mit "neueste Information" markierten Abschnitte enthalten den aktuellsten Stand zu diesem Thema, w√§hrend "erste Erw√§hnung" historischen Kontext bietet. Nutze diese Informationen, um eine informierte Antwort zu geben, besonders wenn der Benutzer sich auf bereits besprochene Themen bezieht.`
    }
  }

  const loadChatSessions = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      console.log(
        "üîÑ Loading chat sessions - userId:",
        userId,
        "workspaceId:",
        workspaceId
      )

      // Verwende personalWorkspaceId als Fallback, wenn keine workspaceId √ºbergeben wird
      const targetWorkspaceId = workspaceId || personalWorkspaceId

      // Build the query
      let query = supabase
        .from("chats")
        .select(
          "id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id"
        )

      // Properly handle null workspace IDs
      if (targetWorkspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Chats in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq("workspace_id", targetWorkspaceId)
      } else {
        // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is("workspace_id", null).eq("user_id", userId)
      }

      const { data, error } = await query.order("last_message_timestamp", {
        ascending: false
      })

      if (error) {
        console.error("‚ùå Error loading chat sessions:", error)
        setError(`Fehler beim Laden der Chats: ${error.message}`)
        throw error
      }

      if (data) {
        console.log("‚úÖ Loaded", data.length, "chat sessions")
        console.log("Chat data:", data) // Debug: Zeige die Chat-Daten

        const formattedSessions = data.map((chat: any) => ({
          id: chat.id || "",
          name: chat.name || "Unnamed Chat",
          created_at: chat.created_at || new Date().toISOString(),
          last_message_timestamp: chat.last_message_timestamp,
          user_id: chat.user_id, // Behalte user_id um den Ersteller anzuzeigen
          ...(chat.description && { description: chat.description }),
          project_id: chat.project_id
        }))

        console.log("Formatted sessions:", formattedSessions) // Debug: Zeige die formatierten Sessions
        setChatSessions(formattedSessions)
      } else {
        console.log("‚ÑπÔ∏è No chat sessions found")
        setChatSessions([])
      }
    } catch (err) {
      console.error("‚ùå Error in loadChatSessions:", err)
      setChatSessions([])
    }
  }

  const createNewChat = async () => {
    try {
      if (!user) {
        setError("Sie m√ºssen angemeldet sein, um einen Chat zu erstellen.")
        return null
      }

      // Determine the workspace ID to use - simplify this logic
      const workspaceId = rawWorkspaceId || personalWorkspaceId

      if (!workspaceId) {
        setError(
          "Konnte keinen g√ºltigen Arbeitsbereich zum Erstellen des Chats finden."
        )
        return null
      }

      console.log(`Creating new chat in workspace: ${workspaceId}`)

      // Create a new chat with a temporary name - we'll update it later
      const newChatId = uuidv4()
      const initialTitle = "Neuer Chat"

      // Create with retry to ensure it succeeds
      const { data: newChat, error } = await supabase
        .from("chats")
        .insert({
          id: newChatId,
          user_id: user.id,
          name: initialTitle,
          workspace_id: workspaceId,
          created_at: new Date().toISOString(),
          last_message_timestamp: new Date().toISOString()
        })
        .select()
        .single()

      if (error) {
        console.error(`‚ùå Error creating new chat: ${error.message}`)
        setError(`Fehler beim Erstellen des Chats: ${error.message}`)
        return null
      }

      if (!newChat) {
        console.error("‚ùå No chat data returned after creation")
        setError("Fehler beim Erstellen des Chats: Keine Daten zur√ºckgegeben")
        return null
      }

      console.log(`‚úÖ Successfully created new chat with ID: ${newChatId}`)

      // Set the current chat ID immediately
      setCurrentChatId(newChatId)

      // Wait for the database to properly register the new chat
      await new Promise(resolve => setTimeout(resolve, 300))

      // Reload chat sessions to update UI
      if (user) {
        await loadChatSessions(user.id, workspaceId)
      }

      return newChatId
    } catch (err) {
      console.error("Error in createNewChat:", err)
      setError(
        `Fehler beim Erstellen des Chats: ${err instanceof Error ? err.message : "Unbekannter Fehler"}`
      )
      return null
    }
  }

  const loadChat = async (chatId: string) => {
    try {
      setCurrentChatId(chatId)

      // Try to get chat details first to confirm it exists
      const { data: chatData, error: chatError } = await supabase
        .from("chats")
        .select("id, name")
        .eq("id", chatId)
        .single()

      if (chatError) {
        console.error("Error fetching chat details:", chatError)
        return
      }

      // Get chat messages - now only using chat_id
      const { data: messagesData, error: messagesError } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (messagesError) {
        console.error("Error fetching chat messages:", messagesError)
        setMessages([])
        return
      }

      if (messagesData && messagesData.length > 0) {
        // Transform to our Message format
        const transformedMessages = messagesData.map((msg: any) => ({
          id: uuidv4(),
          role: msg.role as "user" | "assistant" | "system",
          content: msg.content,
          timestamp: new Date(msg.created_at),
          user_id: msg.user_id, // Store user_id from database
          sentfrom: msg.sentfrom // Store sentfrom from database
        }))

        setMessages(transformedMessages)
        console.log(
          `Loaded ${transformedMessages.length} messages for chat ${chatId}`
        )

        // Fetch usernames for all unique user_ids in messages
        const userIds = [
          ...new Set(
            transformedMessages
              .filter(msg => msg.role === "user" && msg.user_id)
              .map(msg => msg.user_id)
          )
        ]

        if (userIds.length > 0) {
          const { data: profilesData, error: profilesError } = await supabase
            .from("profiles")
            .select("id, full_name")
            .in("id", userIds)

          if (profilesError) {
            console.error("Error fetching user profiles:", profilesError)
          } else if (profilesData) {
            // Create a map of user_id to full_name
            const userNames: { [key: string]: string } = {}
            profilesData.forEach(profile => {
              userNames[profile.id] = profile.full_name
            })
            setUserNamesMap(userNames)
          }
        }
      } else {
        console.log(`No messages found for chat ${chatId}`)
        setMessages([])
      }
    } catch (err) {
      console.error("Error loading chat:", err)
      setMessages([])
    }
  }

  const loadTasks = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status pr√ºfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - √úberspringe Laden der Tasks");
        return; // Fr√ºher Abbruch bei fehlender Internetverbindung
      }

      // Timeout f√ºr die Anfrage setzen, um lange h√§ngende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("tasks").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Tasks in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufr√§umen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedTasks = data.map(task => ({
            ...task,
            title: task.title || task.name,
            ai_model: task.ai_model || task.preferred_model || "gpt-4o"
          }));
          setTasks(formattedTasks);
        }
      } catch (fetchError: any) {
        // Timeout aufr√§umen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Pr√ºfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Task-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Tasks - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading tasks:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu √ºberfluten
      // Wenn die Seite neu geladen wird, wird ein neuer Versuch unternommen
    }
  };

  const loadProjects = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status pr√ºfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - √úberspringe Laden der Projekte");
        return; // Fr√ºher Abbruch bei fehlender Internetverbindung
      }

      // Timeout f√ºr die Anfrage setzen, um lange h√§ngende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("projects").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Projekte in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufr√§umen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedProjects = data.map(project => ({
            ...project,
            name: project.name || project.title,
            workspace_id:
              project.workspace_id || project.preferred_workspace_id || "gpt-4o"
          }));
          setProjects(formattedProjects);
        }
      } catch (fetchError: any) {
        // Timeout aufr√§umen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Pr√ºfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Project-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Projekte - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading projects:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu √ºberfluten
    }
  };

  // Wenn ein user (per Link Sharing) einen spezifischen Chat betritt, dann direkt laden
  useEffect(() => {
    // Lade alle verf√ºgbaren Tasks als Optionen
    if (user) {
      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
      loadTasks(user.id, workspaceContext)
    }

    // Wenn eine Task-ID in der URL ist, lade diese Task
    if (taskId) {
      console.log("Task ID in URL gefunden:", taskId)
      const fetchTask = async () => {
        if (!supabase) return

        const { data, error } = await supabase
          .from("tasks")
          .select("*")
          .eq("id", taskId)
          .single()

        if (error) {
          console.error("Fehler beim Laden der Task:", error)
          return
        }

        if (data) {
          console.log("Task geladen:", data)
          setSelectedTask(data)
          setSelectedModel(data.ai_model || "gpt-4o")
        }
      }

      fetchTask()
    }
  }, [user, taskId, supabase, rawWorkspaceId, personalWorkspaceId, loadTasks])

  // Effect f√ºr die Textareabehandlung
  useEffect(() => {
    const textarea = inputRef.current
    if (textarea) {
      // Reset height - wichtig, um zu verhindern, dass es nur nach oben w√§chst
      textarea.style.height = "auto"
      // Setze die neue H√∂he basierend auf dem Scroll-H√∂hen-Wert
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`
    }
  }, [inputValue])

  // Reduziere unn√∂tige Re-Renders durch Memoization der Lade-Funktionen
  const loadChatSessionsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadChatSessions(userId, workspaceId);
    },
    [supabase, setChatSessions]
  );
  
  const loadChatMemoized = useCallback(
    async (chatId: string) => {
      return await loadChat(chatId);
    },
    [supabase, user, setMessages, setUserNamesMap]
  );
  
  const loadTasksMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadTasks(userId, workspaceId);
    },
    [supabase, setTasks]
  );
  
  const loadProjectsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadProjects(userId, workspaceId);
    },
    [supabase, setProjects]
  );

  // Haupt-Initialisierungscode f√ºr den Chat
  useEffect(() => {
    // Zeitsperre, um zu h√§ufige Aufrufe zu verhindern
    const checkSession = async () => {
      // Vermeide mehrfache gleichzeitige Initialisierungen
      if (isInitializingRef.current) {
        debugLog("Initialization already in progress, skipping");
        return;
      }
      
      isInitializingRef.current = true;
      try {
        setLoading(true);

        // Pr√ºfe, ob der Benutzer angemeldet ist
        const {
          data: { session }
        } = await supabase.auth.getSession();

        if (!session) {
          console.log("No session found, redirecting to login");
          router.push("/login");
          return;
        }

        // Benutzer ist angemeldet
        setUser(session.user);

        // Profilnamen laden (nicht kritisch f√ºr Initialisierung)
        if (!userFullName || userFullName === "Du") {
          try {
            const { data: profileData } = await supabase
              .from("profiles")
              .select("full_name")
              .eq("id", session.user.id)
              .single();

            if (profileData?.full_name) {
              setUserFullName(profileData.full_name);
            }
          } catch (profileError) {
            console.error("Error loading user profile:", profileError);
          }
        }

        debugLog(`*** Session exists, user: ${session.user.id}`);

        // Workspace-Kontext bestimmen
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        debugLog("Current workspace context:", workspaceContext);

        // Chats nur laden, wenn n√∂tig
        if (workspaceContext && !initialChatsLoadedRef.current && chatSessions.length === 0) {
          debugLog("Loading chat sessions for the first time");
          // Use Promise.all to load data in parallel
          await Promise.all([
            loadChatSessionsMemoized(session.user.id, workspaceContext),
            loadProjectsMemoized(session.user.id, workspaceContext)
          ]);
          initialChatsLoadedRef.current = true;
        }

        // Wenn ein Chat bereits in state ist, lade ihn
        if (currentChatId) {
          debugLog("Chat ID in state bereits vorhanden:", currentChatId);
          await loadChatMemoized(currentChatId);
        } else if (chatSessions.length > 0 && !messages.length && !isStartingNewChatRef.current) {
          // Sonst lade den ersten Chat, aber nur wenn:
          // - keine Nachrichten bereits geladen sind 
          // - UND kein expliziter Neustart eines Chats angefordert wurde
          debugLog("Lade den ersten Chat aus vorhandenen Sessions:", chatSessions[0].id);
          setCurrentChatId(chatSessions[0].id);
          await loadChatMemoized(chatSessions[0].id);
        } else if (isStartingNewChatRef.current) {
          debugLog("Neuer Chat wurde explizit angefordert - lade keinen vorhandenen Chat");
          // Flag zur√ºcksetzen nach Verwendung
          isStartingNewChatRef.current = false;
        }

        // Tasks laden (wenn noch nicht geladen)
        if (tasks.length === 0 && workspaceContext) {
          await loadTasksMemoized(session.user.id, workspaceContext);
        }

        // Icebreakers zeigen, wenn keine Nachrichten vorhanden
        if (messages.length === 0) {
          setShowIceBreakers(true);
        }

        // Task laden, wenn eine ID √ºbergeben wurde
        if (taskId && (!selectedTask || selectedTask.id !== taskId)) {
          const { data: taskData, error } = await supabase
            .from("tasks")
            .select("*")
            .eq("id", taskId)
            .single();

          if (!error && taskData) {
            debugLog("Task geladen:", taskData);
            setSelectedTask(taskData);
            setSelectedModel(taskData.ai_model || selectedModel);
          }
        }
      } catch (err: any) {
        console.error("Chat init error:", err);
        setError(err.message);
      } finally {
        setLoading(false);
        
        // Use setTimeout to avoid race conditions when setting isInitializingRef
        if (initializationTimeoutRef.current) {
          clearTimeout(initializationTimeoutRef.current);
        }
        
        initializationTimeoutRef.current = setTimeout(() => {
          isInitializingRef.current = false;
          debugLog("Initialization flag reset to false");
          initializationTimeoutRef.current = null;
        }, 100);
      }
    };

    checkSession();
    
    // Cleanup function
    return () => {
      if (initializationTimeoutRef.current) {
        clearTimeout(initializationTimeoutRef.current);
      }
      if (messageUpdateTimeoutRef.current) {
        clearTimeout(messageUpdateTimeoutRef.current);
      }
    };
  }, [
    supabase,
    currentChatId,
    personalWorkspaceId,
    rawWorkspaceId,
    router,
    taskId
  ]);

  /* eslint-disable react-hooks/rules-of-hooks */
  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        modelDropdownRef.current &&
        !modelDropdownRef.current.contains(event.target as Node)
      ) {
        setShowModelDropdown(false)
      }

      if (
        taskDropdownRef.current &&
        !taskDropdownRef.current.contains(event.target as Node)
      ) {
        setShowTaskDropdown(false)
      }

      // Schlie√üe Chat-Men√º bei Klick au√üerhalb
      const chatMenuTarget = (event.target as Element)?.closest(
        "[data-chat-menu]"
      )
      if (chatMenuOpen && !chatMenuTarget) {
        setChatMenuOpen(null)
      }

      // Schlie√üe Projekt-Men√º bei Klick au√üerhalb
      const projectMenuTarget = (event.target as Element)?.closest(
        "[data-project-menu]"
      )
      if (projectMenuOpen && !projectMenuTarget) {
        setProjectMenuOpen(null)
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [chatMenuOpen, projectMenuOpen])

  // Haupt-Funktion zum Senden einer Nachricht an die API
  const sendMessageToAPI = async (
    messages: Message[],
    model: string,
    chatId: string
  ) => {
    console.log(`üîÑ sendMessageToAPI v2 aufgerufen mit Chat-ID: ${chatId}`);

    const userId = user?.id;
    if (!userId) {
      console.error("‚ùå User ID fehlt beim Senden an API.");
      throw new Error("User ID ist erforderlich");
    }

    // 1. DATEN SAMMELN (wie bisher)
    // --------------------------------
    console.log(`üë§ Hole Benutzerprofil f√ºr User ID: ${userId}`);
    const { data: fetchedUserProfile, error: profileError } = await supabase
        .from("profiles")
        .select("*")
      .eq("id", userId)
      .single();
      
    // Use fetchedUserProfile instead of the state variable userProfile directly here
    // to ensure we have the latest data for this specific call.
    if (profileError) console.error("Fehler beim Abrufen des Profils:", profileError);
    else console.log("‚úÖ Benutzerprofil erfolgreich abgerufen");

    const lastUserMessage = [...messages].reverse().find(m => m.role === "user");
    let knowledgeResults: any[] = [];
    let similarMessages: any[] = []; // Assuming this holds structured QA or relevant snippets
    // (SelectedTask comes from component state)
    const currentSelectedTask = selectedTask; // Capture state at the time of call

    if (lastUserMessage) {
        const userQuery = lastUserMessage.content;
        
        // Wissensdatenbank-Suche (falls KB ausgew√§hlt)
        if (selectedKnowledgeBaseId && selectedKnowledgeBaseId.length > 0) { 
            try {
                console.log(`üß† Performing knowledge base search for KBs: ${selectedKnowledgeBaseId.join(', ')}...`);
                const { data: authData } = await supabase.auth.getSession();
                const authToken = authData?.session?.access_token;

                // Alle Ergebnisse aus allen ausgew√§hlten Wissensdatenbanken sammeln
                let allKnowledgeResults: any[] = [];
                
                // Sequentiell durch alle ausgew√§hlten Wissensdatenbanken gehen
                for (const kbId of selectedKnowledgeBaseId) {
                    const knowledgeResponse = await fetch("/api/knowledge/search", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            query: userQuery,
                            knowledge_base_id: kbId,
                            auth_token: authToken
                        })
                    });
                    
                    if (knowledgeResponse.ok) {
                        const knowledgeData = await knowledgeResponse.json();
                        const results = knowledgeData.results || [];
                        console.log(`üß† Found ${results.length} raw knowledge items from KB ${kbId}.`);
                        allKnowledgeResults.push(...results);
                    } else {
                        console.error(`‚ö†Ô∏è Knowledge base search failed for KB ${kbId}:`, knowledgeResponse.statusText);
                    }
                }
                
                // Sortiere alle Ergebnisse nach Relevanz (falls ein similarity-Feld existiert)
                knowledgeResults = allKnowledgeResults.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));
                console.log(`üß† Combined ${knowledgeResults.length} total knowledge items from all KBs.`);
          
            } catch (knowledgeError) {
                console.error("‚ùå Error during knowledge base search fetch:", knowledgeError);
            }
        } else {
            console.log("‚ÑπÔ∏è Keine Wissensdatenbank ausgew√§hlt, √ºberspringe Suche.");
        }
        
        // Suche nach √§hnlichen Nachrichten (wie bisher)
        try {
            console.log(`üîç Suche nach User-weiten Kontext f√ºr User ${userId}, basierend auf: ${userQuery.substring(0, 30)}...`);
            // Assuming findSimilarMessagesOptimized returns the structured data needed
            similarMessages = await findSimilarMessagesOptimized(userId, userQuery, lastUserMessage.id) || [];
            console.log(`‚úÖ ${similarMessages.length} √§hnliche Nachrichten gefunden`);
             // Log details of similar messages structure if needed for debugging
             // console.log("Similar messages structure:", JSON.stringify(similarMessages.slice(0,2), null, 2));
        } catch (error) {
            console.error("‚ùå Fehler bei der Suche nach √§hnlichen Nachrichten:", error);
        }

    } else {
      console.warn("Keine letzte Benutzernachricht gefunden, kann keinen Kontext generieren.");
      // Handle case where there's somehow no user message? Maybe return early or send without context.
    }
    
    // KONSOLIDIERTE PROMPT-ERSTELLUNG MIT DEM NEUEN PROMPT-BUILDER
    // -------------------------------------------
    const userInput = lastUserMessage ? lastUserMessage.content : "";
    
    // Verwende den neuen buildPrompt statt manueller Zusammensetzung
    const finalPrompt = buildPrompt({
      userInput,
      chatId,
      taskPrompt: currentSelectedTask?.system_prompt || null,
      // Verwende den aus prompt-builder.ts importierten DEFAULT_SYSTEM_PROMPT 
      // Das systemPrompt muss hier nicht explizit √ºbergeben werden, da es den DEFAULT_SYSTEM_PROMPT nutzt
      userProfile: fetchedUserProfile,
      knowledgeResults,
      pastMessages: similarMessages,
      allMessages: messages,
      modelType: "default", // Standard-Chat
      maxPastMessages: 4,
      maxKnowledgeResults: 3
    });
    
    console.log(`üì© Sende an API: ${messages.filter(m => m.role !== 'system').length} User/Assistant Nachrichten, ${finalPrompt.length - messages.filter(m => m.role !== 'system').length} System/Assistant Kontextobjekt(e)`);
    console.log("Final apiMessages array (V2) before API call:", JSON.stringify(finalPrompt, null, 2));
    
    // API CALL MIT STREAMING
    // --------------------------------------------------
    try {
        const apiUrl = `/api/chat?model=${encodeURIComponent(model)}&chatId=${encodeURIComponent(chatId)}`;
        
        // Streaming aktivieren
        const streaming = true;
        
        if (streaming) {
          // Streaming Anfrage mit benutzerdefinierten Parametern
          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              messages: finalPrompt,
              streaming: true
            })
          });
          
          if (!response.ok) {
            const errorBody = await response.text();
            console.error("API Error Response Body:", errorBody);
            throw new Error(`API responded with ${response.status}`);
          }

          // Stream verarbeiten
          const reader = response.body?.getReader();
          if (!reader) throw new Error("Stream reader not available");
          
          const decoder = new TextDecoder();
          let fullContent = "";
          let metaInfo = null;
          
          // Event-basierter Streaming-Modus (gibt Text-Chunks zur√ºck w√§hrend sie ankommen)
          return {
            content: "", // Wird unten schrittweise gef√ºllt
            streamContent: async function* () {
              let buffer = ""; // Puffer f√ºr eingehende Chunks
              const decoder = new TextDecoder();
              let accumulatedJsonRemainder = ""; // Buffer for incomplete JSON chunks

              try {
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) {
                    // Yield any remaining buffer content when the stream ends
                    if (buffer.length > 0) {
                      yield buffer;
                      // fullContent is already updated progressively
                    }
                     // Yield any remaining JSON remainder if it's valid text
                    if (accumulatedJsonRemainder.length > 0 && !accumulatedJsonRemainder.startsWith('{')) {
                       yield accumulatedJsonRemainder;
                    }
                    break;
                  }

                  const rawChunk = decoder.decode(value, { stream: true });
                  accumulatedJsonRemainder += rawChunk;

                  let textToProcess = "";
                  let processFromIndex = 0;

                  // Attempt to parse JSON if it looks like it might be JSON
                  if (accumulatedJsonRemainder.includes('{') && accumulatedJsonRemainder.includes('}')) {
                      try {
                          // Find potential JSON boundary more robustly
                          let potentialJsonEnd = accumulatedJsonRemainder.lastIndexOf('}') + 1;
                          let potentialJson = accumulatedJsonRemainder.substring(0, potentialJsonEnd);
                          
                          // Basic check if it looks like a valid JSON object
                          if (potentialJson.startsWith('{')) {
                              const parsed = JSON.parse(potentialJson);
                              if (parsed && typeof parsed.content === 'string') {
                                  textToProcess = parsed.content;
                                  // Update fullContent only with the actual text part
                                  fullContent += textToProcess;
                                  // Remove the processed JSON part from the remainder
                                  accumulatedJsonRemainder = accumulatedJsonRemainder.substring(potentialJsonEnd);
                                  processFromIndex = 0; // Start processing the new text from beginning
                              } else {
                                 // Valid JSON but not the expected format, treat accumulated as text
                                 textToProcess = accumulatedJsonRemainder;
                                 fullContent += textToProcess; // Add raw chunk to fullContent
                                 accumulatedJsonRemainder = ""; // Clear remainder
                      }
    } else {
                             // Doesn't start with '{', treat as raw text
                             textToProcess = accumulatedJsonRemainder;
                             fullContent += textToProcess; // Add raw chunk to fullContent
                             accumulatedJsonRemainder = ""; // Clear remainder
                        }
                      } catch (e) {
                          // Invalid JSON or incomplete chunk, wait for more data or treat as text if stream ends
                          // Continue accumulating, do not process buffer yet unless it's very long
                          if (accumulatedJsonRemainder.length > 1000) { // Process as text if buffer gets too long
                               textToProcess = accumulatedJsonRemainder;
                               fullContent += textToProcess; // Add raw chunk to fullContent
                               accumulatedJsonRemainder = ""; // Clear remainder
                      }
                    }
    } else {
                     // Does not contain braces, likely raw text
                     textToProcess = accumulatedJsonRemainder;
                     fullContent += textToProcess; // Add raw chunk to fullContent
                     accumulatedJsonRemainder = ""; // Clear remainder
                  }
                  
                  // If we extracted text (either from JSON or raw chunk), add to buffer and yield words
                  if (textToProcess) {
                    buffer += textToProcess;

                    // Process the buffer to yield whole words/segments
                    let lastDelimiterPos = -1;
                    const lastSpacePos = buffer.lastIndexOf(' ');
                    const lastNewlinePos = buffer.lastIndexOf('\\n');
                    lastDelimiterPos = Math.max(lastSpacePos, lastNewlinePos);

                    if (lastDelimiterPos !== -1) {
                      const partToYield = buffer.substring(0, lastDelimiterPos + 1);
                      if (partToYield.length > 0) {
                           yield partToYield;
                      }
                      buffer = buffer.substring(lastDelimiterPos + 1);
                    }
                  }
                }
              } catch (error) {
                console.error("Error reading stream:", error);
                if (buffer.length > 0) yield buffer;
                if (accumulatedJsonRemainder.length > 0) yield accumulatedJsonRemainder;
                throw error;
              } finally {
                this.content = fullContent;
              }
            },
            getContent: () => fullContent,
            model: model
          };
        } else {
          // Nicht-Streaming-Modus (f√ºr Fallback)
      const apiResponse = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
              messages: finalPrompt
        })
        });

      if (!apiResponse.ok) {
            // Log response body if available
            const errorBody = await apiResponse.text();
            console.error("API Error Response Body:", errorBody);
            throw new Error(`API responded with ${apiResponse.status}`);
        }

        const data = await apiResponse.json();
        return data; // R√ºckgabe an den Aufrufer (handleSendMessage)
        }
    } catch (error) {
        console.error("‚ùå Fehler beim API-Aufruf in sendMessageToAPI:", error);
        throw error; // Fehler weitergeben, damit handleSendMessage ihn fangen kann
    }
  }  // Ende von sendMessageToAPI

  const handleTypewriterComplete = (messageId: string) => {
    const updatedMessages = messages.map(m =>
      m.id === messageId ? { ...m, isTypewriting: false } : m
    )
    setMessages(updatedMessages)
    setTypingMessageId(null)
  }

  const handleCreateTask = async () => {
    if (!newTaskName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || null

      const { data, error } = await supabase
        .from("tasks")
        .insert({
          title: newTaskName,
          description: newTaskDescription,
          system_prompt: newTaskSystemPrompt,
          ai_model: newTaskModel,
          status: "todo",
          priority: "medium",
          user_id: user.id,
          workspace_id: workspaceContext
        })
        .select()

      if (error) throw error

      await loadTasks(user.id, workspaceContext)

      setShowTaskModal(false)
      setNewTaskName("")
      setNewTaskDescription("")
      setNewTaskSystemPrompt("")
      setNewTaskModel("gpt-4o")
    } catch (err) {
      console.error("Error creating task:", err)
    } finally {
      setLoading(false)
    }
  }

  const handleCreateProject = async () => {
    if (!newProjectName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null

      // ---> START DEBUG LOG <---
      console.log("--- Creating Project --- ")
      console.log("User ID to send:", user?.id)
      console.log("Raw Workspace ID from URL:", rawWorkspaceId)
      console.log("Personal Workspace ID state:", personalWorkspaceId)
      console.log("Workspace Context to send:", workspaceContext)
      // ---> END DEBUG LOG <---

      // ---> ADDED AUTH CHECK <---
      const { data: authData, error: authError } =
        await supabase.auth.getSession()
      console.log("--- Auth Check Before Insert ---")
      console.log("Current Session:", authData?.session)
      console.log("Session User ID:", authData?.session?.user?.id)
      console.log("Auth Error:", authError)
      if (authError || !authData?.session) {
        console.error("CRITICAL: No valid session before insert!")
        // Optionally: Prevent the insert or show an error to the user
        // return;
      }
      // ---> END AUTH CHECK <---

      // ---> ADDED DIAGNOSTIC FUNCTION <---
      // This immediately runs when you click "Create Project" in the UI
      // It helps diagnose why the workspace membership check fails
      console.log("--- Running Diagnostic Function ---")
      const diagResult = await supabase.rpc("diagnose_workspace_membership", {
        p_user_id: user.id,
        p_workspace_id: workspaceContext
      })
      console.log("Diagnosis Result:", diagResult)
      // Explicit logging of the important diagnostic data
      console.log("MEMBERSHIP DATA:", JSON.stringify(diagResult.data, null, 2))
      if (diagResult.data) {
        console.log("User ID Input:", diagResult.data.user_id_input)
        console.log("Workspace ID Input:", diagResult.data.workspace_id_input)
        console.log("Membership Exists:", diagResult.data.membership_exists)
        console.log("Membership Count:", diagResult.data.membership_count)
        console.log("All User Workspaces:", diagResult.data.all_user_workspaces)
        console.log(
          "All Workspace Members:",
          diagResult.data.all_workspace_members
        )
      }
      // ---> END DIAGNOSTIC FUNCTION <---

      // Use the database function instead of direct table access
      // This bypasses RLS issues while maintaining security checks in the function
      const { data, error } = await supabase.rpc("create_project", {
        p_name: newProjectName,
        p_description: newProjectDescription,
        p_user_id: user.id,
        p_workspace_id: workspaceContext,
        p_color: "#4c4cff",
        p_status: "active"
      })

      if (error) throw error

      await loadProjects(user.id, workspaceContext)
      setShowProjectModal(false)
      setNewProjectName("")
      setNewProjectDescription("")
    } catch (err) {
      console.error("Error creating project:", err)
    } finally {
      setLoading(false)
    }
  }

  // Generate a chat name from the first user message
  const generateChatName = (message: string): string => {
    // Split the message into words
    const words = message.trim().split(/\s+/)

    // Get up to the first 3 words
    const firstThreeWords = words.slice(0, 3).join(" ")

    // If the result is too short, use "Neuer Chat"
    return firstThreeWords.length >= 3 ? firstThreeWords : "Neuer Chat"
  }

  // Modifiziere den useEffect f√ºr Task-Wechsel
  useEffect(() => {
    // Only perform task change operations if no message update is pending
    // And ensure at least 500ms has passed since the last message update
    const timeSinceLastUpdate = Date.now() - lastMessageUpdate
    if (messageUpdatePending || timeSinceLastUpdate < 500) {
      console.log(
        "Message update in progress or too recent, deferring task change handling"
      )
      return
    }

    const handleTaskOrModelChange = async () => {
      // Pr√ºfen, ob es sich um einen Task- oder Modellwechsel handelt
      const isTaskChange = selectedTask?.id !== previousSelectedTask?.id
      // const isModelChange = selectedModel !== previousSelectedModel && !selectedTask;

      // Run this logic ONLY on task change, not on simple model selection
      if (isTaskChange && messages.length > 0) {
        // Wenn eine Task oder ein Modell gewechselt wurde und es Nachrichten gibt

        console.log("Task wurde gewechselt, erstelle Zusammenfassung...")

        try {
          // Pr√ºfe, ob bereits eine Zusammenfassung im Chat existiert
          const lastSummaryMessage = [...messages]
            .reverse()
            .find(
              msg =>
                msg.role === "assistant" &&
                (msg.content.includes("Chat-Zusammenfassung") ||
                  msg.content.includes("Hauptpunkte:") ||
                  msg.content.includes("Zusammenfassung des Chats"))
            )

          let summary: string

          if (lastSummaryMessage) {
            // Verwende die vorhandene Zusammenfassung
            console.log("Verwende vorhandene Zusammenfassung")
            summary = lastSummaryMessage.content
          } else {
            // Erstelle eine neue Zusammenfassung, da keine vorhanden ist
            console.log("√úberspringe Zusammenfassung f√ºr Task-Wechsel (DEBUG)")
            summary = "" // Tempor√§r deaktiviert
          }

          if (summary) {
            // Erstelle eine neue System-Nachricht mit der Zusammenfassung
            const summarySystemMessage: Message = {
              id: uuidv4(),
              role: "system",
              content: `Zusammenfassung des bisherigen Gespr√§chs: ${summary}

${selectedTask ? selectedTask.system_prompt : "Fahre mit dem Gespr√§ch fort, basierend auf dieser Zusammenfassung."}`,
              timestamp: new Date()
            }

            // Entferne alle bisherigen System-Nachrichten
            const filteredMessages = messages.filter(m => m.role !== "system")

            // F√ºge die neue System-Nachricht am Anfang hinzu
            setMessages([summarySystemMessage, ...filteredMessages])

            console.log(
              "Zusammenfassung wurde als System-Nachricht hinzugef√ºgt."
            )

            // Task-switching notification message is REMOVED
          }
        } catch (error) {
          console.error("Error in task change handling:", error)
        } finally {
          // Always set isTaskSwitching to false when complete
          setIsTaskSwitching(false)
        }
      } else {
        // If there's no task change or no messages, just reset the switching state
        setIsTaskSwitching(false)
      }

      // Aktuelle Task und Modell f√ºr den n√§chsten Vergleich speichern
      setPreviousSelectedTask(selectedTask)
      setPreviousSelectedModel(selectedModel)
    }

    handleTaskOrModelChange()
  }, [
    selectedTask,
    selectedModel,
    messages,
    messageUpdatePending,
    previousSelectedTask,
    previousSelectedModel,
    lastMessageUpdate
  ])

  // Add this function to sync messages with the database when needed
  const syncMessagesWithDatabase = async (chatId: string) => {
    if (!chatId) return

    try {
      console.log("Syncing messages with database for chat:", chatId)
      const { data, error } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (error) {
        console.error("Error syncing messages:", error)
        return
      }

      if (data) {
        // Convert database messages to app message format
        const formattedMessages: Message[] = data.map(dbMsg => ({
          id: dbMsg.id || uuidv4(),
          role: dbMsg.role as "user" | "assistant" | "system",
          content: dbMsg.content,
          timestamp: new Date(dbMsg.created_at)
        }))

        console.log(`Synced ${formattedMessages.length} messages from database`)
        setMessages(formattedMessages)
      }
    } catch (error) {
      console.error("Error in syncMessagesWithDatabase:", error)
    }
  }

  // Modify handleSendMessage to optionally include web search results
  const handleSendMessage = async (
    message: string,
    includeWebSearch: boolean = false
  ) => {
    if (message.trim().length === 0) return
    if (isTyping || messageUpdatePending || isTaskSwitching) return

    // Markieren, dass der Benutzer mit dem Tippen begonnen hat
    setHasStartedTyping(true)

    const userMessageId = uuidv4()
    const newMessage: Message = {
      id: userMessageId,
      role: "user",
      content: message,
      timestamp: new Date(),
      user_id: user?.id,
      sentfrom: userFullName
    }

    console.log("Creating new message with user_id:", user?.id)

    try {
      // Prevent task switching effects during message sending
      setMessageUpdatePending(true)
      setLastMessageUpdate(Date.now())

      // Create the new array *before* setting state
      const newMessagesArray = [...messages, newMessage]

      // Add user message to state immediately for better UX
      setMessages(newMessagesArray) // Use the new array
      setInputValue("") // Eingabefeld leeren

      // Show typing indicator
      setIsTyping(true)

      // If web search is requested, perform it before sending to API
      let webSearchResults = null
      if (includeWebSearch) {
        setIsSearching(true)
        try {
          webSearchResults = await performSerpApiSearch(message)
          console.log("Web search results:", webSearchResults.length)
        } catch (searchError) {
          console.error("Error during web search:", searchError)
        } finally {
          setIsSearching(false)
        }
      }

      let chatIdToUse = currentChatId

      // If no current chat exists, create a new one before proceeding
      if (!chatIdToUse) {
        console.log(
          "No current chat, creating new one before sending message..."
        )
        chatIdToUse = await createNewChat()
        if (!chatIdToUse) {
          throw new Error("Failed to create a new chat")
        }
        console.log(`Successfully created new chat with ID: ${chatIdToUse}`)
        // Set current chat ID immediately to ensure context is maintained
        setCurrentChatId(chatIdToUse)
      }

      // Speichern der Benutzernachricht in der Datenbank
      console.log(`Saving message to chat ID: ${chatIdToUse}`)

      // Wichtig: Wir ben√∂tigen diese Nachrichts-ID f√ºr Embedding
      let dbMessageId = null;

      try {
      const { data: messageData, error: messageError } = await retryOperation(
        async () => {
          return await supabase
            .from("chat_messages")
            .insert({
              chat_id: chatIdToUse,
              role: "user",
                content: message,
              user_id: user?.id,
              sentfrom: userFullName,
              created_at: newMessage.timestamp.toISOString()
            })
            .select()
        },
        3,
        1000
        );

      if (messageError) {
        console.error("‚ùå Error saving message:", messageError)
      } else {
        console.log("‚úÖ Message saved successfully to database", messageData)
          // Speichere die ID f√ºr sp√§tere Verwendung
        if (messageData && messageData.length > 0) {
            dbMessageId = messageData[0].id;
          }
        }
      } catch (saveError) {
        console.error("Error saving user message:", saveError);
        // Wir setzen den Prozess fort, auch wenn die Nachricht nicht gespeichert werden konnte
      }

      // Vorbereiten und Senden der Anfrage an die API
      try {
        const modelToUse = selectedTask?.ai_model || selectedModel
        console.log("üì£ Sende Nachricht an API mit Chat-ID:", chatIdToUse)
        console.log("üîÑ Ausgew√§hltes Modell f√ºr diese Anfrage:", modelToUse);

        // Streaming-Response
        const response = await sendMessageToAPI(
          newMessagesArray,
          modelToUse,
          chatIdToUse
        )

        // Assistentennachricht erstellen und anzeigen (vorerst leer)
        const assistantMessageId = uuidv4()
        const assistantMessage: Message = {
          id: assistantMessageId,
          role: "assistant",
          content: "", // Startinhalt ist leer, wird nach und nach gef√ºllt
          timestamp: new Date(),
          isTypewriting: true // Ensure this is set to true
        }

        // Calculate whether to show the effect
        const showEffect = assistantMessage.role === "assistant" && (assistantMessage.isTypewriting || typingMessageId === assistantMessage.id);

        // Modifiziere die AssistentMessage-Creation f√ºr mehr Konsistenz
        const assistantMessage: Message = {
          id: assistantMessageId,
          role: "assistant",
          content: "", // Startinhalt ist leer, wird nach und nach gef√ºllt
          timestamp: new Date(),
          isTypewriting: true // Stelle sicher, dass dies immer auf true gesetzt ist
        };

        // Add to messages immediately to show the placeholder
        setMessages(prevMessages => [...prevMessages, assistantMessage])
        setTypingMessageId(assistantMessageId) // Track the message ID that's being typed

        // Wenn Streaming-Antwort verf√ºgbar ist, nutze diese
        if (response.streamContent) {
"use client"

import React from "react"
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs"
import { useEffect, useRef, useState, useMemo, useCallback } from "react"
import { useSearchParams } from "next/navigation"
import Link from "next/link"
import {
  ChevronLeft,
  Menu,
  Plus,
  Send,
  ChevronDown,
  Copy,
  RotateCcw,
  Edit,
  Paperclip,
  Image,
  Search,
  MoreVertical,
  Trash,
  X,
  FlaskConical,
  MoreHorizontal,
  Mic,
  Loader,
  FileText,
  FileDown,
  BookOpen,
  User,
  Settings,
  Home,
  ChevronRight,
  MessageCircle,
  Sparkles,
  Check
} from "lucide-react" // Added Icons
import ReactMarkdown from "react-markdown"
import remarkGfm from "remark-gfm"
import { v4 as uuidv4 } from "uuid"
import { TypewriterEffect } from "@/components/typewriter-effect"
import { RevealEffect } from "@/components/reveal-effect"; // Import RevealEffect
import { useRouter } from "next/navigation"
import { cn } from "@/lib/utils"
import Joyride, { Step, CallBackProps, STATUS } from "react-joyride" // Import Joyride
import dynamic from "next/dynamic" // Import dynamic
import {
  performSerpApiSearch,
  formatSearchResults,
  formatSearchResultsForAI
} from "../utils/serpApi"
import { downloadChatAsPdf } from "../utils/pdfExport"
import { generateChatSummary } from "../utils/chatSummary"
import ExportModal from "../components/ExportModal"
import SummaryModal from "../components/SummaryModal"
// Drag-and-Drop-Bibliotheken
import {
  DndContext,
  useDraggable,
  useDroppable,
  useSensors,
  useSensor,
  PointerSensor
} from "@dnd-kit/core"
import LoadingIndicator from "@/components/LoadingIndicator" // Corrected import path
import SettingsModal from "@/app/components/SettingsModal" // Import the SettingsModal component
import { KnowledgeBaseSelector } from "@/components/knowledge/KnowledgeBaseSelector"
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter"
import { oneDark } from "react-syntax-highlighter/dist/cjs/styles/prism"
import { MessageMarkdown } from "@/components/message-markdown"
import { MessageCodeBlock } from "@/components/message-code-block"
import { buildPrompt, DEFAULT_SYSTEM_PROMPT } from "@/lib/prompt-builder"

// Dynamically import Joyride with SSR disabled
const DynamicJoyride = dynamic(() => import("react-joyride"), { ssr: false })

// Define a simpler interface for CodeProps
interface CodeProps {
  node?: any
  inline?: boolean
  className?: string
  children?: React.ReactNode
}

interface Message {
  id: string
  role: "user" | "assistant" | "system"
  content: string
  timestamp: Date
  isTypewriting?: boolean
  user_id?: string // Add user_id to track message sender
  sentfrom?: string // Add sentfrom to store user name directly
}

interface ChatSession {
  id: string
  name: string
  created_at: string
  description?: string
  project_id?: string | null
  last_message_timestamp?: string
  user_id?: string
}

interface Task {
  id: string
  title: string
  description: string
  system_prompt: string
  ai_model: string
  created_at?: string
  updated_at?: string
  user_id?: string
  workspace_id?: string | null
  project_id?: string | null
}

interface Project {
  id: string
  name: string
  description?: string
  user_id: string
  workspace_id?: string | null
  chats?: ChatSession[] // Chats, die zu diesem Projekt geh√∂ren
}

// Define structure for info items (used for buttons, tour content can be different)
interface InfoItem {
  title: string
  // We'll define tour steps separately now
}

// Keep infoItems simple for the buttons
const infoItems: InfoItem[] = [
  { title: "Tasks nutzen" },
  { title: "KI-Modell wechseln" },
  { title: "Nachrichten bearbeiten & neu generieren" },
  { title: "Chats verwalten" }
]

const initialMessages: Message[] = []

// Define Tour Steps (Adjust step 3)
const tourSteps: Step[] = [
  {
    target: "#task-select-button",
    content: (
      <>
        <p className="mb-2">
          Mit Tasks k√∂nnen Sie der KI spezifische Anweisungen oder eine
          bestimmte Rolle f√ºr den gesamten Chat zuweisen.
        </p>
        <p>
          Klicken Sie hier, um einen vorhandenen Task zu w√§hlen oder einen neuen
          zu erstellen. Tasks √ºberschreiben die manuelle Modellauswahl.
        </p>
      </>
    ),
    placement: "bottom-end",
    title: "Tasks nutzen"
  },
  {
    target: "#model-select-button",
    content: (
      <>
        <p className="mb-2 text-sm">
          W√§hlen Sie hier das KI-Modell, wenn kein Task aktiv ist:
        </p>
        <ul className="mb-2 ml-4 list-inside list-disc space-y-1 text-sm">
          <li>
            <strong>Basic (GPT-4o):</strong> Ausgewogen.
          </li>
          <li>
            <strong>Fast (GPT-4o mini):</strong> Schnell & G√ºnstig.
          </li>
          <li>
            <strong>Reason (GPT-4 Vision):</strong> Leistungsstark.
          </li>
        </ul>
      </>
    ),
    placement: "bottom-end",
    title: "KI-Modell wechseln"
  },
  {
    target: "#chat-sidebar",
    content:
      "Hier verwalten Sie Ihre Chats: Neuen Chat erstellen (+), Chat ausw√§hlen, umbenennen oder l√∂schen (√ºber die drei Punkte).",
    placement: "right",
    title: "Chats verwalten"
  },
  {
    target: "#new-chat-button",
    content: "Klicken Sie hier, um einen neuen, leeren Chat zu beginnen.",
    placement: "left",
    title: "Neuer Chat",
    disableScrolling: true,
    disableOverlayClose: true,
    spotlightPadding: 5
  },
  {
    target: "#chat-input-textarea",
    content:
      "Geben Sie hier Ihre Nachricht ein und dr√ºcken Sie Enter oder klicken Sie auf den Senden-Button.",
    placement: "top",
    title: "Nachricht senden"
  }
]

// Helper function to fix the columns handling consistently
const getColumnNames = (columns: any[] | null): string[] => {
  return columns
    ? columns.map((col: { column_name: string }) => col.column_name)
    : []
}

// Detect and format HTML code
const formatCodeInMessage = (content: string): string => {
  // If content already has markdown code blocks, don't modify
  if (content.includes("```")) return content;
  
  // Check if the content appears to be HTML
  if (
    content.trim().startsWith("<") && 
    (content.includes("<!DOCTYPE") || 
     content.includes("<html") ||
     (content.includes("<body") && content.includes("</body>")) ||
     (content.includes("<head") && content.includes("</head>")))
  ) {
    return "```html\n" + content + "\n```";
  }
  
  return content;
};

// This is a standalone component for code blocks

// ---> HILFSFUNKTIONEN f√ºr V2 Prompt <--- 
function trimText(txt: string | null | undefined, maxWords = 60): string {
  if (!txt) return "";
  const words = txt.trim().split(/\s+/);
  if (words.length <= maxWords) return txt;
  return words.slice(0, maxWords).join(" ") + " ‚Ä¶";
}

// V2 System Prompt Definition - entfernt, da jetzt zentral in prompt-builder.ts definiert
// const systemPrompt = `...`.trim();
// ---> ENDE HILFSFUNKTIONEN f√ºr V2 Prompt <--- 

// Add debugging flag at the top of the file, after imports
const DEBUG_MODE = false; // Set to true to enable verbose logging

// Replace console.log with debug-aware logging function
const debugLog = (...args: any[]) => {
  if (DEBUG_MODE) {
    console.log(...args);
  }
};

// Add this custom hook for subscription management
// Place it outside the component, before export default function Chat()
const useSubscriptions = (supabase: any) => {
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const [subscriptionStatus, setSubscriptionStatus] = useState({
    chatsSubscribed: false,
    messagesSubscribed: false
  });

  // Setup chat subscription
  const setupChatSubscription = useCallback((userId: string) => {
    if (!supabase || !userId || chatsChannelRef.current) {
      return;
    }

    const channelId = `chats_updates_global`;
    debugLog(`Setting up realtime subscription for chats table: ${channelId}`);

    const chatsChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chats"
        },
        (payload: any) => {
          debugLog("Realtime chat update received:", payload);
          // Callback to update UI based on the payload would be passed
          // from the component when calling this function
        }
      )
      .subscribe((status: string) => {
        debugLog(`Subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, chatsSubscribed: status === "SUBSCRIBED"}));
      });
    
    chatsChannelRef.current = chatsChannel;
    return chatsChannel;
  }, [supabase]);

  // Setup message subscription
  const setupMessageSubscription = useCallback((chatId: string, userId: string, onMessageReceived: (msg: any) => void) => {
    if (!supabase || !chatId || !userId) {
      return;
    }

    // Cleanup previous subscription if exists
    if (messagesChannelRef.current) {
      debugLog("Cleaning up previous message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    const channelId = `chat_messages_${chatId}`;
    debugLog(`Setting up message subscription for chat: ${chatId}`);

    const messagesChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "chat_messages",
          filter: `chat_id=eq.${chatId}`
        },
        (payload: any) => {
          debugLog(`Realtime message update received for chat ${chatId}:`, payload.eventType);
          
          if (payload.eventType === "INSERT") {
            const newMsg = payload.new;
            // Check if message is from another user
            const msgSentByOtherUser = newMsg.user_id && newMsg.user_id !== userId;
            
            // Only notify if message is from another user or pass to the callback in any case
            onMessageReceived(payload);
          }
        }
      )
      .subscribe((status: string) => {
        debugLog(`Message subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, messagesSubscribed: status === "SUBSCRIBED"}));
      });

    messagesChannelRef.current = messagesChannel;
    return messagesChannel;
  }, [supabase]);

  // Cleanup all subscriptions
  const cleanupSubscriptions = useCallback(() => {
    if (chatsChannelRef.current && supabase) {
      debugLog("Cleaning up chats table subscription");
      supabase.removeChannel(chatsChannelRef.current);
      chatsChannelRef.current = null;
    }

    if (messagesChannelRef.current && supabase) {
      debugLog("Cleaning up message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    setSubscriptionStatus({
      chatsSubscribed: false,
      messagesSubscribed: false
    });
  }, [supabase]);

  return {
    setupChatSubscription,
    setupMessageSubscription,
    cleanupSubscriptions,
    subscriptionStatus
  };
};

export default function Chat() {
  const searchParams = useSearchParams()
  const rawWorkspaceId = searchParams.get("workspace")
  const taskId = searchParams.get("task")

  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [user, setUser] = useState<any>(null)
  const [workspace, setWorkspace] = useState<any>(null)
  const [userFullName, setUserFullName] = useState<string>("Du")
  const [messages, setMessages] = useState<Message[]>(initialMessages)
  const [inputValue, setInputValue] = useState("")
  const [isTyping, setIsTyping] = useState(false)
  const [showIceBreakers, setShowIceBreakers] = useState(false)
  const [showModelDropdown, setShowModelDropdown] = useState(false)
  const [selectedModel, setSelectedModel] = useState("gpt-4o")
  const [chatSessions, setChatSessions] = useState<ChatSession[]>([])
  const [currentChatId, setCurrentChatId] = useState<string | null>(null)
  const [tasks, setTasks] = useState<Task[]>([])
  const [selectedTask, setSelectedTask] = useState<Task | null>(null)
  const [showTaskDropdown, setShowTaskDropdown] = useState(false)
  const [showTaskModal, setShowTaskModal] = useState(false)
  const [newTask, setNewTask] = useState<Task>({
    id: "",
    title: "",
    description: "",
    system_prompt: "",
    ai_model: ""
  })
  const [newTaskName, setNewTaskName] = useState("")
  const [newTaskDescription, setNewTaskDescription] = useState("")
  const [newTaskSystemPrompt, setNewTaskSystemPrompt] = useState("")
  const [newTaskModel, setNewTaskModel] = useState("gpt-4o")
  const [showSidebar, setShowSidebar] = useState(true)
  const [typingMessageId, setTypingMessageId] = useState<string | null>(null)
  const [personalWorkspaceId, setPersonalWorkspaceId] = useState<string | null>(
    null
  )
  const [previousSelectedTask, setPreviousSelectedTask] = useState<Task | null>(
    null
  )
  const [previousSelectedModel, setPreviousSelectedModel] = useState<
    string | null
  >(null)
  const [messageUpdatePending, setMessageUpdatePending] = useState(false)
  const [isTaskSwitching, setIsTaskSwitching] = useState(false)
  const [lastMessageUpdate, setLastMessageUpdate] = useState(Date.now())

  // State f√ºr Projekte
  const [projects, setProjects] = useState<Project[]>([])
  const [selectedProject, setSelectedProject] = useState<Project | null>(null)
  const [showProjectDropdown, setShowProjectDropdown] = useState(false)
  const [showProjectModal, setShowProjectModal] = useState(false)
  const [newProjectName, setNewProjectName] = useState("")
  const [newProjectDescription, setNewProjectDescription] = useState("")
  const [projectMenuOpen, setProjectMenuOpen] = useState<string | null>(null)
  const [projectToRename, setProjectToRename] = useState<Project | null>(null)

  // State f√ºr Drag & Drop
  const [draggedChatId, setDraggedChatId] = useState<string | null>(null)
  const [activeDropTarget, setActiveDropTarget] = useState<string | null>(null)

  // State f√ºr aufgeklappte Projekte
  const [expandedProjects, setExpandedProjects] = useState<
    Record<string, boolean>
  >({})

  // State for editing messages
  const [editingMessageId, setEditingMessageId] = useState<string | null>(null)
  const [editingContent, setEditingContent] = useState("")
  
  // State to store original messages during editing
  const [originalMessages, setOriginalMessages] = useState<Message[]>([])

  // Add searchDebounceTimeout ref
  const searchDebounceTimeout = useRef<any>(null)

  const chatBodyRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLTextAreaElement>(null)
  const modelDropdownRef = useRef<HTMLDivElement>(null)
  const taskDropdownRef = useRef<HTMLDivElement>(null)
  const projectDropdownRef = useRef<HTMLDivElement>(null)

  const supabase = createClientComponentClient()

  // Add state for chat menu and rename functionality
  const [chatMenuOpen, setChatMenuOpen] = useState<string | null>(null)
  const [renameModalOpen, setRenameModalOpen] = useState(false)
  const [chatToRename, setChatToRename] = useState<ChatSession | null>(null)
  const [newChatName, setNewChatName] = useState("")
  // Neuer State f√ºr inline edit
  const [editingChatId, setEditingChatId] = useState<string | null>(null)

  const router = useRouter()

  // Add state and refs for the input action menu
  const [showInputMenu, setShowInputMenu] = useState(false)
  const inputMenuRef = useRef<HTMLDivElement>(null)
  const moreOptionsButtonRef = useRef<HTMLButtonElement>(null)

  // F√ºge einen Ref f√ºr die Edit-Box hinzu
  const editBoxRef = useRef<HTMLDivElement>(null)

  // Add state for the new info modal
  // const [showInfoModal, setShowInfoModal] = useState(false)
  // const [modalContent, setModalContent] = useState<InfoItem | null>(null)

  // Add state for React Joyride
  const [runTour, setRunTour] = useState(false)
  const [stepIndex, setStepIndex] = useState(0)

  // State to control showing fake messages during the tour
  const [showFakeMessagesForTour, setShowFakeMessagesForTour] = useState(false)

  // Define fake messages for the tour demonstration
  const fakeTourMessages: Message[] = [
    {
      id: "fake-user-1",
      role: "user",
      content: "Das ist eine Beispiel-Nachricht des Benutzers.",
      timestamp: new Date(Date.now() - 120000) // 2 minutes ago
    },
    {
      id: "fake-ai-message",
      role: "assistant",
      content:
        "Und hier ist eine Beispiel-Antwort der KI. Wenn Sie den Mauszeiger √ºber diese Nachricht bewegen, werden Aktionsbuttons angezeigt.",
      timestamp: new Date(Date.now() - 60000) // 1 minute ago
    }
  ]

  // Add loading state specifically for search
  const [isSearching, setIsSearching] = useState(false)
  // Add chat message search state
  const [searchOpen, setSearchOpen] = useState(false)
  const [messageSearchQuery, setMessageSearchQuery] = useState("")
  const [messageSearchResults, setMessageSearchResults] = useState<any[]>([])

  // New state variables for the export and summary modals
  const [showExportModal, setShowExportModal] = useState(false)
  const [showSummaryModal, setShowSummaryModal] = useState(false)
  const [chatSummary, setChatSummary] = useState("")
  const [isSummarizing, setIsSummarizing] = useState(false)

  // State for showing the message actions dialog
  const [showMessageActionsDialog, setShowMessageActionsDialog] =
    useState(false)
  const [isImprovingPrompt, setIsImprovingPrompt] = useState(false)

  // Add the state for showing settings modal
  const [showSettingsModal, setShowSettingsModal] = useState(false) // Add state for settings modal

  // Add state for storing user names
  const [userNamesMap, setUserNamesMap] = useState<{ [key: string]: string }>(
    {}
  )

  // Neue State-Variable f√ºr die ausgew√§hlte Wissensdatenbank
  const [selectedKnowledgeBaseId, setSelectedKnowledgeBaseId] = useState<
    string[] | null
  >(null)

  // Online-Status-State
  const [isOnline, setIsOnline] = useState<boolean>(true); // Standardm√§√üig annehmen, dass wir online sind

  // Korrekte Typisierung des Refs am Anfang der Komponente
  const initialChatsLoadedRef = useRef(false);
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const isInitializingRef = useRef(false);
  const isStartingNewChatRef = useRef(false);

  // Improved state management for initialization with proper debouncing
  // Add this near the beginning of the component, around line 200-300
  const initializationTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const messageUpdateTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Event-Listener f√ºr Online/Offline-Status
  useEffect(() => {
    // Initialen Status setzen
    setIsOnline(navigator.onLine);
    
    // Handler f√ºr Online/Offline-Events
    const handleOnline = () => {
      console.log("üü¢ Internetverbindung wiederhergestellt");
      setIsOnline(true);
      
      // Optional: Beim Wiederherstellen der Verbindung Daten neu laden
      if (user) {
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        loadChatSessionsMemoized(user.id, workspaceContext);
        loadTasksMemoized(user.id, workspaceContext);
        loadProjectsMemoized(user.id, workspaceContext);
      }
    };
    
    const handleOffline = () => {
      console.log("üî¥ Internetverbindung verloren");
      setIsOnline(false);
    };
    
    // Event-Listener hinzuf√ºgen
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    // Event-Listener beim Unmount entfernen
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [user, rawWorkspaceId, personalWorkspaceId]);
  
  useEffect(() => {
    if (selectedTask && selectedTask.ai_model) {
      setSelectedModel(selectedTask.ai_model)
    }
  }, [selectedTask])

  // UI-Komponente f√ºr Offline-Status 
  const OfflineIndicator = () => {
    if (isOnline) return null;
    
    return (
      <div className="fixed bottom-4 right-4 z-50 rounded-md bg-yellow-600 px-4 py-2 text-white shadow-lg">
        <div className="flex items-center space-x-2">
          <div className="h-2 w-2 rounded-full bg-red-500"></div>
          <span>Offline-Modus - Einige Funktionen sind nicht verf√ºgbar</span>
        </div>
      </div>
    );
  };

  useEffect(() => {
    const fetchPersonalWorkspace = async () => {
      if (user) {
        console.log("Fetching personal workspace for user:", user.id)
        const { data, error } = await supabase
          .from("workspaces")
          .select("id")
          .eq("user_id", user.id)
          .eq("is_home", true)
          .single() // Annahme: Es gibt nur EINEN pers√∂nlichen Workspace

        if (error && error.code !== "PGRST116") {
          // Ignore ' esattamente uma linha esperada'
          console.error("Error fetching personal workspace:", error)
        } else if (data) {
          console.log("Personal workspace found:", data.id)
          setPersonalWorkspaceId(data.id)
        } else {
          console.warn("Personal workspace not found for user:", user.id)
          // Hier k√∂nnte man optional den Workspace erstellen, falls er fehlt
          // oder eine Fehlermeldung anzeigen.
        }
      }
    }
    if (user && !rawWorkspaceId) {
      // Nur laden, wenn kein Workspace in URL und User bekannt
      fetchPersonalWorkspace()
    }
  }, [user, supabase, rawWorkspaceId]) // Abh√§ngigkeiten

  // Optimierte Kontextauswahl mit Caching, besserer Priorisierung und Ausschluss aktueller Nachrichten
  // Cache f√ºr Chat-Sessions um redundante Ladevorg√§nge zu vermeiden
  const chatSessionsCache: {
    sessions: any[] | null
    timestamp: number
    maxAge: number
  } = {
    sessions: null,
    timestamp: 0,
    maxAge: 5000 // Cache ist f√ºr 5 Sekunden g√ºltig
  }

  // Cache f√ºr Projektberechnungen
  const projectsCache: {
    projectChats: Map<string, any[]> | null
    timestamp: number
    maxAge: number
  } = {
    projectChats: null,
    timestamp: 0,
    maxAge: 10000 // Cache ist f√ºr 10 Sekunden g√ºltig
  }

  // Optimierte Funktion zum Laden von Chat-Sessions mit Caching
  const loadChatSessionsWithCache = async (
    userId: string,
    workspaceId: string | null
  ) => {
    const now = Date.now()

    // Pr√ºfen, ob der Cache g√ºltig ist
    if (
      chatSessionsCache.sessions &&
      now - chatSessionsCache.timestamp < chatSessionsCache.maxAge
    ) {
      console.log("üì¶ Verwende gecachte Chat-Sessions")
      return chatSessionsCache.sessions
    }

    console.log(
      `üîÑ Loading chat sessions - userId: ${userId} workspaceId: ${workspaceId}`
    )

    // Lade Daten wie zuvor
    const { data, error } = await supabase
      .from("chats")
      .select("*")
      .eq("user_id", userId)
      .eq("workspace_id", workspaceId)
      .order("updated_at", { ascending: false })

    if (error) {
      console.error("‚ùå Fehler beim Laden der Chat-Sessions:", error)
      return []
    }

    console.log(`‚úÖ Loaded ${data.length} chat sessions`)

    // Verarbeite Daten und speichere sie im Cache
    const formattedSessions = data.map((chat: any) => ({
      id: chat.id,
      name: chat.name || "Neuer Chat",
      timestamp: chat.updated_at,
      message_count: chat.message_count || 0,
      project: chat.project || null,
      temperature: chat.temperature,
      model: chat.model || null
    }))

    // Cache aktualisieren
    chatSessionsCache.sessions = formattedSessions
    chatSessionsCache.timestamp = now

    return formattedSessions
  }

  // Optimierte Funktion zur Projektberechnung mit Caching
  const recalculateProjectsWithCache = (chats: any[]) => {
    const now = Date.now()

    // Pr√ºfen, ob der Cache g√ºltig ist
    if (
      projectsCache.projectChats &&
      now - projectsCache.timestamp < projectsCache.maxAge
    ) {
      return projectsCache.projectChats
    }

    console.log(
      `üî¢ Berechne Projekte neu aus ${chats.length} verf√ºgbaren Chats`
    )

    const projectChats = new Map()

    // Projekte berechnen wie zuvor
    const availableProjects = [
      ...new Set(chats.filter(c => c.project).map(c => c.project))
    ]

    availableProjects.forEach(project => {
      const chatsInProject = chats.filter(c => c.project === project)
      projectChats.set(project, chatsInProject)
      console.log(`üóÇÔ∏è Projekt ${project} hat ${chatsInProject.length} Chats`)
    })

    // Cache aktualisieren
    projectsCache.projectChats = projectChats
    projectsCache.timestamp = now

    return projectChats
  }

  // Hauptfunktion f√ºr die Kontext-Suche, verbessert mit Ausschluss der aktuellen Nachricht
  const findSimilarMessagesOptimized = async (
    userId: string,
    query: string,
    currentMessageId: string | null = null
  ) => {
    debugLog(`üîç Suche nach √§hnlichen Nachrichten f√ºr User ${userId}`);
    debugLog(`üìù Suchanfrage: "${query}"`);

    // Skip search for very short queries to reduce database load
    if (query.trim().length < 3) {
      debugLog("‚è© √úberspringe Suche f√ºr zu kurze Anfrage (weniger als 3 Zeichen)");
      return [];
    }

    // Validiere userId
    if (!userId || typeof userId !== "string" || userId.trim() === "") {
      console.error("‚ùå Ung√ºltige userId f√ºr die Suche:", userId);
      return [];
    }

    try {
      // Erstelle ein tempor√§res Nachrichtenobjekt f√ºr das Embedding
      const tempQueryMessage = {
        content: query,
        id: "query", // Diese ID wird nicht in der DB gespeichert
        role: "user" as "user", // Explizit typisieren
        timestamp: new Date()
      };

      // Erstelle Embedding f√ºr die Anfrage
      debugLog(`üß† Generiere Embedding f√ºr Suchanfrage...`);

      try {
        // Direkter Aufruf der Embedding-API als tempor√§rer Ersatz f√ºr createEmbedding
        debugLog("üì® Original Nachrichteninhalt:", tempQueryMessage.content);
        const currentDate = new Date().toISOString().split("T")[0];
        const contentWithDate = `[Datum: ${currentDate}]\n${tempQueryMessage.content}`;
        
        const response = await fetch("/api/embeddings", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            input: contentWithDate
          })
        });
        
        if (!response.ok) {
          throw new Error(`Embedding API responded with ${response.status}`);
        }
        
        const embeddingData = await response.json();
        const embedding = embeddingData.embedding;

        if (!embedding) {
          console.error("‚ùå Fehler beim Generieren des Embeddings f√ºr die Suche");
          return [];
        }

        debugLog(`‚úÖ Embedding f√ºr Abfrage erfolgreich generiert`);
        debugLog(`üìä Query-Embedding-Dimensionen: ${embedding.length}`);
        
        // Adjust similarity threshold based on query length
        const dynamicThreshold = query.length < 10 ? 0.75 : 0.65;
        const maxResults = query.length < 10 ? 10 : 20;
        
        debugLog(
          `üìû Rufe search_similar_messages RPC f√ºr User ${userId} auf (Schwellwert: ${dynamicThreshold}, Max Ergebnisse: ${maxResults})`
        );

        // RPC f√ºr die √Ñhnlichkeitssuche aufrufen
        const { data: results, error } = await supabase.rpc(
          "search_similar_messages",
          {
            p_user_id: userId,
            query_embedding: embedding,
            similarity_threshold: dynamicThreshold, // Use dynamic threshold
            max_results: maxResults
          }
        );

        if (error) {
          console.error("‚ùå Fehler bei der RPC-Suche nach √§hnlichen Nachrichten:", error);
          return [];
        }

        debugLog(`üîé RPC Ergebnis: ${results?.length || 0} Nachrichten gefunden`);
        
        if (!results || results.length === 0) {
          return [];
        }
        
        if (DEBUG_MODE) {
          debugLog(`üìã Erste Ergebnisse (Rohdaten): ${JSON.stringify(results?.slice(0, 2) || [])}`);
        }

        // Filtere die aktuelle Nachricht, falls vorhanden
        let filteredResults = results || [];
        if (currentMessageId) {
          const originalLength = filteredResults.length;
          filteredResults = filteredResults.filter(
            (msg: any) => msg.message_id !== currentMessageId
          );
          if (originalLength !== filteredResults.length) {
            debugLog(`üßπ Aktuelle Nachricht mit ID ${currentMessageId} aus Ergebnissen ausgeschlossen`);
          }
        }

        // Schnellere Verarbeitung der Datumsangaben ohne √ºberm√§√üiges Logging
        for (const msg of filteredResults) {
          // Generiere eine anzeigbare Version des Inhalts ohne Datum
          msg.displayContent = msg.content;
          if (msg.content && typeof msg.content === 'string' && msg.content.startsWith('[Datum:') && msg.content.includes(']\n')) {
            msg.displayContent = msg.content.replace(/^\[Datum:[^\]]+\]\n/, '');
          }
          
          // Extrahiere Datum aus dem Nachrichteninhalt, aber logge nicht jede Nachricht
          const dateMatch = msg.content?.match(/\[Datum: ([^\]]+)\]/);
          msg.dateInfo = dateMatch ? dateMatch[1] : null;
        }

        debugLog(`‚úÖ ${filteredResults.length} √§hnliche Nachrichten nach Filterung gefunden`);

        return filteredResults;
      } catch (error) {
        console.error("‚ùå Fehler beim Erstellen des Embeddings:", error);
        return [];
      }
    } catch (error) {
      console.error("‚ùå Fehler bei der Suche nach √§hnlichen Nachrichten:", error);
      return [];
    }
  };

  // Verbesserte Kontext-Auswahlfunktion mit optimierter Bewertung f√ºr neueste/√§lteste Nachrichten
  const prepareContextMessage = (contextContent: string) => {
    return {
      role: "system",
      content: `Relevanter Kontext aus fr√ºheren Gespr√§chen:\n\n${contextContent}\n\nDies sind Ausschnitte aus vorherigen Konversationen, die f√ºr die aktuelle Frage relevant sein k√∂nnten. Die mit "neueste Information" markierten Abschnitte enthalten den aktuellsten Stand zu diesem Thema, w√§hrend "erste Erw√§hnung" historischen Kontext bietet. Nutze diese Informationen, um eine informierte Antwort zu geben, besonders wenn der Benutzer sich auf bereits besprochene Themen bezieht.`
    }
  }

  const loadChatSessions = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      console.log(
        "üîÑ Loading chat sessions - userId:",
        userId,
        "workspaceId:",
        workspaceId
      )

      // Verwende personalWorkspaceId als Fallback, wenn keine workspaceId √ºbergeben wird
      const targetWorkspaceId = workspaceId || personalWorkspaceId

      // Build the query
      let query = supabase
        .from("chats")
        .select(
          "id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id"
        )

      // Properly handle null workspace IDs
      if (targetWorkspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Chats in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq("workspace_id", targetWorkspaceId)
      } else {
        // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is("workspace_id", null).eq("user_id", userId)
      }

      const { data, error } = await query.order("last_message_timestamp", {
        ascending: false
      })

      if (error) {
        console.error("‚ùå Error loading chat sessions:", error)
        setError(`Fehler beim Laden der Chats: ${error.message}`)
        throw error
      }

      if (data) {
        console.log("‚úÖ Loaded", data.length, "chat sessions")
        console.log("Chat data:", data) // Debug: Zeige die Chat-Daten

        const formattedSessions = data.map((chat: any) => ({
          id: chat.id || "",
          name: chat.name || "Unnamed Chat",
          created_at: chat.created_at || new Date().toISOString(),
          last_message_timestamp: chat.last_message_timestamp,
          user_id: chat.user_id, // Behalte user_id um den Ersteller anzuzeigen
          ...(chat.description && { description: chat.description }),
          project_id: chat.project_id
        }))

        console.log("Formatted sessions:", formattedSessions) // Debug: Zeige die formatierten Sessions
        setChatSessions(formattedSessions)
      } else {
        console.log("‚ÑπÔ∏è No chat sessions found")
        setChatSessions([])
      }
    } catch (err) {
      console.error("‚ùå Error in loadChatSessions:", err)
      setChatSessions([])
    }
  }

  const createNewChat = async () => {
    try {
      if (!user) {
        setError("Sie m√ºssen angemeldet sein, um einen Chat zu erstellen.")
        return null
      }

      // Determine the workspace ID to use - simplify this logic
      const workspaceId = rawWorkspaceId || personalWorkspaceId

      if (!workspaceId) {
        setError(
          "Konnte keinen g√ºltigen Arbeitsbereich zum Erstellen des Chats finden."
        )
        return null
      }

      console.log(`Creating new chat in workspace: ${workspaceId}`)

      // Create a new chat with a temporary name - we'll update it later
      const newChatId = uuidv4()
      const initialTitle = "Neuer Chat"

      // Create with retry to ensure it succeeds
      const { data: newChat, error } = await supabase
        .from("chats")
        .insert({
          id: newChatId,
          user_id: user.id,
          name: initialTitle,
          workspace_id: workspaceId,
          created_at: new Date().toISOString(),
          last_message_timestamp: new Date().toISOString()
        })
        .select()
        .single()

      if (error) {
        console.error(`‚ùå Error creating new chat: ${error.message}`)
        setError(`Fehler beim Erstellen des Chats: ${error.message}`)
        return null
      }

      if (!newChat) {
        console.error("‚ùå No chat data returned after creation")
        setError("Fehler beim Erstellen des Chats: Keine Daten zur√ºckgegeben")
        return null
      }

      console.log(`‚úÖ Successfully created new chat with ID: ${newChatId}`)

      // Set the current chat ID immediately
      setCurrentChatId(newChatId)

      // Wait for the database to properly register the new chat
      await new Promise(resolve => setTimeout(resolve, 300))

      // Reload chat sessions to update UI
      if (user) {
        await loadChatSessions(user.id, workspaceId)
      }

      return newChatId
    } catch (err) {
      console.error("Error in createNewChat:", err)
      setError(
        `Fehler beim Erstellen des Chats: ${err instanceof Error ? err.message : "Unbekannter Fehler"}`
      )
      return null
    }
  }

  const loadChat = async (chatId: string) => {
    try {
      setCurrentChatId(chatId)

      // Try to get chat details first to confirm it exists
      const { data: chatData, error: chatError } = await supabase
        .from("chats")
        .select("id, name")
        .eq("id", chatId)
        .single()

      if (chatError) {
        console.error("Error fetching chat details:", chatError)
        return
      }

      // Get chat messages - now only using chat_id
      const { data: messagesData, error: messagesError } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (messagesError) {
        console.error("Error fetching chat messages:", messagesError)
        setMessages([])
        return
      }

      if (messagesData && messagesData.length > 0) {
        // Transform to our Message format
        const transformedMessages = messagesData.map((msg: any) => ({
          id: uuidv4(),
          role: msg.role as "user" | "assistant" | "system",
          content: msg.content,
          timestamp: new Date(msg.created_at),
          user_id: msg.user_id, // Store user_id from database
          sentfrom: msg.sentfrom // Store sentfrom from database
        }))

        setMessages(transformedMessages)
        console.log(
          `Loaded ${transformedMessages.length} messages for chat ${chatId}`
        )

        // Fetch usernames for all unique user_ids in messages
        const userIds = [
          ...new Set(
            transformedMessages
              .filter(msg => msg.role === "user" && msg.user_id)
              .map(msg => msg.user_id)
          )
        ]

        if (userIds.length > 0) {
          const { data: profilesData, error: profilesError } = await supabase
            .from("profiles")
            .select("id, full_name")
            .in("id", userIds)

          if (profilesError) {
            console.error("Error fetching user profiles:", profilesError)
          } else if (profilesData) {
            // Create a map of user_id to full_name
            const userNames: { [key: string]: string } = {}
            profilesData.forEach(profile => {
              userNames[profile.id] = profile.full_name
            })
            setUserNamesMap(userNames)
          }
        }
      } else {
        console.log(`No messages found for chat ${chatId}`)
        setMessages([])
      }
    } catch (err) {
      console.error("Error loading chat:", err)
      setMessages([])
    }
  }

  const loadTasks = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status pr√ºfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - √úberspringe Laden der Tasks");
        return; // Fr√ºher Abbruch bei fehlender Internetverbindung
      }

      // Timeout f√ºr die Anfrage setzen, um lange h√§ngende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("tasks").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Tasks in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufr√§umen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedTasks = data.map(task => ({
            ...task,
            title: task.title || task.name,
            ai_model: task.ai_model || task.preferred_model || "gpt-4o"
          }));
          setTasks(formattedTasks);
        }
      } catch (fetchError: any) {
        // Timeout aufr√§umen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Pr√ºfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Task-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Tasks - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading tasks:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu √ºberfluten
      // Wenn die Seite neu geladen wird, wird ein neuer Versuch unternommen
    }
  };

  const loadProjects = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status pr√ºfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - √úberspringe Laden der Projekte");
        return; // Fr√ºher Abbruch bei fehlender Internetverbindung
      }

      // Timeout f√ºr die Anfrage setzen, um lange h√§ngende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("projects").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Projekte in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufr√§umen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedProjects = data.map(project => ({
            ...project,
            name: project.name || project.title,
            workspace_id:
              project.workspace_id || project.preferred_workspace_id || "gpt-4o"
          }));
          setProjects(formattedProjects);
        }
      } catch (fetchError: any) {
        // Timeout aufr√§umen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Pr√ºfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Project-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Projekte - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading projects:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu √ºberfluten
    }
  };

  // Wenn ein user (per Link Sharing) einen spezifischen Chat betritt, dann direkt laden
  useEffect(() => {
    // Lade alle verf√ºgbaren Tasks als Optionen
    if (user) {
      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
      loadTasks(user.id, workspaceContext)
    }

    // Wenn eine Task-ID in der URL ist, lade diese Task
    if (taskId) {
      console.log("Task ID in URL gefunden:", taskId)
      const fetchTask = async () => {
        if (!supabase) return

        const { data, error } = await supabase
          .from("tasks")
          .select("*")
          .eq("id", taskId)
          .single()

        if (error) {
          console.error("Fehler beim Laden der Task:", error)
          return
        }

        if (data) {
          console.log("Task geladen:", data)
          setSelectedTask(data)
          setSelectedModel(data.ai_model || "gpt-4o")
        }
      }

      fetchTask()
    }
  }, [user, taskId, supabase, rawWorkspaceId, personalWorkspaceId, loadTasks])

  // Effect f√ºr die Textareabehandlung
  useEffect(() => {
    const textarea = inputRef.current
    if (textarea) {
      // Reset height - wichtig, um zu verhindern, dass es nur nach oben w√§chst
      textarea.style.height = "auto"
      // Setze die neue H√∂he basierend auf dem Scroll-H√∂hen-Wert
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`
    }
  }, [inputValue])

  // Reduziere unn√∂tige Re-Renders durch Memoization der Lade-Funktionen
  const loadChatSessionsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadChatSessions(userId, workspaceId);
    },
    [supabase, setChatSessions]
  );
  
  const loadChatMemoized = useCallback(
    async (chatId: string) => {
      return await loadChat(chatId);
    },
    [supabase, user, setMessages, setUserNamesMap]
  );
  
  const loadTasksMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadTasks(userId, workspaceId);
    },
    [supabase, setTasks]
  );
  
  const loadProjectsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadProjects(userId, workspaceId);
    },
    [supabase, setProjects]
  );

  // Haupt-Initialisierungscode f√ºr den Chat
  useEffect(() => {
    // Zeitsperre, um zu h√§ufige Aufrufe zu verhindern
    const checkSession = async () => {
      // Vermeide mehrfache gleichzeitige Initialisierungen
      if (isInitializingRef.current) {
        debugLog("Initialization already in progress, skipping");
        return;
      }
      
      isInitializingRef.current = true;
      try {
        setLoading(true);

        // Pr√ºfe, ob der Benutzer angemeldet ist
        const {
          data: { session }
        } = await supabase.auth.getSession();

        if (!session) {
          console.log("No session found, redirecting to login");
          router.push("/login");
          return;
        }

        // Benutzer ist angemeldet
        setUser(session.user);

        // Profilnamen laden (nicht kritisch f√ºr Initialisierung)
        if (!userFullName || userFullName === "Du") {
          try {
            const { data: profileData } = await supabase
              .from("profiles")
              .select("full_name")
              .eq("id", session.user.id)
              .single();

            if (profileData?.full_name) {
              setUserFullName(profileData.full_name);
            }
          } catch (profileError) {
            console.error("Error loading user profile:", profileError);
          }
        }

        debugLog(`*** Session exists, user: ${session.user.id}`);

        // Workspace-Kontext bestimmen
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        debugLog("Current workspace context:", workspaceContext);

        // Chats nur laden, wenn n√∂tig
        if (workspaceContext && !initialChatsLoadedRef.current && chatSessions.length === 0) {
          debugLog("Loading chat sessions for the first time");
          // Use Promise.all to load data in parallel
          await Promise.all([
            loadChatSessionsMemoized(session.user.id, workspaceContext),
            loadProjectsMemoized(session.user.id, workspaceContext)
          ]);
          initialChatsLoadedRef.current = true;
        }

        // Wenn ein Chat bereits in state ist, lade ihn
        if (currentChatId) {
          debugLog("Chat ID in state bereits vorhanden:", currentChatId);
          await loadChatMemoized(currentChatId);
        } else if (chatSessions.length > 0 && !messages.length && !isStartingNewChatRef.current) {
          // Sonst lade den ersten Chat, aber nur wenn:
          // - keine Nachrichten bereits geladen sind 
          // - UND kein expliziter Neustart eines Chats angefordert wurde
          debugLog("Lade den ersten Chat aus vorhandenen Sessions:", chatSessions[0].id);
          setCurrentChatId(chatSessions[0].id);
          await loadChatMemoized(chatSessions[0].id);
        } else if (isStartingNewChatRef.current) {
          debugLog("Neuer Chat wurde explizit angefordert - lade keinen vorhandenen Chat");
          // Flag zur√ºcksetzen nach Verwendung
          isStartingNewChatRef.current = false;
        }

        // Tasks laden (wenn noch nicht geladen)
        if (tasks.length === 0 && workspaceContext) {
          await loadTasksMemoized(session.user.id, workspaceContext);
        }

        // Icebreakers zeigen, wenn keine Nachrichten vorhanden
        if (messages.length === 0) {
          setShowIceBreakers(true);
        }

        // Task laden, wenn eine ID √ºbergeben wurde
        if (taskId && (!selectedTask || selectedTask.id !== taskId)) {
          const { data: taskData, error } = await supabase
            .from("tasks")
            .select("*")
            .eq("id", taskId)
            .single();

          if (!error && taskData) {
            debugLog("Task geladen:", taskData);
            setSelectedTask(taskData);
            setSelectedModel(taskData.ai_model || selectedModel);
          }
        }
      } catch (err: any) {
        console.error("Chat init error:", err);
        setError(err.message);
      } finally {
        setLoading(false);
        
        // Use setTimeout to avoid race conditions when setting isInitializingRef
        if (initializationTimeoutRef.current) {
          clearTimeout(initializationTimeoutRef.current);
        }
        
        initializationTimeoutRef.current = setTimeout(() => {
          isInitializingRef.current = false;
          debugLog("Initialization flag reset to false");
          initializationTimeoutRef.current = null;
        }, 100);
      }
    };

    checkSession();
    
    // Cleanup function
    return () => {
      if (initializationTimeoutRef.current) {
        clearTimeout(initializationTimeoutRef.current);
      }
      if (messageUpdateTimeoutRef.current) {
        clearTimeout(messageUpdateTimeoutRef.current);
      }
    };
  }, [
    supabase,
    currentChatId,
    personalWorkspaceId,
    rawWorkspaceId,
    router,
    taskId
  ]);

  /* eslint-disable react-hooks/rules-of-hooks */
  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        modelDropdownRef.current &&
        !modelDropdownRef.current.contains(event.target as Node)
      ) {
        setShowModelDropdown(false)
      }

      if (
        taskDropdownRef.current &&
        !taskDropdownRef.current.contains(event.target as Node)
      ) {
        setShowTaskDropdown(false)
      }

      // Schlie√üe Chat-Men√º bei Klick au√üerhalb
      const chatMenuTarget = (event.target as Element)?.closest(
        "[data-chat-menu]"
      )
      if (chatMenuOpen && !chatMenuTarget) {
        setChatMenuOpen(null)
      }

      // Schlie√üe Projekt-Men√º bei Klick au√üerhalb
      const projectMenuTarget = (event.target as Element)?.closest(
        "[data-project-menu]"
      )
      if (projectMenuOpen && !projectMenuTarget) {
        setProjectMenuOpen(null)
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [chatMenuOpen, projectMenuOpen])

  // Haupt-Funktion zum Senden einer Nachricht an die API
  const sendMessageToAPI = async (
    messages: Message[],
    model: string,
    chatId: string
  ) => {
    console.log(`üîÑ sendMessageToAPI v2 aufgerufen mit Chat-ID: ${chatId}`);

    const userId = user?.id;
    if (!userId) {
      console.error("‚ùå User ID fehlt beim Senden an API.");
      throw new Error("User ID ist erforderlich");
    }

    // 1. DATEN SAMMELN (wie bisher)
    // --------------------------------
    console.log(`üë§ Hole Benutzerprofil f√ºr User ID: ${userId}`);
    const { data: fetchedUserProfile, error: profileError } = await supabase
        .from("profiles")
        .select("*")
      .eq("id", userId)
      .single();
      
    // Use fetchedUserProfile instead of the state variable userProfile directly here
    // to ensure we have the latest data for this specific call.
    if (profileError) console.error("Fehler beim Abrufen des Profils:", profileError);
    else console.log("‚úÖ Benutzerprofil erfolgreich abgerufen");

    const lastUserMessage = [...messages].reverse().find(m => m.role === "user");
    let knowledgeResults: any[] = [];
    let similarMessages: any[] = []; // Assuming this holds structured QA or relevant snippets
    // (SelectedTask comes from component state)
    const currentSelectedTask = selectedTask; // Capture state at the time of call

    if (lastUserMessage) {
        const userQuery = lastUserMessage.content;
        
        // Wissensdatenbank-Suche (falls KB ausgew√§hlt)
        if (selectedKnowledgeBaseId && selectedKnowledgeBaseId.length > 0) { 
            try {
                console.log(`üß† Performing knowledge base search for KBs: ${selectedKnowledgeBaseId.join(', ')}...`);
                const { data: authData } = await supabase.auth.getSession();
                const authToken = authData?.session?.access_token;

                // Alle Ergebnisse aus allen ausgew√§hlten Wissensdatenbanken sammeln
                let allKnowledgeResults: any[] = [];
                
                // Sequentiell durch alle ausgew√§hlten Wissensdatenbanken gehen
                for (const kbId of selectedKnowledgeBaseId) {
                    const knowledgeResponse = await fetch("/api/knowledge/search", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            query: userQuery,
                            knowledge_base_id: kbId,
                            auth_token: authToken
                        })
                    });
                    
                    if (knowledgeResponse.ok) {
                        const knowledgeData = await knowledgeResponse.json();
                        const results = knowledgeData.results || [];
                        console.log(`üß† Found ${results.length} raw knowledge items from KB ${kbId}.`);
                        allKnowledgeResults.push(...results);
                    } else {
                        console.error(`‚ö†Ô∏è Knowledge base search failed for KB ${kbId}:`, knowledgeResponse.statusText);
                    }
                }
                
                // Sortiere alle Ergebnisse nach Relevanz (falls ein similarity-Feld existiert)
                knowledgeResults = allKnowledgeResults.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));
                console.log(`üß† Combined ${knowledgeResults.length} total knowledge items from all KBs.`);
          
            } catch (knowledgeError) {
                console.error("‚ùå Error during knowledge base search fetch:", knowledgeError);
            }
        } else {
            console.log("‚ÑπÔ∏è Keine Wissensdatenbank ausgew√§hlt, √ºberspringe Suche.");
        }
        
        // Suche nach √§hnlichen Nachrichten (wie bisher)
        try {
            console.log(`üîç Suche nach User-weiten Kontext f√ºr User ${userId}, basierend auf: ${userQuery.substring(0, 30)}...`);
            // Assuming findSimilarMessagesOptimized returns the structured data needed
            similarMessages = await findSimilarMessagesOptimized(userId, userQuery, lastUserMessage.id) || [];
            console.log(`‚úÖ ${similarMessages.length} √§hnliche Nachrichten gefunden`);
             // Log details of similar messages structure if needed for debugging
             // console.log("Similar messages structure:", JSON.stringify(similarMessages.slice(0,2), null, 2));
        } catch (error) {
            console.error("‚ùå Fehler bei der Suche nach √§hnlichen Nachrichten:", error);
        }

    } else {
      console.warn("Keine letzte Benutzernachricht gefunden, kann keinen Kontext generieren.");
      // Handle case where there's somehow no user message? Maybe return early or send without context.
    }
    
    // KONSOLIDIERTE PROMPT-ERSTELLUNG MIT DEM NEUEN PROMPT-BUILDER
    // -------------------------------------------
    const userInput = lastUserMessage ? lastUserMessage.content : "";
    
    // Verwende den neuen buildPrompt statt manueller Zusammensetzung
    const finalPrompt = buildPrompt({
      userInput,
      chatId,
      taskPrompt: currentSelectedTask?.system_prompt || null,
      // Verwende den aus prompt-builder.ts importierten DEFAULT_SYSTEM_PROMPT 
      // Das systemPrompt muss hier nicht explizit √ºbergeben werden, da es den DEFAULT_SYSTEM_PROMPT nutzt
      userProfile: fetchedUserProfile,
      knowledgeResults,
      pastMessages: similarMessages,
      allMessages: messages,
      modelType: "default", // Standard-Chat
      maxPastMessages: 4,
      maxKnowledgeResults: 3
    });
    
    console.log(`üì© Sende an API: ${messages.filter(m => m.role !== 'system').length} User/Assistant Nachrichten, ${finalPrompt.length - messages.filter(m => m.role !== 'system').length} System/Assistant Kontextobjekt(e)`);
    console.log("Final apiMessages array (V2) before API call:", JSON.stringify(finalPrompt, null, 2));
    
    // API CALL MIT STREAMING
    // --------------------------------------------------
    try {
        const apiUrl = `/api/chat?model=${encodeURIComponent(model)}&chatId=${encodeURIComponent(chatId)}`;
        
        // Streaming aktivieren
        const streaming = true;
        
        if (streaming) {
          // Streaming Anfrage mit benutzerdefinierten Parametern
          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              messages: finalPrompt,
              streaming: true
            })
          });
          
          if (!response.ok) {
            const errorBody = await response.text();
            console.error("API Error Response Body:", errorBody);
            throw new Error(`API responded with ${response.status}`);
          }

          // Stream verarbeiten
          const reader = response.body?.getReader();
          if (!reader) throw new Error("Stream reader not available");
          
          const decoder = new TextDecoder();
          let fullContent = "";
          let metaInfo = null;
          
          // Event-basierter Streaming-Modus (gibt Text-Chunks zur√ºck w√§hrend sie ankommen)
          return {
            content: "", // Wird unten schrittweise gef√ºllt
            streamContent: async function* () {
              let buffer = ""; // Puffer f√ºr eingehende Chunks
              const decoder = new TextDecoder();
              let accumulatedJsonRemainder = ""; // Buffer for incomplete JSON chunks

              try {
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) {
                    // Yield any remaining buffer content when the stream ends
                    if (buffer.length > 0) {
                      yield buffer;
                      // fullContent is already updated progressively
                    }
                     // Yield any remaining JSON remainder if it's valid text
                    if (accumulatedJsonRemainder.length > 0 && !accumulatedJsonRemainder.startsWith('{')) {
                       yield accumulatedJsonRemainder;
                    }
                    break;
                  }

                  const rawChunk = decoder.decode(value, { stream: true });
                  accumulatedJsonRemainder += rawChunk;

                  let textToProcess = "";
                  let processFromIndex = 0;

                  // Attempt to parse JSON if it looks like it might be JSON
                  if (accumulatedJsonRemainder.includes('{') && accumulatedJsonRemainder.includes('}')) {
                      try {
                          // Find potential JSON boundary more robustly
                          let potentialJsonEnd = accumulatedJsonRemainder.lastIndexOf('}') + 1;
                          let potentialJson = accumulatedJsonRemainder.substring(0, potentialJsonEnd);
                          
                          // Basic check if it looks like a valid JSON object
                          if (potentialJson.startsWith('{')) {
                              const parsed = JSON.parse(potentialJson);
                              if (parsed && typeof parsed.content === 'string') {
                                  textToProcess = parsed.content;
                                  // Update fullContent only with the actual text part
                                  fullContent += textToProcess;
                                  // Remove the processed JSON part from the remainder
                                  accumulatedJsonRemainder = accumulatedJsonRemainder.substring(potentialJsonEnd);
                                  processFromIndex = 0; // Start processing the new text from beginning
                              } else {
                                 // Valid JSON but not the expected format, treat accumulated as text
                                 textToProcess = accumulatedJsonRemainder;
                                 fullContent += textToProcess; // Add raw chunk to fullContent
                                 accumulatedJsonRemainder = ""; // Clear remainder
                      }
    } else {
                             // Doesn't start with '{', treat as raw text
                             textToProcess = accumulatedJsonRemainder;
                             fullContent += textToProcess; // Add raw chunk to fullContent
                             accumulatedJsonRemainder = ""; // Clear remainder
                        }
                      } catch (e) {
                          // Invalid JSON or incomplete chunk, wait for more data or treat as text if stream ends
                          // Continue accumulating, do not process buffer yet unless it's very long
                          if (accumulatedJsonRemainder.length > 1000) { // Process as text if buffer gets too long
                               textToProcess = accumulatedJsonRemainder;
                               fullContent += textToProcess; // Add raw chunk to fullContent
                               accumulatedJsonRemainder = ""; // Clear remainder
                      }
                    }
    } else {
                     // Does not contain braces, likely raw text
                     textToProcess = accumulatedJsonRemainder;
                     fullContent += textToProcess; // Add raw chunk to fullContent
                     accumulatedJsonRemainder = ""; // Clear remainder
                  }
                  
                  // If we extracted text (either from JSON or raw chunk), add to buffer and yield words
                  if (textToProcess) {
                    buffer += textToProcess;

                    // Process the buffer to yield whole words/segments
                    let lastDelimiterPos = -1;
                    const lastSpacePos = buffer.lastIndexOf(' ');
                    const lastNewlinePos = buffer.lastIndexOf('\\n');
                    lastDelimiterPos = Math.max(lastSpacePos, lastNewlinePos);

                    if (lastDelimiterPos !== -1) {
                      const partToYield = buffer.substring(0, lastDelimiterPos + 1);
                      if (partToYield.length > 0) {
                           yield partToYield;
                      }
                      buffer = buffer.substring(lastDelimiterPos + 1);
                    }
                  }
                }
              } catch (error) {
                console.error("Error reading stream:", error);
                if (buffer.length > 0) yield buffer;
                if (accumulatedJsonRemainder.length > 0) yield accumulatedJsonRemainder;
                throw error;
              } finally {
                this.content = fullContent;
              }
            },
            getContent: () => fullContent,
            model: model
          };
        } else {
          // Nicht-Streaming-Modus (f√ºr Fallback)
      const apiResponse = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
              messages: finalPrompt
        })
        });

      if (!apiResponse.ok) {
            // Log response body if available
            const errorBody = await apiResponse.text();
            console.error("API Error Response Body:", errorBody);
            throw new Error(`API responded with ${apiResponse.status}`);
        }

        const data = await apiResponse.json();
        return data; // R√ºckgabe an den Aufrufer (handleSendMessage)
        }
    } catch (error) {
        console.error("‚ùå Fehler beim API-Aufruf in sendMessageToAPI:", error);
        throw error; // Fehler weitergeben, damit handleSendMessage ihn fangen kann
    }
  }  // Ende von sendMessageToAPI

  const handleTypewriterComplete = (messageId: string) => {
    const updatedMessages = messages.map(m =>
      m.id === messageId ? { ...m, isTypewriting: false } : m
    )
    setMessages(updatedMessages)
    setTypingMessageId(null)
  }

  const handleCreateTask = async () => {
    if (!newTaskName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || null

      const { data, error } = await supabase
        .from("tasks")
        .insert({
          title: newTaskName,
          description: newTaskDescription,
          system_prompt: newTaskSystemPrompt,
          ai_model: newTaskModel,
          status: "todo",
          priority: "medium",
          user_id: user.id,
          workspace_id: workspaceContext
        })
        .select()

      if (error) throw error

      await loadTasks(user.id, workspaceContext)

      setShowTaskModal(false)
      setNewTaskName("")
      setNewTaskDescription("")
      setNewTaskSystemPrompt("")
      setNewTaskModel("gpt-4o")
    } catch (err) {
      console.error("Error creating task:", err)
    } finally {
      setLoading(false)
    }
  }

  const handleCreateProject = async () => {
    if (!newProjectName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null

      // ---> START DEBUG LOG <---
      console.log("--- Creating Project --- ")
      console.log("User ID to send:", user?.id)
      console.log("Raw Workspace ID from URL:", rawWorkspaceId)
      console.log("Personal Workspace ID state:", personalWorkspaceId)
      console.log("Workspace Context to send:", workspaceContext)
      // ---> END DEBUG LOG <---

      // ---> ADDED AUTH CHECK <---
      const { data: authData, error: authError } =
        await supabase.auth.getSession()
      console.log("--- Auth Check Before Insert ---")
      console.log("Current Session:", authData?.session)
      console.log("Session User ID:", authData?.session?.user?.id)
      console.log("Auth Error:", authError)
      if (authError || !authData?.session) {
        console.error("CRITICAL: No valid session before insert!")
        // Optionally: Prevent the insert or show an error to the user
        // return;
      }
      // ---> END AUTH CHECK <---

      // ---> ADDED DIAGNOSTIC FUNCTION <---
      // This immediately runs when you click "Create Project" in the UI
      // It helps diagnose why the workspace membership check fails
      console.log("--- Running Diagnostic Function ---")
      const diagResult = await supabase.rpc("diagnose_workspace_membership", {
        p_user_id: user.id,
        p_workspace_id: workspaceContext
      })
      console.log("Diagnosis Result:", diagResult)
      // Explicit logging of the important diagnostic data
      console.log("MEMBERSHIP DATA:", JSON.stringify(diagResult.data, null, 2))
      if (diagResult.data) {
        console.log("User ID Input:", diagResult.data.user_id_input)
        console.log("Workspace ID Input:", diagResult.data.workspace_id_input)
        console.log("Membership Exists:", diagResult.data.membership_exists)
        console.log("Membership Count:", diagResult.data.membership_count)
        console.log("All User Workspaces:", diagResult.data.all_user_workspaces)
        console.log(
          "All Workspace Members:",
          diagResult.data.all_workspace_members
        )
      }
      // ---> END DIAGNOSTIC FUNCTION <---

      // Use the database function instead of direct table access
      // This bypasses RLS issues while maintaining security checks in the function
      const { data, error } = await supabase.rpc("create_project", {
        p_name: newProjectName,
        p_description: newProjectDescription,
        p_user_id: user.id,
        p_workspace_id: workspaceContext,
        p_color: "#4c4cff",
        p_status: "active"
      })

      if (error) throw error

      await loadProjects(user.id, workspaceContext)
      setShowProjectModal(false)
      setNewProjectName("")
      setNewProjectDescription("")
    } catch (err) {
      console.error("Error creating project:", err)
    } finally {
      setLoading(false)
    }
  }

  // Generate a chat name from the first user message
  const generateChatName = (message: string): string => {
    // Split the message into words
    const words = message.trim().split(/\s+/)

    // Get up to the first 3 words
    const firstThreeWords = words.slice(0, 3).join(" ")

    // If the result is too short, use "Neuer Chat"
    return firstThreeWords.length >= 3 ? firstThreeWords : "Neuer Chat"
  }

  // Modifiziere den useEffect f√ºr Task-Wechsel
  useEffect(() => {
    // Only perform task change operations if no message update is pending
    // And ensure at least 500ms has passed since the last message update
    const timeSinceLastUpdate = Date.now() - lastMessageUpdate
    if (messageUpdatePending || timeSinceLastUpdate < 500) {
      console.log(
        "Message update in progress or too recent, deferring task change handling"
      )
      return
    }

    const handleTaskOrModelChange = async () => {
      // Pr√ºfen, ob es sich um einen Task- oder Modellwechsel handelt
      const isTaskChange = selectedTask?.id !== previousSelectedTask?.id
      // const isModelChange = selectedModel !== previousSelectedModel && !selectedTask;

      // Run this logic ONLY on task change, not on simple model selection
      if (isTaskChange && messages.length > 0) {
        // Wenn eine Task oder ein Modell gewechselt wurde und es Nachrichten gibt

        console.log("Task wurde gewechselt, erstelle Zusammenfassung...")

        try {
          // Pr√ºfe, ob bereits eine Zusammenfassung im Chat existiert
          const lastSummaryMessage = [...messages]
            .reverse()
            .find(
              msg =>
                msg.role === "assistant" &&
                (msg.content.includes("Chat-Zusammenfassung") ||
                  msg.content.includes("Hauptpunkte:") ||
                  msg.content.includes("Zusammenfassung des Chats"))
            )

          let summary: string

          if (lastSummaryMessage) {
            // Verwende die vorhandene Zusammenfassung
            console.log("Verwende vorhandene Zusammenfassung")
            summary = lastSummaryMessage.content
          } else {
            // Erstelle eine neue Zusammenfassung, da keine vorhanden ist
            console.log("√úberspringe Zusammenfassung f√ºr Task-Wechsel (DEBUG)")
            summary = "" // Tempor√§r deaktiviert
          }

          if (summary) {
            // Erstelle eine neue System-Nachricht mit der Zusammenfassung
            const summarySystemMessage: Message = {
              id: uuidv4(),
              role: "system",
              content: `Zusammenfassung des bisherigen Gespr√§chs: ${summary}

${selectedTask ? selectedTask.system_prompt : "Fahre mit dem Gespr√§ch fort, basierend auf dieser Zusammenfassung."}`,
              timestamp: new Date()
            }

            // Entferne alle bisherigen System-Nachrichten
            const filteredMessages = messages.filter(m => m.role !== "system")

            // F√ºge die neue System-Nachricht am Anfang hinzu
            setMessages([summarySystemMessage, ...filteredMessages])

            console.log(
              "Zusammenfassung wurde als System-Nachricht hinzugef√ºgt."
            )

            // Task-switching notification message is REMOVED
          }
        } catch (error) {
          console.error("Error in task change handling:", error)
        } finally {
          // Always set isTaskSwitching to false when complete
          setIsTaskSwitching(false)
        }
      } else {
        // If there's no task change or no messages, just reset the switching state
        setIsTaskSwitching(false)
      }

      // Aktuelle Task und Modell f√ºr den n√§chsten Vergleich speichern
      setPreviousSelectedTask(selectedTask)
      setPreviousSelectedModel(selectedModel)
    }

    handleTaskOrModelChange()
  }, [
    selectedTask,
    selectedModel,
    messages,
    messageUpdatePending,
    previousSelectedTask,
    previousSelectedModel,
    lastMessageUpdate
  ])

  // Add this function to sync messages with the database when needed
  const syncMessagesWithDatabase = async (chatId: string) => {
    if (!chatId) return

    try {
      console.log("Syncing messages with database for chat:", chatId)
      const { data, error } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (error) {
        console.error("Error syncing messages:", error)
        return
      }

      if (data) {
        // Convert database messages to app message format
        const formattedMessages: Message[] = data.map(dbMsg => ({
          id: dbMsg.id || uuidv4(),
          role: dbMsg.role as "user" | "assistant" | "system",
          content: dbMsg.content,
          timestamp: new Date(dbMsg.created_at)
        }))

        console.log(`Synced ${formattedMessages.length} messages from database`)
        setMessages(formattedMessages)
      }
    } catch (error) {
      console.error("Error in syncMessagesWithDatabase:", error)
    }
  }

  // Modify handleSendMessage to optionally include web search results
  const handleSendMessage = async (
    message: string,
    includeWebSearch: boolean = false
  ) => {
    if (message.trim().length === 0) return
    if (isTyping || messageUpdatePending || isTaskSwitching) return

    // Markieren, dass der Benutzer mit dem Tippen begonnen hat
    setHasStartedTyping(true)

    const userMessageId = uuidv4()
    const newMessage: Message = {
      id: userMessageId,
      role: "user",
      content: message,
      timestamp: new Date(),
      user_id: user?.id,
      sentfrom: userFullName
    }

    console.log("Creating new message with user_id:", user?.id)

    try {
      // Prevent task switching effects during message sending
      setMessageUpdatePending(true)
      setLastMessageUpdate(Date.now())

      // Create the new array *before* setting state
      const newMessagesArray = [...messages, newMessage]

      // Add user message to state immediately for better UX
      setMessages(newMessagesArray) // Use the new array
      setInputValue("") // Eingabefeld leeren

      // Show typing indicator
      setIsTyping(true)

      // If web search is requested, perform it before sending to API
      let webSearchResults = null
      if (includeWebSearch) {
        setIsSearching(true)
        try {
          webSearchResults = await performSerpApiSearch(message)
          console.log("Web search results:", webSearchResults.length)
        } catch (searchError) {
          console.error("Error during web search:", searchError)
        } finally {
          setIsSearching(false)
        }
      }

      let chatIdToUse = currentChatId

      // If no current chat exists, create a new one before proceeding
      if (!chatIdToUse) {
        console.log(
          "No current chat, creating new one before sending message..."
        )
        chatIdToUse = await createNewChat()
        if (!chatIdToUse) {
          throw new Error("Failed to create a new chat")
        }
        console.log(`Successfully created new chat with ID: ${chatIdToUse}`)
        // Set current chat ID immediately to ensure context is maintained
        setCurrentChatId(chatIdToUse)
      }

      // Speichern der Benutzernachricht in der Datenbank
      console.log(`Saving message to chat ID: ${chatIdToUse}`)

      // Wichtig: Wir ben√∂tigen diese Nachrichts-ID f√ºr Embedding
      let dbMessageId = null;

      try {
      const { data: messageData, error: messageError } = await retryOperation(
        async () => {
          return await supabase
            .from("chat_messages")
            .insert({
              chat_id: chatIdToUse,
              role: "user",
                content: message,
              user_id: user?.id,
              sentfrom: userFullName,
              created_at: newMessage.timestamp.toISOString()
            })
            .select()
        },
        3,
        1000
        );

      if (messageError) {
        console.error("‚ùå Error saving message:", messageError)
      } else {
        console.log("‚úÖ Message saved successfully to database", messageData)
          // Speichere die ID f√ºr sp√§tere Verwendung
        if (messageData && messageData.length > 0) {
            dbMessageId = messageData[0].id;
          }
        }
      } catch (saveError) {
        console.error("Error saving user message:", saveError);
        // Wir setzen den Prozess fort, auch wenn die Nachricht nicht gespeichert werden konnte
      }

      // Vorbereiten und Senden der Anfrage an die API
      try {
        const modelToUse = selectedTask?.ai_model || selectedModel
        console.log("üì£ Sende Nachricht an API mit Chat-ID:", chatIdToUse)
        console.log("üîÑ Ausgew√§hltes Modell f√ºr diese Anfrage:", modelToUse);

        // Streaming-Response
        const response = await sendMessageToAPI(
          newMessagesArray,
          modelToUse,
          chatIdToUse
        )

        // Assistentennachricht erstellen und anzeigen (vorerst leer)
        const assistantMessageId = uuidv4()
        const assistantMessage: Message = {
          id: assistantMessageId,
          role: "assistant",
          content: "", // Startinhalt ist leer, wird nach und nach gef√ºllt
          timestamp: new Date(),
          isTypewriting: true // Ensure this is set to true
        }

        // Sofort hinzuf√ºgen, um den Platzhalter anzuzeigen
        setMessages(prevMessages => [...prevMessages, assistantMessage])
        setTypingMessageId(assistantMessageId) // Make sure to set the typing message ID

        // Wenn Streaming-Antwort verf√ºgbar ist, nutze diese
        if (response.streamContent) {
          try {
            console.log("üé¨ Starte Streaming-Verarbeitung...");
            // Sammle Nachrichteninhalt w√§hrend des Streamings
            let collectedContent = "";
            
            // Hole den Generator f√ºr die Stream-Verarbeitung
            const contentGenerator = response.streamContent();
            
            // Schreibe die assistantMessageId in eine konstante Variable
            // f√ºr die asynchronen Funktionen
            const messageIdToUpdate = assistantMessageId;
            
            // Verarbeite jeden Chunk aus dem Stream
            for await (const chunk of contentGenerator) {
              // Try to process chunk if it's JSON
              let processedChunk = chunk;
              try {
                if (chunk.trim().startsWith('{') && chunk.trim().endsWith('}')) {
                  const jsonChunk = JSON.parse(chunk);
                  if (jsonChunk && typeof jsonChunk.content === 'string') {
                    processedChunk = jsonChunk.content;
                  }
                }
              } catch (e) {
                // Use original chunk if JSON parsing fails
                processedChunk = chunk;
              }
              
              collectedContent += processedChunk;
              
              // Aktualisiere die Nachricht in der UI mit jedem Chunk
              setMessages(prevMessages => 
                prevMessages.map(msg => 
                  msg.id === messageIdToUpdate 
                    ? { ...msg, content: collectedContent, isTypewriting: true }
                    : msg
                )
              );
            }
            
            // Nach Ende des Streams: endg√ºltigen Inhalt speichern
            assistantMessage.content = collectedContent || response.content;
            
            // Aktualisiere mit dem endg√ºltigen Inhalt f√ºr den Fall von Metadaten
            setMessages(prevMessages => 
              prevMessages.map(msg => 
                msg.id === messageIdToUpdate 
                  ? { ...msg, content: assistantMessage.content }
                  : msg
              )
            );
            
            console.log("‚úÖ Streaming abgeschlossen, Gesamtl√§nge:", assistantMessage.content.length);
          } catch (streamingError) {
            console.error("‚ùå Fehler bei der Stream-Verarbeitung:", streamingError);
            // Fallback: Verwende das content-Feld, wenn verf√ºgbar
            if (response.content) {
              assistantMessage.content = response.content;
              setMessages(prevMessages => 
                prevMessages.map(msg => 
                  msg.id === assistantMessageId 
                    ? { ...msg, content: response.content }
                    : msg
                )
              );
            }
          }
        } else {
          // Fallback f√ºr nicht-Streaming-Antworten
          assistantMessage.content = response.content;
          setMessages(prevMessages => 
            prevMessages.map(msg => 
              msg.id === assistantMessageId 
                ? { ...msg, content: response.content }
                : msg
            )
          );
        }

        // Speichern der Assistentennachricht in der Datenbank
        let dbAssistantId = null;
        try {
          const { data: assistantData, error: assistantError } = await supabase
            .from("chat_messages")
            .insert({
              chat_id: chatIdToUse,
              role: "assistant",
              content: assistantMessage.content,
              created_at: assistantMessage.timestamp.toISOString()
            })
            .select();

          if (assistantError) {
            console.error("‚ùå Error saving assistant message:", assistantError)
          } else {
            console.log("‚úÖ AI message saved to database", assistantData)
            if (assistantData && assistantData.length > 0) {
              dbAssistantId = assistantData[0].id;
            }
          }
        } catch (saveError) {
          console.error("Error saving assistant message:", saveError);
        }

        // Nach erfolgreicher Kommunikation, starte asynchrone Aufgaben
        // Embedding f√ºr Benutzernachricht
        if (dbMessageId) {
          const dbMessage = { ...newMessage, id: dbMessageId };
          const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
          createEmbedding(dbMessage, chatIdToUse, workspaceIdToUse)
            .catch(err => console.error("User embedding failed:", err));
        }

        // Embedding f√ºr Assistentennachricht
        if (dbAssistantId) {
          const dbAssistantMessage = { ...assistantMessage, id: dbAssistantId };
          const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
          createEmbedding(dbAssistantMessage, chatIdToUse, workspaceIdToUse)
            .catch(err => console.error("Assistant embedding failed:", err));
        }

        // Titelgenerierung f√ºr neue Chats
        if (!currentChatId && chatIdToUse) {
          generateAndSetChatTitle(chatIdToUse, message)
            .catch(err => console.error("Title generation failed:", err));
        }

        // Chat-Liste aktualisieren
        if (user) {
          loadChatSessions(user.id, rawWorkspaceId || null)
            .catch(err => console.error("Chat session loading failed:", err));
        }
      } catch (apiError) {
        console.error("Error getting AI response:", apiError)
        setIsTyping(false)

        // Fehlermeldung hinzuf√ºgen
        const errorMessageId = uuidv4()
        const errorMessage: Message = {
          id: errorMessageId,
          role: "assistant",
          content: "Die Verbindung zum AI-Service konnte nicht hergestellt werden. Bitte versuche es sp√§ter noch einmal.",
          timestamp: new Date()
        }
        setMessages(prevMessages => [...prevMessages, errorMessage])
      } finally {
        // In jedem Fall Typing-Status zur√ºcksetzen
        setIsTyping(false)
        setMessageUpdatePending(false)
      }
    } catch (error) {
      console.error("Error in handleSendMessage:", error)
      setIsTyping(false)
      setMessageUpdatePending(false)
    }
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    handleSendMessage(inputValue)
  }

  const getModelLabel = (modelId: string | null): string => {
    // Map actual model IDs back to friendly names
    switch (modelId) {
      // Direkte Namen (keine Umwandlung n√∂tig)
      case "Basic":
        return "Basic"
      case "Fast":
        return "Fast"
      case "Reason":
        return "Reason"
      case "Reason+":
        return "Reason+"

      // Alte technische IDs f√ºr Abw√§rtskompatibilit√§t
      case "gpt-4o-2024-11-20":
        return "Basic"
      case "gpt-4o-mini-2024-07-18":
        return "Fast"
      case "o3-mini-2025-01-31":
        return "Reason"
      case "gpt-4.5-preview-2025-02-27":
        return "Reason+"

      // Sehr alte IDs f√ºr Abw√§rtskompatibilit√§t
      case "gpt-4o":
        return "Basic"
      case "gpt-4o-mini":
        return "Fast"
      case "gpt-4-vision-preview":
        return "Reason"
      default:
        // Standardwert
        return modelId || "Basic"
    }
  }

  // Function to copy message content to clipboard
  const copyToClipboard = (text: string) => {
    navigator.clipboard
      .writeText(text)
      .then(() => {
        // Could show a toast notification here
        console.log("Copied to clipboard")
      })
      .catch(err => {
        console.error("Failed to copy: ", err)
      })
  }

  // Function to start editing a user message
  const startEditMessage = (message: Message) => {
    // Save the current state of all messages for potential restoration
    setOriginalMessages([...messages]);
    
    // Find the index of the message to edit
    const messageIndex = messages.findIndex(m => m.id === message.id);
    if (messageIndex === -1) return;
    
    // Keep only messages up to and including the one being edited
    const visibleMessages = messages.slice(0, messageIndex + 1);
    setMessages(visibleMessages);
    
    // Set editing state
    setEditingMessageId(message.id);
    setEditingContent(message.content);
  }

  // Function to cancel editing
  const cancelEditMessage = () => {
    // Restore messages to their original state
    if (originalMessages.length > 0) {
      setMessages(originalMessages);
    }
    
    // Reset editing state
    setEditingMessageId(null);
    setEditingContent("");
    setOriginalMessages([]);
  }

  // Add this helper function to track processed messages
  const processedMessageIds = new Set<string>();

  // Add the saveAssistantMessage helper function before the handleSaveEdit function
  const saveAssistantMessage = async (assistantMessage: Message, chatId: string) => {
    try {
      debugLog("Saving AI response for chat:", chatId);
      
      // Get current date in YYYY-MM-DD format
      const currentDate = new Date().toISOString().split("T")[0];
      
      // Store date directly in content field but in a way that can be filtered out in UI
      const contentWithDate = `[Datum: ${currentDate}]\n${assistantMessage.content}`;
      
      const { error: aiInsertError, data: aiInsertData } = await supabase
          .from("chat_messages")
        .insert({
          id: assistantMessage.id, // Use specific ID to help with deduplication
          chat_id: chatId,
          role: "assistant",
          // Store content with date prefix - we'll strip it when displaying
          content: contentWithDate,
          user_id: null, // AI responses don't have a user ID
          created_at: new Date().toISOString()
        })
        .select();

      if (aiInsertError) {
        console.error("Error saving AI response:", aiInsertError);
        return false;
      }
      
      debugLog("AI response saved successfully:", aiInsertData);
      return true;
    } catch (aiInsertErr) {
      console.error("Error during AI message insertion:", aiInsertErr);
      return false;
    }
  };

  // Function to handle saving edited messages
  const handleSaveEdit = async () => {
    if (!editingMessageId || !editingContent.trim()) return;

    try {
      // Use a copy of original messages to work with
      const originalMessagesCopy = [...originalMessages];
      const messageIndex = originalMessagesCopy.findIndex(m => m.id === editingMessageId);

      if (messageIndex === -1) {
        console.error("Message to edit not found in original messages");
        return;
      }

      const messageToEdit = originalMessagesCopy[messageIndex]; // Get the original message object

      // Create the updated message object
      const updatedMessage = {
        ...messageToEdit,
        content: editingContent,
        timestamp: new Date() // Use new timestamp for the edited message
      };

      // Determine if AI messages after the edited one need removal
      const hasAssistantMessagesAfter = originalMessagesCopy
        .slice(messageIndex + 1)
        .some(m => m.role === "assistant");

      // Prepare the new messages array for the UI
      let newMessagesForUI;
      
      if (hasAssistantMessagesAfter) {
        // Keep messages before the edited one, then add the updated message
        newMessagesForUI = [
          ...originalMessagesCopy.slice(0, messageIndex),
          updatedMessage
        ];
      } else {
        // Create a new array excluding the original, then add the updated one
        newMessagesForUI = [
            ...originalMessagesCopy.filter(msg => msg.id !== editingMessageId),
            updatedMessage
        ];
      }

      // Update UI state *before* database operations
      setMessages(newMessagesForUI);

      // Reset editing state immediately after UI update
      const savedEditingMessageId = editingMessageId; // Save for DB ops
      setEditingMessageId(null);
      setEditingContent("");
      setOriginalMessages([]); // Clear the saved original state

      // Database Operations: Delete original, Insert new
      if (currentChatId) {
        try {
          // 1. Delete subsequent AI messages if necessary
          if (hasAssistantMessagesAfter) {
            console.log("DB: Deleting subsequent AI messages after", messageToEdit.timestamp.toISOString());
            const { error: deleteSubsequentError } = await supabase
              .from("chat_messages")
              .delete()
              .eq("chat_id", currentChatId)
              .gt("created_at", messageToEdit.timestamp.toISOString()); // Match based on original timestamp
            if (deleteSubsequentError) console.error("DB: Error deleting subsequent messages:", deleteSubsequentError);
            else console.log("DB: Subsequent AI messages deleted.");
          }

          // 2. Delete the *original* message from the database
          console.log(`DB: Deleting original message (created at ${messageToEdit.timestamp.toISOString()})`);
          const { error: deleteOriginalError } = await supabase
            .from("chat_messages")
            .delete()
            .eq("chat_id", currentChatId)
            .eq("created_at", messageToEdit.timestamp.toISOString()); // Match original by timestamp
          
          if (deleteOriginalError) {
            console.error("DB: Error deleting original message:", deleteOriginalError);
            // Consider handling this error more gracefully, maybe revert UI?
          } else {
            console.log("DB: Original message deleted successfully.");

            // 3. Insert the *new* edited message
            console.log("DB: Inserting edited message");
            const { data: insertData, error: insertError } = await supabase
              .from("chat_messages")
              .insert({
                chat_id: currentChatId,
                role: updatedMessage.role,
                content: updatedMessage.content,
                user_id: updatedMessage.user_id,
                sentfrom: updatedMessage.sentfrom,
                created_at: updatedMessage.timestamp.toISOString() // Use the new timestamp
              })
              .select(); // Select the inserted row to get its DB ID if needed
            
            if (insertError) {
              console.error("DB: Error inserting edited message:", insertError);
              // Consider reverting UI or showing error
            } else {
              console.log("DB: Edited message inserted successfully.");
              const insertedDbMessageId = insertData?.[0]?.id; // Get DB ID if available
              
              // Create embedding for the newly inserted edited message
              if (insertedDbMessageId) {
                // We need the full Message object with the DB ID for embedding potentially
                 const embeddingMessage = { ...updatedMessage, id: insertedDbMessageId }; // Use DB id if needed by embedding
                 const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
                 createEmbedding(embeddingMessage, currentChatId, workspaceIdToUse)
                  .catch(err => console.error("Edited message embedding failed:", err));
              }

              // 4. Regenerate AI response if necessary (only after successful insert)
              if (hasAssistantMessagesAfter) {
                console.log("Regenerating AI response after edit...");
                setIsTyping(true); // Show typing indicator for regeneration
                setMessageUpdatePending(true); // Prevent other actions during regen
                try {
                    const modelToUse = selectedTask?.ai_model || selectedModel
                    const response = await sendMessageToAPI(
                        newMessagesForUI, // Use the corrected message list for the API
                        modelToUse,
                        currentChatId
                    );

                    // Handle streaming response for the regenerated message
                    const assistantMessageId = uuidv4();
                    const assistantMessage: Message = {
                        id: assistantMessageId,
                        role: "assistant",
                        content: "",
                        timestamp: new Date(),
                        isTypewriting: true
                    };
                    
                    setMessages(prev => [...prev, assistantMessage]);
                    setTypingMessageId(assistantMessageId);

                    if (response.streamContent) {
                      let collectedContent = "";
                      const contentGenerator = response.streamContent();
                      const messageIdToUpdate = assistantMessageId;
                      
                      for await (const chunk of contentGenerator) {
                        let processedChunk = chunk;
                        try {
                          if (chunk.trim().startsWith('{') && chunk.trim().endsWith('}')) {
                            const jsonChunk = JSON.parse(chunk);
                            if (jsonChunk && typeof jsonChunk.content === 'string') {
                              processedChunk = jsonChunk.content;
                            }
                          }
                        } catch (e) { /* Ignore parsing errors, use chunk */ }
                        
                        collectedContent += processedChunk;
                        setMessages(prev => prev.map(msg => msg.id === messageIdToUpdate ? { ...msg, content: collectedContent, isTypewriting: true } : msg));
                      }
                      assistantMessage.content = collectedContent || response.content;
                       setMessages(prev => prev.map(msg => msg.id === messageIdToUpdate ? { ...msg, content: assistantMessage.content } : msg)); // Final update
                      
                    } else {
                       assistantMessage.content = response.content;
                       setMessages(prev => prev.map(msg => msg.id === assistantMessageId ? { ...msg, content: assistantMessage.content } : msg)); // Use assistantMessageId here
                    }
                    
                   // Save regenerated AI message to DB & create embedding
                    let dbAssistantId = null;
                    try {
                      const { data: assistantData, error: assistantError } = await supabase
                        .from("chat_messages")
                        .insert({
                          chat_id: currentChatId,
                          role: "assistant",
                          content: assistantMessage.content,
                          created_at: assistantMessage.timestamp.toISOString()
                        })
                        .select();

                      if (assistantError) console.error("‚ùå Error saving regenerated assistant message:", assistantError)
                      else {
                         console.log("‚úÖ Regenerated AI message saved to database", assistantData)
                         dbAssistantId = assistantData?.[0]?.id;
                         if (dbAssistantId) {
                             const dbAssistantMessage = { ...assistantMessage, id: dbAssistantId };
                             const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
                             createEmbedding(dbAssistantMessage, currentChatId, workspaceIdToUse)
                               .catch(err => console.error("Regenerated assistant embedding failed:", err));
                         }
                      }
                    } catch (saveError) { console.error("Error saving regenerated assistant message:", saveError); }

                } catch (regenError) {
                    console.error("Error regenerating AI response:", regenError);
                    // Add error message to UI?
                } finally {
                    setIsTyping(false);
                    setMessageUpdatePending(false);
                    // Assuming assistantMessageId IS defined in this scope, despite linter warning
                    handleTypewriterComplete(assistantMessageId); // Ensure typewriter stops
                }
              }
            }
          }
        } catch (dbError) {
          console.error("DB: Operation failed:", dbError);
        }
      }
    } catch (err) {
      console.error("Error in handleSaveEdit:", err);
      // Ensure UI state is reset even if there's an error
       if (editingMessageId) {
          cancelEditMessage(); // Attempt to restore original state if possible
       }
    }
  };

  // Updated function to regenerate AI response
  const regenerateResponse = async (aiMessageId: string) => {
    setTypingMessageId(null)

    const aiMessageIndex = messages.findIndex(m => m.id === aiMessageId)
    if (aiMessageIndex === -1 || aiMessageIndex === 0) return // Cannot regenerate if it's the first message or not found

    const userMessageIndex = aiMessageIndex - 1
    if (messages[userMessageIndex].role !== "user") return // Should be preceded by a user message

    const userMessageToResend = messages[userMessageIndex]

    // Keep messages up to the preceding user message
    const messagesToKeep = messages.slice(0, userMessageIndex + 1)

    // Update UI state
    setMessages(messagesToKeep)

    // Delete the AI message and subsequent ones from DB
    if (currentChatId) {
      supabase
        .from("chat_messages")
        .delete()
        .eq("chat_id", currentChatId)
        .gte("created_at", messages[aiMessageIndex].timestamp.toISOString())
        .then(({ error }) => {
          if (error) {
            console.error("Error deleting messages for regeneration:", error)
          } else {
            console.log("Messages deleted for regeneration from DB")
          }
        })
    }

    // Resend the user message that led to this AI response
    await handleSendMessage(userMessageToResend.content)
  }

  // Add another function to retry failed database operations with logging
  const retryOperation = async (
    operation: () => Promise<any>,
    maxRetries = 3,
    delay = 500
  ) => {
    let lastError
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation()
      } catch (err) {
        lastError = err
        console.error(
          `Operation failed (attempt ${attempt}/${maxRetries}):`,
          err
        )

        if (attempt < maxRetries) {
          console.log(`Retrying in ${delay}ms...`)
          await new Promise(resolve => setTimeout(resolve, delay))
          delay *= 2 // Exponential backoff
        }
      }
    }
    throw lastError
  }

  // Simplified deleteChat function that works with the consolidated database structure
  const deleteChat = async (chatId: string) => {
    try {
      // Close any open menus
      setChatMenuOpen(null)

      console.log("Starting delete process for chat:", chatId)

      // With the ON DELETE CASCADE constraint, we only need to delete the chat
      // All associated messages will be automatically deleted
      const { error } = await supabase
        .from("chats")
        .delete()
        .eq("id", chatId)
        .eq("user_id", user.id)

      if (error) {
        console.error("Error deleting chat:", error)
        return
      }

      console.log("Chat and all associated messages deleted successfully")

      // Remove from state
      setChatSessions(prevSessions =>
        prevSessions.filter(chat => chat.id !== chatId)
      )

      // If the deleted chat was the current one, load another chat
      if (currentChatId === chatId) {
        // Get a fresh list of remaining chats after removing the deleted one
        const remainingChats = [...chatSessions].filter(
          chat => chat.id !== chatId
        )

        if (remainingChats.length > 0) {
          const nextChatId = remainingChats[0].id
          console.log("Switching to next chat:", nextChatId)
          setCurrentChatId(nextChatId)
        } else {
          console.log("No chats remaining, clearing state")
          setCurrentChatId(null)
          setMessages([])
        }
      }

      // Reload chats from database to ensure we have fresh data
      await loadChatSessions(user.id, rawWorkspaceId || null)

      console.log("Chat successfully deleted:", chatId)
    } catch (err) {
      console.error("Error in deleteChat:", err)
    }
  }

  // Add function to open rename modal
  const openRenameModal = (chat: ChatSession) => {
    setChatToRename(chat)
    setNewChatName(chat.name)
    setRenameModalOpen(true)
    setChatMenuOpen(null)
  }

  // Start inline edit for a chat
  const startInlineEdit = (chat: ChatSession, e: React.MouseEvent) => {
    e.stopPropagation() // Verhindere Bubble-Up zum Button
    setEditingChatId(chat.id)
    setNewChatName(chat.name)
    setChatMenuOpen(null)
  }

  // Handle focus loss on inline edit
  const handleInlineEditBlur = async () => {
    if (editingChatId && newChatName.trim()) {
      // Finde den Chat
      const chatToUpdate = chatSessions.find(chat => chat.id === editingChatId)
      if (chatToUpdate) {
        try {
          // Update in DB
          const { error } = await supabase
            .from("chats")
            .update({ name: newChatName })
            .eq("id", editingChatId)
            .eq("user_id", user.id)

          if (error) {
            console.error("Error renaming chat:", error)
          } else {
            // Update local state
            setChatSessions(prevSessions =>
              prevSessions.map(chat =>
                chat.id === editingChatId
                  ? { ...chat, name: newChatName }
                  : chat
              )
            )
          }
        } catch (err) {
          console.error("Error in inline chat rename:", err)
        }
      }
    }
    // Reset edit state
    setEditingChatId(null)
    setNewChatName("")
  }

  // Submit inline edit with enter key
  const handleInlineEditKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault()
      handleInlineEditBlur()
    } else if (e.key === "Escape") {
      e.preventDefault()
      setEditingChatId(null)
      setNewChatName("")
    }
  }

  // Simplified function to handle chat renaming
  const handleRenameChat = async () => {
    if (!chatToRename || !newChatName.trim()) return

    try {
      const { error } = await supabase
        .from("chats")
        .update({ name: newChatName })
        .eq("id", chatToRename.id)
        .eq("user_id", user.id)

      if (error) {
        console.error("Error renaming chat:", error)
        return
      }

      console.log("Chat renamed successfully")

      // Update in state
      setChatSessions(prevSessions =>
        prevSessions.map(chat =>
          chat.id === chatToRename.id ? { ...chat, name: newChatName } : chat
        )
      )

      // Close modal
      setRenameModalOpen(false)
      setChatToRename(null)
      setNewChatName("")

      // Reload chats to ensure state is in sync
      await loadChatSessions(user.id, rawWorkspaceId || null)
    } catch (err) {
      console.error("Error in handleRenameChat:", err)
    }
  }

  const deleteProject = async (projectId: string) => {
    try {
      setError(null)
      setProjectMenuOpen(null)

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null

      // --- BERECHTIGUNGSPR√úFUNG ---
      // Diese Pr√ºfung schl√§gt aktuell fehl (PGRST116) und muss behoben werden!
      const { data: memberData, error: memberError } = await supabase
        .from("workspace_members")
        .select("role")
        .eq("workspace_id", workspaceContext)
        .eq("user_id", user.id)
        .single() // <- Findet 0 Zeilen!

      if (memberError) {
        console.error("Fehler beim Pr√ºfen der Berechtigung:", memberError)
        // Zeige den Fehler an, aber kehre *noch nicht* zur√ºck,
        // damit der Rest der Funktion f√ºr den Fall ausgef√ºhrt wird, dass die Pr√ºfung *korrekt* w√§re.
        // In der finalen Version sollte hier ein `return` stehen.
        setError(`Berechtigungsfehler: ${memberError.message}`)
        return // <-- Wichtig: Reaktiviert!
      } else if (!memberData || !["admin", "owner"].includes(memberData.role)) {
        setError(
          "Nur Workspace-Administratoren oder Eigent√ºmer k√∂nnen Projekte l√∂schen."
        )
        return // Hier ist der Return OK.
      }
      // --- ENDE BERECHTIGUNGSPR√úFUNG ---

      if (
        !confirm(
          `Projekt "${projects.find(p => p.id === projectId)?.name}" wirklich l√∂schen?`
        )
      ) {
        return
      }

      // L√∂sche das Projekt
      const { error: deleteError } = await supabase
        .from("projects")
        .delete()
        .eq("id", projectId)

      if (deleteError) {
        console.error("Error deleting project:", deleteError)
        setError(`Fehler beim L√∂schen des Projekts: ${deleteError.message}`)
        return // Beende bei L√∂schfehler
      }

      console.log("‚úÖ Projekt erfolgreich gel√∂scht. Lade Daten neu...")

      // --- DATEN NEU LADEN statt lokalen State zu patchen ---
      setLoading(true) // Ladeindikator anzeigen
      try {
        // Lade Projekte und Chats neu
        if (user) {
          await loadProjects(user.id, workspaceContext)
          await loadChatSessions(user.id, workspaceContext)
        }

        // Setze abh√§ngige Zust√§nde zur√ºck
        if (selectedProject?.id === projectId) {
          setSelectedProject(null)
        }
        // Finde Chats, die zu diesem Projekt geh√∂ren (basierend auf dem *alten* State vor dem Reload)
        const chatsInProjectToDelete = chatSessions.filter(
          chat => chat.project_id === projectId
        )
        if (
          editingChatId &&
          chatsInProjectToDelete.some(chat => chat.id === editingChatId)
        ) {
          setEditingChatId(null)
          setNewChatName("")
        }
        // expandedProjects muss nicht manuell bereinigt werden, da es von 'projects' abh√§ngt
      } catch (reloadError) {
        console.error(
          "Fehler beim Neuladen der Daten nach Projektl√∂schung:",
          reloadError
        )
        setError(
          "Projekt gel√∂scht, aber Fehler beim Aktualisieren der Ansicht."
        )
      } finally {
        setLoading(false)
      }
    } catch (err) {
      // Dieser Catch ist jetzt haupts√§chlich f√ºr unerwartete Fehler
      console.error("Unexpected error in deleteProject:", err)
      setError("Ein unerwarteter Fehler ist aufgetreten.")
    }
  }

  const updateProject = async () => {
    if (!projectToRename || !newProjectName.trim()) return

    try {
      setLoading(true)

      const { data, error } = await supabase
        .from("projects")
        .update({
          name: newProjectName,
          description: newProjectDescription,
          updated_at: new Date().toISOString()
        })
        .eq("id", projectToRename.id)
        .select()

      if (error) throw error

      // Aktualisiere Projektliste
      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
      await loadProjects(user.id, workspaceContext)

      // Wenn das bearbeitete Projekt ausgew√§hlt war, aktualisiere die Auswahl
      if (selectedProject?.id === projectToRename.id && data?.[0]) {
        setSelectedProject(data[0])
      }

      // Modal schlie√üen
      setShowProjectModal(false)
      setProjectToRename(null)
      setNewProjectName("")
      setNewProjectDescription("")
    } catch (err) {
      console.error("Error updating project:", err)
    } finally {
      setLoading(false)
    }
  }

  // Chat einem Projekt zuweisen
  const assignChatToProject = async (
    chatId: string,
    projectId: string | null
  ) => {
    try {
      console.log(
        `Zuweisen von Chat ${chatId} zu Projekt ${projectId || "none"}`
      )

      // Update in der Datenbank
      const { error } = await supabase
        .from("chats")
        .update({
          project_id: projectId,
          // Auch last_message_timestamp aktualisieren, damit die Sortierung korrekt bleibt
          last_message_timestamp: new Date().toISOString()
        })
        .eq("id", chatId)

      if (error) throw error

      // Update im lokalen State
      setChatSessions(prev =>
        prev.map(chat =>
          chat.id === chatId ? { ...chat, project_id: projectId } : chat
        )
      )

      // Lade Chats neu, um sicherzustellen, dass die UI korrekt aktualisiert wird
      if (user) {
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
        // Verz√∂gerung einbauen, damit die Datenbank Zeit hat, die √Ñnderung zu verarbeiten
        setTimeout(async () => {
          await loadChatSessions(user.id, workspaceContext)
        }, 300)
      }

      console.log(
        `Chat ${chatId} wurde ${projectId ? `Projekt ${projectId}` : "keinem Projekt"} zugewiesen`
      )
    } catch (err) {
      console.error("Fehler beim Zuweisen des Chats:", err)
      setError("Fehler beim Zuweisen des Chats zu einem Projekt")
    }
  }

  // Erg√§nze die Message-Komponente
  const Message = ({
    message,
    isTyping
  }: {
    message: Message
    isTyping?: boolean
  }) => {
    const isUser = message.role === "user"
    const messageRef = useRef<HTMLDivElement>(null)

    // Detect and format HTML code
    const formatCodeInMessage = (content: string): string => {
      // If content already has markdown code blocks, don't modify
      if (content.includes("```")) return content;
      
      // Check if the content appears to be HTML
      if (
        content.trim().startsWith("<") && 
        (content.includes("<!DOCTYPE") || 
         content.includes("<html") ||
         (content.includes("<body") && content.includes("</body>")) ||
         (content.includes("<head") && content.includes("</head>")))
      ) {
        return "```html\n" + content + "\n```";
      }
      
      return content;
    };

    // Add effect to ensure message is visible
    useEffect(() => {
      // Only scroll into view for the most recent message
      if (messageRef.current && !isTyping) {
        messageRef.current.scrollIntoView({ behavior: "smooth", block: "end" })
      }
    }, [message.id, isTyping])

    if (message.role === "system") {
      return null // System-Nachrichten nicht anzeigen
    }

    // Calculate whether to show the effect
    const showEffect = message.role === "assistant" && (message.isTypewriting || typingMessageId === message.id);

    return (
      <div
        ref={messageRef}
        className={`w-full ${isUser ? "bg-transparent" : "bg-gray-800"}`}
        data-message-id={message.id}
      >
        <div className="mx-auto max-w-xl px-8 pt-0 pb-1">
          <div className={`flex items-start gap-1 ${isUser ? "justify-end" : "justify-start"}`}>
            {!isUser && (
              <div className="flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full bg-gray-600 text-white">
                AI
              </div>
            )}
            <div className={`${isUser ? "max-w-[65%]" : "max-w-[65%]"}`}>
              {showEffect ? (
                <div className="text-left">
                {/* Replace TypewriterEffect with RevealEffect */}
                <RevealEffect
                  content={message.content}
                  onComplete={() => handleTypewriterComplete(message.id)}
                />
                </div>
              ) : (
                <div className="text-left">
                  {(() => {
                    let displayContent = message.content;
                    try {
                      // Check if content is JSON with a content field
                      if (message.content.trim().startsWith('{') && message.content.trim().endsWith('}')) {
                        const jsonContent = JSON.parse(message.content);
                        if (jsonContent && typeof jsonContent.content === 'string') {
                          displayContent = jsonContent.content;
                        }
                      }
                    } catch (e) {
                      // If parsing fails, use the original content
                    }
                    return <MessageMarkdown content={displayContent} />;
                  })()}
                </div>
              )}
            </div>
            {isUser && (
              <div className="flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full bg-blue-600 text-white">
                U
              </div>
            )}
          </div>
        </div>
      </div>
    )
  }

  // Add this new useEffect to listen for changes to personalWorkspaceId
  useEffect(() => {
    // Skip if no personal workspace or if we already have chat sessions
    if (!personalWorkspaceId || initialChatsLoadedRef.current || !user) {
      return;
    }
    
    console.log("Personal workspace ID available, loading initial data:", personalWorkspaceId);
    
    // Mark as loaded to prevent multiple executions
    initialChatsLoadedRef.current = true;
    
    const loadInitialData = async () => {
      try {
        // Use the direct query approach to ensure we get the latest data
        let query = supabase
          .from("chats")
          .select(
            "id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id"
          )
          .eq("workspace_id", personalWorkspaceId)
          .order("last_message_timestamp", { ascending: false });

        const { data, error } = await query;

        if (error) {
          console.error("Error loading initial chats:", error);
          return;
        }

        if (data && data.length > 0) {
          console.log("Found existing chats:", data.length);
          const formattedSessions = data.map((chat: any) => ({
            id: chat.id || "",
            name: chat.name || "Unnamed Chat",
            created_at: chat.created_at || new Date().toISOString(),
            project_id: chat.project_id,
            user_id: chat.user_id,
            last_message_timestamp: chat.last_message_timestamp,
            ...(chat.description && { description: chat.description })
          }));

          setChatSessions(formattedSessions);

          // Set current chat if not already set
          if (!currentChatId) {
            console.log("Setting current chat to:", data[0].id);
            setCurrentChatId(data[0].id);
            await loadChat(data[0].id);
          }
        } else {
          console.log("No chats found for personal workspace, will create one on first message");
        }
      } catch (err) {
        console.error("Error in loadInitialData:", err);
      }
    };

    loadInitialData();
  }, [personalWorkspaceId, user, supabase]); // Removed currentChatId and chatSessions dependencies

  // Funktion zum Generieren und Setzen des Chat-Titels via AI
  const generateAndSetChatTitle = async (
    chatId: string,
    firstUserMessage: string
  ) => {
    console.log(
      `‚ú® Generating title for chat ${chatId} based on: "${firstUserMessage}"`
    )
    try {
      // NEUE DIREKTE IMPLEMENTATION:
      // Statt sendMessageToAPI zu nutzen, machen wir den API Call direkt hier
      // um Fehler durch komplexe State-Handling-Logic in sendMessageToAPI zu vermeiden

      const prompt = `Analysiere die folgende Benutzernachricht und generiere einen kurzen, pr√§gnanten Titel (maximal 4 W√∂rter) f√ºr diesen Chat. Gib NUR den Titel zur√ºck, ohne Anf√ºhrungszeichen oder zus√§tzliche Erkl√§rungen:\n\nNachricht: "${firstUserMessage}"\n\nTitel:`

      // Direkte Anfrage an unsere API-Route
      const response = await fetch("/api/chat", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [{ role: "user", content: prompt }],
          model: "Fast" // Schnelles Modell verwenden
        })
      })

      if (!response.ok) {
        throw new Error(`API request failed: ${response.status}`)
      }

      const data = await response.json()
      let generatedTitle = data?.content?.trim() || null

      console.log(`üëã API response for title generation:`, data)

      if (generatedTitle) {
        console.log(`‚ú® AI generated title: "${generatedTitle}"`)

        // Entferne m√∂gliche Anf√ºhrungszeichen am Anfang/Ende
        generatedTitle = generatedTitle.replace(/^"|"$/g, "")

        // Kurzen Fallback, falls Titel leer wird
        if (!generatedTitle.trim()) {
          generatedTitle = generateChatName(firstUserMessage) // Fallback zur alten Methode
          console.log(
            `‚ú® AI title was empty, using fallback: "${generatedTitle}"`
          )
        }

        // Update Datenbank
        const { error: updateError } = await supabase
          .from("chats")
          .update({ name: generatedTitle })
          .eq("id", chatId)

        if (updateError) {
          console.error("‚ùå Error updating chat name in DB:", updateError)
        } else {
          console.log(
            `‚úÖ Chat ${chatId} name updated in DB to: "${generatedTitle}"`
          )
          // Update UI State
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: generatedTitle } : chat
            )
          )
        }
      } else {
        console.warn("‚ö†Ô∏è AI did not return a valid title.")
        // Optional: Fallback zur alten Methode, wenn AI versagt
        const fallbackTitle = generateChatName(firstUserMessage)
        const { error: updateError } = await supabase
          .from("chats")
          .update({ name: fallbackTitle })
          .eq("id", chatId)
        if (!updateError) {
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: fallbackTitle } : chat
            )
          )
        }
      }
    } catch (error) {
      console.error("‚ùå Error generating or setting chat title:", error)
      // Hier nicht abbrechen, Chat funktioniert trotzdem weiter

      // Fallback zur einfachen Methode bei Fehlern
      try {
        const fallbackTitle = generateChatName(firstUserMessage)
        console.log(`‚ö†Ô∏è Using fallback title due to error: "${fallbackTitle}"`)

        const { error: updateError } = await supabase
          .from("chats")
          .update({ name: fallbackTitle })
          .eq("id", chatId)

        if (!updateError) {
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: fallbackTitle } : chat
            )
          )
        }
      } catch (fbError) {
        console.error("‚ùå Even fallback title setting failed:", fbError)
      }
    }
  }

  // F√ºge Event-Listener f√ºr Klicks au√üerhalb der Edit-Box hinzu
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        editBoxRef.current &&
        !editBoxRef.current.contains(event.target as Node) &&
        editingMessageId
      ) {
        cancelEditMessage()
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [editingMessageId])

  // Handle Joyride callback
  const handleJoyrideCallback = (data: CallBackProps) => {
    const { action, index, status, type } = data

    if (type === "step:before" && index === 2) {
      // Show fake messages for message actions
      setShowFakeMessagesForTour(true)
      // Instead of continuing with the tour, show our custom dialog
      setShowMessageActionsDialog(true)
      // Pause the tour
      setRunTour(false)
    } else if (type === "step:after" && index === 2) {
      // Clear fake messages after the step
      setShowFakeMessagesForTour(false)
    }

    if (action === "reset" || status === STATUS.FINISHED) {
      setRunTour(false)
      setShowFakeMessagesForTour(false)
      setShowMessageActionsDialog(false)
    }

    if (type === "step:after") {
      setStepIndex(index + 1)
    }
  }

  // Function to start the tour at a specific step
  const startTourAt = (index: number) => {
    setStepIndex(index)
    // Use timeout to ensure UI elements are rendered, especially if sidebar visibility changes
    setTimeout(() => {
      setRunTour(true)
    }, 100) // Small delay might be needed
  }

  // Function to handle "Deep Research" button click
  const handleDeepResearch = async () => {
    if (!inputValue.trim()) return // Do nothing if input is empty

    // Use the enhanced handleSendMessage with web search enabled
    await handleSendMessage(inputValue.trim(), true)
  }

  // Handle PDF export with message selection
  const handleExportPdf = (
    selection: "all" | "last5" | "last10" | number[]
  ) => {
    try {
      const chatName =
        chatSessions.find(chat => chat.id === currentChatId)?.name || "Chat"
      downloadChatAsPdf(messages, chatName, selection)
    } catch (error) {
      console.error("Error exporting chat:", error)
      // You could add an error state and show a notification here
    }
  }

  // Handle chat summary generation
  const handleGenerateSummary = async () => {
    if (messages.length < 2) {
      // F√ºge eine Nachricht hinzu, wenn nicht genug Nachrichten vorhanden sind
      const errorMessage: Message = {
        id: uuidv4(),
        role: "assistant",
        content: "Es gibt nicht gen√ºgend Nachrichten f√ºr eine Zusammenfassung.",
        timestamp: new Date()
      }
      setMessages(prevMessages => [...prevMessages, errorMessage])
      return
    }

    // Zeige einen Ladeindikator im Chat
    const loadingMessage: Message = {
      id: uuidv4(),
      role: "assistant",
      content: "Erstelle eine Zusammenfassung des bisherigen Chats...",
      timestamp: new Date(),
      isTypewriting: true
    }

    const loadingMessageId = loadingMessage.id
    setMessages(prevMessages => [...prevMessages, loadingMessage])
    setIsTyping(true)

    try {
      // Generiere die Zusammenfassung
      const summary = await generateChatSummary(messages)

      // Ersetze die Lade-Nachricht mit der tats√§chlichen Zusammenfassung
      setMessages(prevMessages =>
        prevMessages.map(msg =>
          msg.id === loadingMessageId
            ? { ...msg, content: summary, isTypewriting: false }
            : msg
        )
      )

      // Speichere die Nachricht in der Datenbank, wenn ein Chat aktiv ist
      if (currentChatId) {
        console.log("üí¨ Saving summary message for chat:", currentChatId)

        try {
          const { error: messageError } = await supabase
            .from("chat_messages")
            .insert({
              chat_id: currentChatId,
              role: "assistant",
              content: summary,
              user_id: user?.id, // Make sure user_id is included in database insert
              created_at: new Date().toISOString()
            })

          if (messageError) {
            console.error("‚ùå Error saving summary message:", messageError)
          } else {
            console.log("‚úÖ Summary message saved")
            // REMOVE: Reloading chat list is likely causing the issue
            // if (user) {
            //   await loadChatSessions(user.id, rawWorkspaceId || null);
            // }
          }
        } catch (dbError) {
          console.error("Database error saving summary:", dbError)
        }
      }
    } catch (error) {
      console.error("Error generating summary:", error)

      // Ersetze die Lade-Nachricht mit einer Fehlermeldung
      setMessages(prevMessages =>
        prevMessages.map(msg =>
          msg.id === loadingMessageId
            ? {
                ...msg,
                content:
                  "Bei der Erstellung der Zusammenfassung ist ein Fehler aufgetreten. Bitte versuche es sp√§ter erneut.",
                isTypewriting: false
              }
            : msg
        )
      )
    } finally {
      setIsTyping(false)
    }
  }

  const chatSessionsWithProjectInfo = chatSessions.map(chat => {
    const assignedProject = projects.find(
      project => chat.project_id === project.id
    )
    return {
      ...chat,
      assignedProjectName: assignedProject?.name || null
    }
  })

  // Nicht zugewiesene Chats filtern - Optimize with proper memoization
  const unassignedChats = useMemo(() => {
    console.debug("Calculating unassigned chats from", chatSessions.length, "available chats");
    return chatSessions.filter(chat => chat.project_id === null);
  }, [chatSessions]); // Only recalculate when chatSessions changes

  // Chats nach Projekten gruppieren - Optimize with proper dependencies
  const chatsByProject = useMemo(() => {
    console.debug("Calculating chats by project from", chatSessions.length, "available chats");
    // Kopiere die Projekte und f√ºge die zugeh√∂rigen Chats hinzu
    return projects.map(project => {
      const projectChats = chatSessions.filter(
        chat => chat.project_id === project.id
      );
      console.debug(`Project ${project.name} has ${projectChats.length} chats`);
      return {
        ...project,
        chats: projectChats
      };
    });
  }, [projects, chatSessions]); // Only recalculate when projects or chatSessions change

  // Toggle Funktion f√ºr das Aufklappen der Projekte
  const toggleProjectExpansion = (projectId: string) => {
    console.log("Toggling project expansion for", projectId)
    setExpandedProjects(prev => ({
      ...prev,
      [projectId]: !prev[projectId]
    }))

    // Wenn ein Projekt ausgew√§hlt wird, setzen wir es auch als aktives Projekt
    setSelectedProject(projects.find(p => p.id === projectId) || null)
  }

  // Hinzuf√ºgen einer Funktion, um anzuzeigen, ob ein Chat geladen ist
  const isActiveChat = (chatId: string): boolean => {
    return currentChatId === chatId
  }

  // Verbesserte Funktion zum Laden eines Chats
  const handleSelectChat = async (chatId: string) => {
    console.log(`Selecting chat: ${chatId}`)

    // Pr√ºfe, ob es ein g√ºltiger Chat ist
    const selectedChat = chatSessions.find(chat => chat.id === chatId)
    if (!selectedChat) {
      console.error(`Chat ${chatId} nicht in aktuellen Chat-Sessions gefunden!`)
      return
    }

    // Setze aktuellen Chat
    setCurrentChatId(chatId)

    // Lade Chat-Inhalte
    await loadChat(chatId)

    // Wenn der Chat zu einem Projekt geh√∂rt, stelle sicher, dass das Projekt aufgeklappt ist
    if (selectedChat.project_id) {
      console.log(
        `Chat geh√∂rt zu Projekt ${selectedChat.project_id}, klappe auf`
      )
      setExpandedProjects(prev => ({
        ...prev,
        [selectedChat.project_id!]: true
      }))
    }
  }

  if (error) {
    return (
      <div className="flex h-screen items-center justify-center bg-[var(--bg-primary)]">
        <div className="max-w-md rounded-lg border border-[var(--border-light)] bg-[var(--bg-tertiary)] p-6 text-center">
          <h2 className="mb-4 text-xl font-medium text-[var(--text-primary)]">
            Fehler
          </h2>
          <p className="mb-4 text-[var(--text-secondary)]">{error}</p>
          <Link
            href="/login"
            className="inline-flex rounded-md bg-[var(--accent-primary)] px-4 py-2 text-sm font-medium text-white hover:bg-[var(--accent-primary-hover)]"
          >
            Zum Login
          </Link>
        </div>
      </div>
    )
  }

  // Funktion, um einen neuen Chat zu beginnen (ohne ihn sofort zu erstellen)
  const startNewChat = () => {
    // Zur√ºcksetzen des Typing-Status f√ºr den neuen Chat
    setHasStartedTyping(false)
    
    // Bisheriger Code
    setMessages([])
    setCurrentChatId(null)
    setEditingMessageId(null)
    setEditingContent("")
    setSelectedTask(null)
    setInputValue("")
    
    // Ensure we're not showing fake messages
    setShowFakeMessagesForTour(false)
    
    // Set isStartingNewChat flag to prevent re-rendering
    isStartingNewChatRef.current = true;
    
    // URL aktualisieren
    const currentPath = window.location.pathname;
    const workspaceQuery = rawWorkspaceId ? `?workspace=${rawWorkspaceId}` : "";
    router.push(`${currentPath}${workspaceQuery}`);
    
    // Fokus auf Inputfeld
    setTimeout(() => {
      if (inputRef.current) {
        inputRef.current.focus();
      }
    }, 100);
  }

  // Add message search functionality
  const handleMessageSearch = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!messageSearchQuery.trim()) return

    try {
      setIsSearching(true)

      // Search in message content - fixed table name from messages to chat_messages
      const { data: messagesData, error: messagesError } = await supabase
        .from("chat_messages")
        .select("id, content, chat_id, created_at, chats(name)")
        .ilike("content", `%${messageSearchQuery}%`)
        .order("created_at", { ascending: false })
        .limit(20)

      if (messagesError) {
        console.error("Fehler bei der Suche in Nachrichten:", messagesError)
      }

      // Combine client-side chat results with server-side message results
      const messageResults = messagesData || []

      // Format message results
      const formattedResults = messageResults.map(result => ({
        id: `message-${result.id}`,
        content: result.content,
        chat_id: result.chat_id,
        created_at: result.created_at,
        chats: result.chats,
        type: "message"
      }))

      // Add any existing client-side filtered chat results
      const existingChatResults = messageSearchResults
        .filter(result => result.id?.startsWith("local-"))
        .map(result => ({ ...result, type: "chat" }))

      // Combine both types of results
      setMessageSearchResults([...formattedResults, ...existingChatResults])
      console.log(
        "Search results:",
        [...formattedResults, ...existingChatResults].length
      )
    } catch (err) {
      console.error("Fehler bei der Suche:", err)
    } finally {
      setIsSearching(false)
    }
  }

  // Update handleSearchInputChange to trigger search automatically after 3+ characters
  const handleSearchInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const query = e.target.value
    setMessageSearchQuery(query)

    // Client-side filtering of visible chats list when typing
    if (query.trim() === "") {
      setMessageSearchResults([])
    } else {
      // Filter chat sessions that match the query and convert to search result format
      const filteredChats = chatSessions
        .filter(chat => chat.name.toLowerCase().includes(query.toLowerCase()))
        .map(chat => ({
          id: `local-${chat.id}`,
          content: "Chat gefunden",
          chat_id: chat.id,
          created_at: chat.created_at,
          chats: { name: chat.name },
          type: "chat"
        }))

      setMessageSearchResults(filteredChats)

      // If query is 3+ characters, automatically trigger the full search
      if (query.trim().length >= 3) {
        // Create a debounced search function to avoid too many API calls
        clearTimeout(searchDebounceTimeout.current)
        searchDebounceTimeout.current = setTimeout(async () => {
          try {
            setIsSearching(true)

            // Search in message content - fixed table name from messages to chat_messages
            const { data: messagesData, error: messagesError } = await supabase
              .from("chat_messages")
              .select("id, content, chat_id, created_at, chats(name)")
              .ilike("content", `%${query}%`)
              .order("created_at", { ascending: false })
              .limit(20)

            if (messagesError) {
              console.error(
                "Fehler bei der Suche in Nachrichten:",
                messagesError
              )
            }

            // Combine client-side chat results with server-side message results
            const messageResults = messagesData || []

            // Format message results
            const formattedResults = messageResults.map(result => ({
              id: `message-${result.id}`,
              content: result.content,
              chat_id: result.chat_id,
              created_at: result.created_at,
              chats: result.chats,
              type: "message"
            }))

            // Combine both types of results
            setMessageSearchResults([...formattedResults, ...filteredChats])
          } catch (err) {
            console.error("Fehler bei der Suche:", err)
          } finally {
            setIsSearching(false)
          }
        }, 300) // 300ms debounce
      }
    }
  }

  const toggleMessageSearch = () => {
    setSearchOpen(!searchOpen)
    if (!searchOpen) {
      setMessageSearchQuery("")
      setMessageSearchResults([])
    }
  }

  const handleImprovePrompt = async () => {
    if (!newTaskSystemPrompt.trim()) return

    try {
      setIsImprovingPrompt(true)

      // Make API call to your reasoning model to improve the prompt
      const response = await fetch("/api/improve-prompt", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          prompt: newTaskSystemPrompt,
          userId: user.id
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => null)
        const errorMessage =
          errorData?.error || "Fehler beim Verbessern des Prompts"
        console.error("API Error:", errorData)
        throw new Error(errorMessage)
      }

      const data = await response.json()
      setNewTaskSystemPrompt(data.improvedPrompt)

      // Show success message -- Removed alert
      // alert(`Prompt erfolgreich verbessert! (Verwendet: ${data.modelUsed || 'GPT-Modell'})`);
    } catch (error: any) {
      console.error("Error improving prompt:", error)
      alert(
        `Fehler beim Verbessern des Prompts: ${error.message || "Unbekannter Fehler"}`
      )
    } finally {
      setIsImprovingPrompt(false)
    }
  }

  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])

  // Finde und ersetze das useEffect f√ºr die Nachrichten-Subscription
  useEffect(() => {
    // Wenn kein Chat ausgew√§hlt ist, nichts tun
    if (!currentChatId) {
      return;
    }
    
    debugLog(`Setting up message subscription for chat: ${currentChatId}`);
    
    // Cleanup function for the channel
    const cleanupChannel = () => {
      if (messagesChannelRef.current && supabase) {
        debugLog("Cleaning up previous message subscription");
        supabase.removeChannel(messagesChannelRef.current);
        messagesChannelRef.current = null;
      }
    };

    // Clean up previous channel before creating a new one
    cleanupChannel();
    
    // Configure realtime channel for chat_messages
    const channelId = `chat_messages_${currentChatId}`;
    const messagesChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "*", // INSERT, UPDATE, DELETE
          schema: "public",
          table: "chat_messages",
          filter: `chat_id=eq.${currentChatId}`
        },
        payload => {
          debugLog(`Realtime message update received for chat ${currentChatId}:`, payload.eventType);

          // Only handle new message insertions
          if (payload.eventType === "INSERT") {
            const newMsg = payload.new;
            
            // *** CRITICAL: Prevent duplicate messages by checking if we've processed this ID already
            if (processedMessageIds.has(newMsg.id)) {
              debugLog(`Skipping already processed message with ID: ${newMsg.id}`);
              return;
            }
            
            // Add to processed set
            processedMessageIds.add(newMsg.id);
            
            // Check if message from another user (not from this client)
            const msgSentByOtherUser = newMsg.user_id && newMsg.user_id !== user?.id;
            
            setMessages(prevMessages => {
              // Double-check for duplicate messages by content and timestamp
              const exists = prevMessages.some(
                msg =>
                  (msg.id === newMsg.id) || // Same ID 
                  (msg.content === newMsg.content &&
                  msg.role === newMsg.role &&
                  new Date(msg.timestamp).getTime() > Date.now() - 5000) // Recent similar message
              );

              if (!exists) {
                debugLog("Adding new message from realtime subscription");
                
                // Process content - strip date prefix if present
                let messageContent = newMsg.content;
                if (messageContent && typeof messageContent === 'string' && messageContent.startsWith('[Datum:') && messageContent.includes(']\n')) {
                  messageContent = messageContent.replace(/^\[Datum:[^\]]+\]\n/, '');
                }
                
                return [
                  ...prevMessages,
                  {
                    id: newMsg.id || uuidv4(),
                    role: newMsg.role as "user" | "assistant" | "system",
                    content: messageContent,
                    timestamp: new Date(newMsg.created_at),
                    user_id: newMsg.user_id,
                    sentfrom: newMsg.sentfrom
                  }
                ];
              }
              return prevMessages;
            });
          }
        }
      )
      .subscribe((status) => {
        debugLog(`Message subscription status for ${channelId}: ${status}`);
      });
    
    // Store the channel in the ref
    messagesChannelRef.current = messagesChannel;

    // Cleanup on unmount or when currentChatId changes
    return cleanupChannel;
  }, [currentChatId, supabase, user?.id]);

  // Realtime subscription f√ºr √Ñnderungen an Chats (insbesondere Projekt-Zuordnungen)
  useEffect(() => {
    // Wenn bereits eine Subscription existiert, nichts tun
    if (chatsChannelRef.current) {
      console.log("Chats subscription already exists, skipping creation");
      return;
    }

    if (user && supabase) {
      // Verwende einen konsistenten Namen
      const channelId = `chats_updates_global`;
      console.log(`Setting up realtime subscription for chats table: ${channelId}`);

      // Konfiguriere den Realtime-Channel f√ºr die chats Tabelle
      const chatsChannel = supabase
        .channel(channelId)
        .on(
          "postgres_changes",
          {
            event: "UPDATE", // Nur Updates √ºberwachen
            schema: "public",
            table: "chats"
          },
          payload => {
            console.log("Realtime chat update received:", payload);

            // Aktualisiere den lokalen State, wenn sich ein Chat √§ndert
            if (payload.eventType === "UPDATE") {
              const updatedChat = payload.new;

              // Aktualisiere den chatSessions-State
              setChatSessions(prevSessions => {
                // Avoid state updates if nothing changed
                const chatNeedsUpdate = prevSessions.some(
                  chat => 
                    chat.id === updatedChat.id && 
                    (chat.name !== updatedChat.name || chat.project_id !== updatedChat.project_id)
                );
                
                if (!chatNeedsUpdate) {
                  return prevSessions;
                }
                
                return prevSessions.map(chat =>
                  chat.id === updatedChat.id
                    ? {
                        ...chat,
                        name: updatedChat.name,
                        project_id: updatedChat.project_id
                      }
                    : chat
                );
              });
            }
          }
        )
        .subscribe((status) => {
          console.log(`Subscription status for ${channelId}:`, status);
        });
      
      // Speichere den Channel in der Ref
      chatsChannelRef.current = chatsChannel;

      // Cleanup beim Unmount oder wenn der Komponent neu geladen wird
      return () => {
        if (chatsChannelRef.current && supabase) {
          console.log("Cleaning up chats table subscription");
          supabase.removeChannel(chatsChannelRef.current);
          chatsChannelRef.current = null;
        }
      };
    }
    
    // Leere Cleanup-Funktion zur√ºckgeben, wenn keine Subscription erstellt wurde
    return () => {};
  }, [user, supabase]);  // Reduzierte Abh√§ngigkeiten

  // Hilfsfunktion, um Initialen aus User-ID oder E-Mail zu extrahieren
  const getUserInitials = (userId: string | undefined): string => {
    if (!userId) return "?"

    // Einfache Extraktionslogik - nimmt die ersten 2 Zeichen der userId
    // In einer realen Anwendung w√ºrde man hier den Namen des Benutzers abrufen
    return userId.substring(0, 2).toUpperCase()
  }

  // Funktion zum Erstellen und Speichern von Embeddings
  const createEmbedding = async (
    message: Message,
    chatId: string | null,
    workspaceId: string | null = null
  ) => {
    try {
      console.log("üîÑ Erstelle Embedding f√ºr Nachricht:", message.id)

      // UUID-Validierung: √úberpr√ºfe, ob message.id ein g√ºltiger String ist
      if (
        !message.id ||
        typeof message.id !== "string" ||
        message.id.trim() === ""
      ) {
        console.error("‚ùå Ung√ºltige message.id f√ºr Embedding:", message.id)
        console.error("Message Objekt:", JSON.stringify(message, null, 2))
        return null // Fr√ºher Abbruch bei ung√ºltiger ID
      }

      console.log("üì® Original Nachrichteninhalt:", message.content)

      // Current date formatted for embedding
      const currentDate = new Date().toISOString().split("T")[0] // Format: YYYY-MM-DD

      // Append date information to the content for embedding
      const contentWithDate = `[Datum: ${currentDate}]\n${message.content}`
      console.log(
        "üìÖ Nachrichteninhalt mit Datum f√ºr Embedding:",
        contentWithDate
      )

      // Wenn dies nur ein Embedding f√ºr die Suche ist (chatId ist null),
      // dann erstellen wir nur das Embedding ohne es zu speichern
      const isSearchOnly = chatId === null

      // OpenAI API f√ºr Embedding aufrufen
      console.log(
        "üß† Embedding wird generiert f√ºr Inhalt mit L√§nge:",
        contentWithDate.length
      )
      const response = await fetch("/api/embeddings", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          input: contentWithDate
        })
      })

      if (!response.ok) {
        throw new Error(`Embedding API responded with ${response.status}`)
      }

      const embeddingData = await response.json()
      console.log("‚úÖ Embedding erfolgreich generiert:")
      console.log("üìä Embedding-Dimensionen:", embeddingData.embedding.length)
      console.log(
        "üîç Embedding-Vorschau (erste 5 Werte):",
        embeddingData.embedding.slice(0, 5)
      )
      console.log(
        "üîç Embedding-Vorschau (letzte 5 Werte):",
        embeddingData.embedding.slice(-5)
      )

      // F√ºr Suchanfragen fr√ºhzeitig zur√ºckkehren, ohne zu speichern
      if (isSearchOnly) {
        console.log(
          "‚ÑπÔ∏è Suchmodus: Embedding wird nur generiert, nicht gespeichert"
        )
        return embeddingData.embedding
      }

      // Validiere chatId
      if (!chatId || typeof chatId !== "string" || chatId.trim() === "") {
        console.error("‚ùå Ung√ºltige chatId f√ºr Embedding:", chatId)
        return null // Fr√ºher Abbruch bei ung√ºltiger chatId
      }

      // In der Datenbank speichern
      const dbPayload = {
        message_id: message.id,
        chat_id: chatId,
        workspace_id: workspaceId || null, // Stelle sicher, dass null und nicht Leerstring gespeichert wird
        role: message.role,
        embedding: embeddingData.embedding,
        content_with_date: contentWithDate // Store the content with date in the new column
      }

      console.log("üíæ Speichere in DB mit Payload:", {
        message_id: dbPayload.message_id,
        chat_id: dbPayload.chat_id,
        workspace_id: dbPayload.workspace_id,
        role: dbPayload.role,
        content_with_date: contentWithDate.substring(0, 50) + "...", // Log truncated for readability
        embedding_length: embeddingData.embedding.length
      })

      const { data, error } = await supabase
        .from("message_embeddings")
        .insert(dbPayload)
        .select()

      if (error) {
        console.error("‚ùå Fehler beim Speichern des Embeddings:", error)
        throw error
      }
      console.log("‚úÖ Embedding gespeichert f√ºr Nachricht:", message.id)
      if (data) {
        console.log("üìù DB-Eintrag erstellt mit ID:", data[0]?.id)
      }

      return embeddingData.embedding
    } catch (error) {
      console.error("‚ùå Fehler beim Erstellen des Embeddings:", error)
      return null
    }
  }

  // Funktion zum Finden √§hnlicher Nachrichten f√ºr einen *Benutzer*
  const findSimilarMessages = async (query: string, userId: string) => {
    // Stelle sicher, dass eine userId vorhanden ist
    if (!userId) {
      console.error(
        "‚ùå User ID fehlt f√ºr die Suche nach √§hnlichen Nachrichten."
      )
      return []
    }

    try {
      console.log(`üîç Suche nach √§hnlichen Nachrichten f√ºr User ${userId}`)
      console.log(`üìù Suchanfrage: "${query}"`)

      // Embedding f√ºr die Abfrage erstellen
      console.log("üß† Generiere Embedding f√ºr Suchanfrage...")
      const response = await fetch("/api/embeddings", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          input: query
        })
      })

      if (!response.ok) {
        throw new Error(`Embedding API responded with ${response.status}`)
      }

      const embeddingData = await response.json()
      console.log("‚úÖ Embedding f√ºr Abfrage erfolgreich generiert")
      console.log(
        "üìä Query-Embedding-Dimensionen:",
        embeddingData.embedding.length
      )
      console.log(
        "üîç Query-Embedding-Vorschau (erste 5 Werte):",
        embeddingData.embedding.slice(0, 5)
      )

      // √Ñhnliche Nachrichten mit *neuer* Stored Procedure finden
      console.log(
        `üìû Rufe search_similar_messages RPC f√ºr User ${userId} auf (Schwellwert: 0.7, Max Ergebnisse: 10)`
      )
      const { data, error } = await supabase.rpc("search_similar_messages", {
        query_embedding: embeddingData.embedding,
        p_user_id: userId, // √úbergabe der User ID
        similarity_threshold: 0.7, // Erh√∂ht von 0.3 auf 0.7 f√ºr pr√§zisere Ergebnisse
        max_results: 10
      })

      if (error) {
        console.error("‚ùå Fehler in search_similar_messages RPC:", error)
        throw error
      }

      console.log(`üîé RPC Ergebnis: ${data?.length || 0} Nachrichten gefunden`)
      if (data && data.length > 0) {
        console.log("üìã Erste Ergebnisse (Rohdaten):", data.slice(0, 2))
      }

      // Filtere die Ergebnisse: Behalte Kontext-Nachrichten und ignoriere zu √§hnliche prim√§re Nachrichten
      const filteredData =
        data?.filter(
          (m: any) =>
            m.is_context || // immer Kontext-Nachrichten behalten
            m.similarity < 0.99 // Nur Hauptnachrichten filtern, nicht Kontext
        ) || []

      console.log(`üßπ Nach Filterung: ${filteredData.length} Nachrichten √ºbrig`)

      // Process messages to extract date information if present
      console.log(
        "üîÑ Verarbeite Nachrichten, um Datumsinformationen zu extrahieren..."
      )
      const processedData = filteredData.map((m: any) => {
        let displayContent = m.content
        let dateInfo = null

        // Extract date information if it's included in the format [Datum: YYYY-MM-DD]
        const dateMatch = m.content.match(/\[Datum: (\d{4}-\d{2}-\d{2})\]/)
        if (dateMatch) {
          dateInfo = dateMatch[1]
          // Remove the date prefix for display
          displayContent = m.content.replace(
            /\[Datum: \d{4}-\d{2}-\d{2}\]\n/,
            ""
          )
          console.log(
            `üìÖ Datum gefunden in Nachricht ${m.message_id}: ${dateInfo}`
          )
        } else {
          console.log(`‚ö†Ô∏è Kein Datum gefunden in Nachricht ${m.message_id}`)
        }

        return {
          ...m,
          displayContent,
          dateInfo,
          isContext: m.is_context || false // √úbernehme das Kontext-Flag
        }
      })

      console.log(
        `‚úÖ ${processedData.length} √§hnliche Nachrichten nach Filterung gefunden`
      )

      // Gruppiere zusammengeh√∂rige Nachrichten f√ºr bessere √úbersicht in Logs
      const contextGroups = new Map()

      processedData.forEach((m: any, index: number) => {
        const contextKey = m.isContext ? "context" : `main-${index}`

        console.log(
          `üîπ ${m.isContext ? "Kontext-Nachricht" : "Ergebnis"} #${index + 1}:`
        )
        console.log(`  ‚Ä¢ ID: ${m.message_id}`)
        console.log(`  ‚Ä¢ Chat: ${m.chat_id}`)
        console.log(`  ‚Ä¢ Rolle: ${m.role}`)
        console.log(`  ‚Ä¢ Datum: ${m.dateInfo || "Keines"}`)
        console.log(
          `  ‚Ä¢ √Ñhnlichkeit: ${m.similarity.toFixed(4)}${m.isContext ? " (Kontext)" : ""}`
        )
        console.log(
          `  ‚Ä¢ Inhalt: ${(m.displayContent || m.content).substring(0, 100)}${(m.displayContent || m.content).length > 100 ? "..." : ""}`
        )
      })

      // Sortiere die Ergebnisse: Prim√§re Nachricht, dann Kontext
      processedData.sort((a: any, b: any) => {
        // Behalte die bestehende Sortierung bei
        return a.isContext === b.isContext
          ? b.similarity - a.similarity // Bei gleichem Typ: Nach √Ñhnlichkeit absteigend
          : a.isContext
            ? 1
            : -1 // Prim√§re Nachrichten zuerst
      })

      return processedData
    } catch (error) {
      console.error("‚ùå Fehler beim Suchen √§hnlicher Nachrichten:", error)
      return []
    }
  }

  // Neue state-Variable, um zu verfolgen, ob der Benutzer bereits angefangen hat zu tippen
  const [hasStartedTyping, setHasStartedTyping] = useState(false)

  return (
    <div className="flex h-screen overflow-hidden bg-[#1e1e1e]">
      {/* Use DynamicJoyride instead of Joyride */}
      <DynamicJoyride
        steps={tourSteps}
        run={runTour}
        stepIndex={stepIndex}
        callback={handleJoyrideCallback}
        continuous={true}
        showProgress={false}
        showSkipButton={true}
        locale={{
          back: "Zur√ºck",
          close: "Schlie√üen",
          last: "Fertig",
          next: "Weiter",
          skip: "√úberspringen"
        }}
        disableOverlayClose={true}
        styles={{
          options: {
            zIndex: 10000,
            arrowColor: "#333333",
            backgroundColor: "#1e1e1e",
            primaryColor: "#ffffff",
            textColor: "#cccccc"
          },
          tooltipContainer: {
            textAlign: "left"
          },
          buttonNext: {
            backgroundColor: "#555555"
          },
          buttonBack: {
            marginRight: 10
          }
        }}
      />

      {/* Sidebar */}
      {showSidebar && (
        <aside
          id="chat-sidebar"
          className="flex h-screen shrink-0 flex-col rounded-r-xl border-r border-[#333333] bg-[#0d0d0d] p-0"
          style={{ width: "305px" }}
        >
          <div className="flex items-center justify-between border-b border-[#333333] p-4">
            {/* Replace H1 with Home Button */}
            <button
              onClick={() => router.push("/dashboard")}
              className="rounded p-1.5 text-gray-400 hover:bg-[#2d2d2d] hover:text-white"
              title="Dashboard"
            >
              <Home size={18} />
            </button>
            <div className="flex items-center space-x-2">
              {/* Search and Add buttons remain here */}
              <button
                onClick={toggleMessageSearch} // Corrected: Use toggleMessageSearch
                className="rounded p-1.5 text-gray-400 hover:bg-gray-800 hover:text-white"
                aria-label="Chats durchsuchen"
              >
                <Search size={16} />
              </button>
              <button
                id="new-chat-button"
                onClick={startNewChat}
                className="rounded p-1.5 text-gray-400 hover:bg-gray-800 hover:text-white"
                aria-label="Neuer Chat"
              >
                <Plus size={16} />
              </button>
            </div>
          </div>

          {/* Search Panel */}
          {searchOpen && (
            <div className="border-b border-[#333333] px-3 py-2">
              <form onSubmit={handleMessageSearch} className="mb-2">
                <div className="relative">
                  <input
                    type="text"
                    value={messageSearchQuery}
                    onChange={handleSearchInputChange}
                    placeholder="Suche in Chats..."
                    className="w-full rounded-md border border-[#333333] bg-[#1a1a1a] px-3 py-1.5 text-xs text-white focus:outline-none"
                    autoFocus
                  />
                  <button
                    type="submit"
                    className="absolute right-2 top-1/2 -translate-y-1/2"
                    disabled={isSearching}
                  >
                    <Search className="size-3 text-gray-400" />
                  </button>
                </div>
              </form>

              {isSearching ? (
                <div className="py-2 text-center">
                  <div className="inline-block size-3 animate-spin rounded-full border-2 border-gray-400 border-t-transparent"></div>
                </div>
              ) : messageSearchResults.length > 0 ? (
                <div className="max-h-60 overflow-y-auto rounded-md border border-[#333333] bg-[#1a1a1a]">
                  {messageSearchResults.map(result => (
                    <div
                      key={result.id}
                      onClick={() => {
                        if (result.chat_id) {
                          // Die neue Funktion verwenden, statt direkter API-Aufrufe
                          handleSelectChat(result.chat_id)
                          // Close search after selecting a result
                          setSearchOpen(false)
                        }
                      }}
                      className="block cursor-pointer border-b border-[#333333] p-2 last:border-0 hover:bg-[#272727]"
                    >
                      <div className="mb-1 flex items-center text-xs font-medium text-white">
                        {result.type === "chat" ? (
                          <>
                            <MessageCircle className="mr-1 size-3 text-gray-300" />
                            <span>Chat: {result.chats?.name || "Chat"}</span>
                          </>
                        ) : (
                          <>
                            <FileText className="mr-1 size-3 text-gray-400" />
                            <span>
                              Nachricht in: {result.chats?.name || "Chat"}
                            </span>
                          </>
                        )}
                      </div>
                      <p className="line-clamp-2 text-xs text-gray-400">
                        {result.type === "chat"
                          ? "Chat mit diesem Namen gefunden"
                          : result.content}
                      </p>
                      <div className="mt-1 text-[10px] text-gray-500">
                        {new Date(result.created_at).toLocaleString()}
                      </div>
                    </div>
                  ))}
                </div>
              ) : messageSearchQuery && !isSearching ? (
                <div className="py-2 text-center text-xs text-gray-400">
                  Keine Ergebnisse gefunden
                </div>
              ) : null}
            </div>
          )}

          {/* Chat List */}
          <div className="custom-scrollbar scrollbar-hide grow overflow-y-auto p-3">
            <div className="mb-4">
              <h2 className="mb-2 text-sm font-semibold uppercase text-[#999999]">
                Chats
              </h2>
              <div className="space-y-1">
                {unassignedChats.map(chatSession => (
                  <div
                    key={chatSession.id}
                    className="group flex items-center"
                    draggable="true"
                    onDragStart={e => {
                      e.dataTransfer.setData("chatId", chatSession.id)
                      setDraggedChatId(chatSession.id)
                    }}
                    onDragEnd={() => setDraggedChatId(null)}
                  >
                    <button
                      onClick={() => handleSelectChat(chatSession.id)}
                      className={cn(
                        "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                        isActiveChat(chatSession.id)
                          ? "bg-[#2d2d2d] text-white"
                          : "text-[#cccccc] hover:bg-[#222222]"
                      )}
                      style={{ maxWidth: "calc(100% - 40px)" }}
                    >
                      {editingChatId === chatSession.id ? (
                        <input
                          type="text"
                          value={newChatName}
                          onChange={e => setNewChatName(e.target.value)}
                          onBlur={handleInlineEditBlur}
                          onKeyDown={handleInlineEditKeyDown}
                          className="w-full rounded border border-[#444444] bg-[#333333] px-2 py-0.5 text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                          autoFocus
                          onClick={e => e.stopPropagation()}
                        />
                      ) : (
                        <div className="flex items-center">
                          <span
                            className="block flex-1 truncate"
                            title={chatSession.name}
                          >
                            {chatSession.name}
                          </span>
                          {chatSession.user_id &&
                            chatSession.user_id !== user?.id && (
                              <span
                                className="ml-2 flex size-5 items-center justify-center rounded-full bg-gray-700 text-xs text-gray-300"
                                title={`Erstellt von ${chatSession.user_id}`}
                              >
                                {getUserInitials(chatSession.user_id)}
                              </span>
                            )}
                        </div>
                      )}
                    </button>
                    <div className="ml-1 flex min-w-[60px] opacity-0 transition-opacity group-hover:opacity-100">
                      <button
                        onClick={e => startInlineEdit(chatSession, e)}
                        className="p-1 text-[#cccccc] hover:text-white"
                        title="Umbenennen"
                      >
                        <Edit size={14} />
                      </button>
                      <button
                        onClick={e => {
                          e.stopPropagation()
                          deleteChat(chatSession.id)
                        }}
                        className="p-1 text-[#cccccc] hover:text-red-500"
                        title="L√∂schen"
                      >
                        <Trash size={14} />
                      </button>
                    </div>
                  </div>
                ))}

                {unassignedChats.length === 0 && (
                  <div className="px-3 py-2 text-xs italic text-[#666666]">
                    Keine freien Chats
                  </div>
                )}
              </div>
              {/* Remove redundant "Neuer Chat" button since we already have one at the top of the sidebar */}
            </div>

            <div className="mt-6">
              <h2 className="mb-2 text-sm font-semibold uppercase text-[#999999]">
                Projekte
              </h2>
              <div className="space-y-1">
                {chatsByProject.map(project => (
                  <div key={project.id} className="mb-1">
                    <div
                      className="group flex items-center"
                      onDragOver={e => {
                        e.preventDefault()
                        setActiveDropTarget(project.id)
                      }}
                      onDragLeave={() => setActiveDropTarget(null)}
                      onDrop={e => {
                        e.preventDefault()
                        const chatId = e.dataTransfer.getData("chatId")
                        if (chatId) {
                          assignChatToProject(chatId, project.id)
                        }
                        setActiveDropTarget(null)
                      }}
                    >
                      <button
                        onClick={() => toggleProjectExpansion(project.id)}
                        className={cn(
                          "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                          selectedProject?.id === project.id
                            ? "bg-[#2d2d2d] text-white"
                            : "text-[#cccccc] hover:bg-[#222222]",
                          activeDropTarget === project.id &&
                            "border border-white/40 bg-[#2d2d2d]"
                        )}
                        style={{ maxWidth: "calc(100% - 40px)" }}
                      >
                        <span className="flex items-center">
                          {expandedProjects[project.id] ? (
                            <ChevronDown size={16} className="mr-2 min-w-4" />
                          ) : (
                            <ChevronRight size={16} className="mr-2 min-w-4" />
                          )}
                          <span className="block truncate" title={project.name}>
                            {project.name}
                          </span>
                          {project.chats.length > 0 && (
                            <span className="ml-2 text-xs text-gray-400">
                              ({project.chats.length})
                            </span>
                          )}
                        </span>
                      </button>
                      <div className="relative ml-1">
                        <button
                          onClick={e => {
                            e.stopPropagation()
                            setProjectMenuOpen(
                              project.id === projectMenuOpen ? null : project.id
                            )
                          }}
                          className="p-1 text-[#cccccc] opacity-0 transition-opacity hover:text-white group-hover:opacity-100"
                          data-project-menu="trigger"
                        >
                          <MoreVertical size={16} />
                        </button>
                        {projectMenuOpen === project.id && (
                          <div
                            className="absolute right-0 top-full z-10 mt-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg"
                            data-project-menu="content"
                          >
                            <button
                              onClick={e => {
                                e.stopPropagation()
                                // Projekt-Bearbeitung implementieren
                                setProjectToRename(project)
                                setNewProjectName(project.name)
                                setNewProjectDescription(
                                  project.description || ""
                                )
                                setShowProjectModal(true)
                              }}
                              className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                            >
                              <Edit size={16} className="mr-2" />
                              Bearbeiten
                            </button>
                            <button
                              onClick={e => {
                                e.stopPropagation()
                                deleteProject(project.id)
                              }}
                              className="flex w-full items-center px-4 py-2 text-sm text-red-500 hover:bg-[#2d2d2d]"
                            >
                              <Trash size={16} className="mr-2" />
                              L√∂schen
                            </button>
                          </div>
                        )}
                      </div>
                    </div>

                    {/* Projektzugewiesene Chats anzeigen, wenn Projekt aufgeklappt ist */}
                    {expandedProjects[project.id] &&
                      project.chats.length > 0 && (
                        <div className="mt-1 space-y-1 pl-6">
                          {project.chats.map(chatSession => (
                            <div
                              key={chatSession.id}
                              className="group flex items-center"
                            >
                              <button
                                onClick={() => handleSelectChat(chatSession.id)}
                                className={cn(
                                  "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                                  isActiveChat(chatSession.id)
                                    ? "bg-[#2d2d2d] text-white"
                                    : "text-[#cccccc] hover:bg-[#222222]"
                                )}
                                style={{ maxWidth: "calc(100% - 70px)" }}
                              >
                                {editingChatId === chatSession.id ? (
                                  <input
                                    type="text"
                                    value={newChatName}
                                    onChange={e =>
                                      setNewChatName(e.target.value)
                                    }
                                    onBlur={handleInlineEditBlur}
                                    onKeyDown={handleInlineEditKeyDown}
                                    className="w-full rounded border border-[#444444] bg-[#333333] px-2 py-0.5 text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                                    autoFocus
                                    onClick={e => e.stopPropagation()}
                                  />
                                ) : (
                                  <div className="flex items-center">
                                    <span
                                      className="block flex-1 truncate"
                                      title={chatSession.name}
                                    >
                                      {chatSession.name}
                                    </span>
                                    {chatSession.user_id &&
                                      chatSession.user_id !== user?.id && (
                                        <span
                                          className="ml-2 flex size-5 items-center justify-center rounded-full bg-gray-700 text-xs text-gray-300"
                                          title={`Erstellt von ${chatSession.user_id}`}
                                        >
                                          {getUserInitials(chatSession.user_id)}
                                        </span>
                                      )}
                                  </div>
                                )}
                              </button>
                              <div className="ml-1 flex min-w-[60px] opacity-0 transition-opacity group-hover:opacity-100">
                                <button
                                  onClick={e => startInlineEdit(chatSession, e)}
                                  className="p-1 text-[#cccccc] hover:text-white"
                                  title="Umbenennen"
                                >
                                  <Edit size={14} />
                                </button>
                                <button
                                  onClick={e => {
                                    e.stopPropagation()
                                    // Von Projekt entfernen
                                    assignChatToProject(chatSession.id, null)
                                  }}
                                  className="p-1 text-[#cccccc] hover:text-white"
                                  title="Von Projekt entfernen"
                                >
                                  <FileText size={14} />
                                </button>
                                <button
                                  onClick={e => {
                                    e.stopPropagation()
                                    deleteChat(chatSession.id)
                                  }}
                                  className="p-1 text-[#cccccc] hover:text-red-500"
                                  title="L√∂schen"
                                >
                                  <Trash size={14} />
                                </button>
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                  </div>
                ))}

                {chatsByProject.length === 0 && (
                  <div className="px-3 py-2 text-xs italic text-[#666666]">
                    Keine Projekte gefunden
                  </div>
                )}
              </div>
              <button
                onClick={() => setShowProjectModal(true)}
                className="mt-2 flex w-full items-center rounded-lg px-3 py-2 text-sm text-[#cccccc] hover:bg-[#222222]"
              >
                <Plus size={16} className="mr-2" />
                Neues Projekt
              </button>
            </div>
          </div>

          {/* User Section */}
          <div className="mt-auto border-t border-[#333333] p-3">
            <button
              onClick={() => setShowSettingsModal(true)}
              className="flex w-full items-center rounded-lg px-3 py-2 text-sm text-[#cccccc] hover:bg-[#222222]"
            >
              <User size={16} className="mr-2" />
              <span className="grow truncate text-left text-xs">
                {user?.email || "Kein Benutzer"}
              </span>
              <Settings size={16} />
            </button>
          </div>
        </aside>
      )}

      {/* Main Content Area */}
      <main className="flex flex-1 flex-col overflow-hidden">
        {/* Header */}
        <header className="flex h-14 items-center justify-between border-b border-neutral-700 bg-neutral-900 px-4">
          <div className="flex items-center space-x-4">
            {/* Back button is removed, H1 is the first item */}
            <h1 className="text-xl font-semibold text-white">
              {selectedTask
                ? selectedTask.title
                : chatSessions.find(chat => chat.id === currentChatId)?.name ||
                  "Neuer Chat"}
            </h1>
          </div>
          <div className="flex items-center space-x-4">
            {/* Knowledge Base Selector - Added here */}
            {user && (
              <div className="relative" id="kb-select-container">
                <KnowledgeBaseSelector
                  userId={user.id}
                  selectedKnowledgeBaseId={selectedKnowledgeBaseId}
                  onSelectKnowledgeBase={setSelectedKnowledgeBaseId}
                  isCompact={true}
                />
              </div>
            )}

            {/* Model Selection Dropdown */}
            <div
              className="relative"
              ref={modelDropdownRef}
              id="model-select-button"
            >
              <button
                onClick={() =>
                  !selectedTask && setShowModelDropdown(!showModelDropdown)
                }
                className={`flex items-center space-x-2 rounded-lg border border-[#333333] px-3 py-1.5 text-sm ${
                  selectedTask
                    ? "cursor-not-allowed text-[#666666]"
                    : "cursor-pointer text-[#cccccc] transition-all hover:border-[#444444] hover:text-white"
                }`}
              >
                <span>
                  {selectedTask
                    ? `${getModelLabel(selectedModel)} (in Task festgelegt)`
                    : getModelLabel(selectedModel)}
                </span>
                {!selectedTask && <ChevronDown size={16} />}
              </button>

              {showModelDropdown && !selectedTask && (
                <div className="absolute right-0 top-full z-10 mt-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg">
                  {/* Button for Basic - Verwende den Label-Namen "Basic" */}
                  <button
                    onClick={() => {
                      setSelectedModel("Basic")
                      setShowModelDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    Basic
                  </button>
                  {/* Button for Fast - Verwende den Label-Namen "Fast" */}
                  <button
                    onClick={() => {
                      setSelectedModel("Fast")
                      setShowModelDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    Fast
                  </button>
                  {/* Button for Reason - Verwende den Label-Namen "Reason" */}
                  <button
                    onClick={() => {
                      setSelectedModel("Reason")
                      setShowModelDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    Reason
                  </button>
                  {/* Button for Reason+ - Verwende den Label-Namen "Reason+" */}
                  <button
                    onClick={() => {
                      setSelectedModel("Reason+")
                      setShowModelDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    Reason+
                  </button>
                </div>
              )}
            </div>

            {/* Task Selection Dropdown */}
            <div
              className="relative"
              ref={taskDropdownRef}
              id="task-select-button"
            >
              <div className="flex items-center">
                <button
                  onClick={() => setShowTaskDropdown(!showTaskDropdown)}
                  disabled={isTaskSwitching}
                  className="flex items-center space-x-2 rounded-lg border border-[#333333] px-3 py-1.5 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white disabled:cursor-not-allowed disabled:opacity-50"
                >
                  <span>
                    {selectedTask ? selectedTask.title : "Task ausw√§hlen"}
                  </span>
                  <ChevronDown size={16} />
                </button>

                {isTaskSwitching && (
                  <div className="ml-2">
                    <div className="size-4 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                  </div>
                )}
              </div>

              {showTaskDropdown && (
                <div className="absolute right-0 top-full z-10 mt-1 w-64 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg">
                  <button
                    onClick={() => {
                      setIsTaskSwitching(true)
                      setSelectedTask(null)
                      setShowTaskDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    Kein Task
                  </button>
                  <div className="my-1 border-t border-[#333333]"></div>
                  {tasks.map(task => (
                    <button
                      key={task.id}
                      onClick={() => {
                        setIsTaskSwitching(true)
                        setSelectedTask(task)
                        setShowTaskDropdown(false)
                      }}
                      className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                    >
                      {task.title}
                    </button>
                  ))}
                  <div className="my-1 border-t border-[#333333]"></div>
                  <button
                    onClick={() => {
                      setShowTaskModal(true)
                      setShowTaskDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    <Plus size={16} className="mr-2" />
                    Neuer Task
                  </button>
                </div>
              )}
            </div>
          </div>
        </header>

        {/* Message Area */}
        <div
          id="message-area-wrapper"
          ref={chatBodyRef}
          className="flex w-full flex-1 justify-center overflow-y-auto"
        >
          <div
            className="w-full"
            style={{ maxWidth: "90%", width: "100%", margin: "0 auto" }}
          >
            {/* Start Screen with Info Buttons */}
            {messages.length === 0 && !runTour && !showFakeMessagesForTour && !inputValue.trim() && !isTyping && !messageUpdatePending && !hasStartedTyping && (
              <div className="flex h-full flex-col items-center justify-center text-center">
                <h2 className="mb-4 text-2xl font-bold text-white">
                  Entdecken Sie die Funktionen dieses Chats
                </h2>
                <div className="grid max-w-2xl grid-cols-2 gap-4">
                  <button
                    key="tour-tasks"
                    className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]"
                    onClick={() => startTourAt(0)}
                  >
                    {infoItems[0].title}
                  </button>
                  <button
                    key="tour-model"
                    className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]"
                    onClick={() => startTourAt(1)}
                  >
                    {infoItems[1].title}
                  </button>
                  <button
                    key="tour-messages"
                    className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]"
                    onClick={() => startTourAt(2)}
                  >
                    {infoItems[2].title}
                  </button>
                  <button
                    key="tour-chats"
                    className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]"
                    onClick={() => startTourAt(3)}
                  >
                    {infoItems[3].title}
                  </button>
                </div>
              </div>
            )}

            {/* Real Messages */}
            {!showFakeMessagesForTour &&
              messages
                .filter(message => message.role !== "system")
                .map(message => (
                  <div
                    key={message.id}
                    className={`group mb-1 flex flex-col ${
                      message.role === "user" ? "items-end" : "items-start"
                    }`}
                  >
                    {/* Sender and timestamp */}
                    <div
                      className={`mb-0 text-xs ${message.role === "user" ? "text-right" : "text-left"} text-gray-400`}
                    >
                      {message.role === "user"
                        ? message.sentfrom
                          ? message.sentfrom // Use sentfrom if available
                          : message.user_id === user?.id
                            ? userFullName
                            : message.user_id &&
                                userNamesMap &&
                                userNamesMap[message.user_id]
                              ? userNamesMap[message.user_id]
                              : message.user_id
                                ? `Benutzer ${message.user_id.substring(0, 4)}`
                                : "Anderer Benutzer"
                        : message.sentfrom
                          ? message.sentfrom // Use sentfrom for assistant too
                          : "KI-Assistent"}{" "}
                      {message.timestamp.toLocaleTimeString("de-DE", {
                        hour: "2-digit",
                        minute: "2-digit",
                        second: "2-digit"
                      })}
                    </div>

                    {/* Message content or edit box */}
                    {editingMessageId === message.id ? (
                      <div
                        ref={editBoxRef}
                        className="flex w-full max-w-[60%] flex-col items-end"
                      >
                        <textarea
                          value={editingContent}
                          onChange={e => setEditingContent(e.target.value)}
                          className="mb-2 w-full resize-none rounded-lg border border-[#444] bg-[#3a3a3a] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#555]"
                          rows={3}
                          autoFocus
                        />
                        <div className="self-end">
                          <button
                            onClick={handleSaveEdit}
                            disabled={!editingContent.trim()}
                            className={`rounded-lg px-4 py-2 text-sm ${
                              !editingContent.trim()
                                ? "cursor-not-allowed text-[#666666]"
                                : "border border-[#444] bg-[#2d2d2d] text-[#cccccc] hover:border-[#555] hover:text-white"
                            }`}
                          >
                            Senden
                          </button>
                        </div>
                      </div>
                    ) : (
                      <div
                        className={`max-w-[60%] rounded-lg overflow-hidden ${message.role === "user" ? "user-message bg-blue-600 text-white" : "assistant-message bg-zinc-800 text-white"}`}
                      >
                        {message.role === "assistant" && message.isTypewriting ? (
                          <div className="p-1">
                          <RevealEffect
                            content={message.content}
                            onComplete={() => handleTypewriterComplete(message.id)}
                          />
                          </div>
                        ) : (
                          <div className="p-1">
                            {(() => {
                              let displayContent = message.content;
                              try {
                                // Check if content is JSON with a content field
                                if (message.content.trim().startsWith('{') && message.content.trim().endsWith('}')) {
                                  const jsonContent = JSON.parse(message.content);
                                  if (jsonContent && typeof jsonContent.content === 'string') {
                                    displayContent = jsonContent.content;
                                  }
                                }
                              } catch (e) {
                                // If parsing fails, use the original content
                              }
                              return <MessageMarkdown content={displayContent} />;
                            })()}
                          </div>
                        )}
                      </div>
                    )}

                    {/* Action buttons */}
                    {editingMessageId !== message.id && (
                      <div className="mt-1 flex items-center space-x-2 opacity-0 transition-opacity duration-200 group-hover:opacity-100">
                        {message.role === "user" && (
                          <>
                            <button
                              onClick={() => copyToClipboard(message.content)}
                              className="p-1 text-[#aaa] hover:text-white"
                              title="Nachricht kopieren"
                            >
                              <Copy size={14} />
                            </button>
                            <button
                              onClick={() => startEditMessage(message)}
                              className="p-1 text-[#aaa] hover:text-white"
                              title="Nachricht bearbeiten"
                            >
                              <Edit size={14} />
                            </button>
                          </>
                        )}
                        {message.role === "assistant" && (
                          <>
                            <button
                              onClick={() => copyToClipboard(message.content)}
                              className="p-1 text-[#aaa] hover:text-white"
                              title="Antwort kopieren"
                            >
                              <Copy size={14} />
                            </button>
                            <button
                              onClick={() => regenerateResponse(message.id)}
                              className="p-1 text-[#aaa] hover:text-white"
                              title="Antwort neu generieren"
                            >
                              <RotateCcw size={14} />
                            </button>
                          </>
                        )}
                      </div>
                    )}
                  </div>
                ))}

            {/* Tour Messages */}
            {showFakeMessagesForTour &&
              fakeTourMessages.map(message => (
                <div
                  key={message.id}
                  className={`group relative mb-8 flex flex-col ${
                    message.role === "user" ? "items-end" : "items-start"
                  }`}
                >
                  <div
                    className={`mb-0 text-xs ${message.role === "user" ? "text-right" : "text-left"} text-gray-400`}
                  >
                    {message.role === "user" ? "Beispiel User" : "Beispiel KI"}{" "}
                    {message.timestamp.toLocaleTimeString("de-DE", {
                      hour: "2-digit",
                      minute: "2-digit"
                    })}
                  </div>
                  <div
                    className={`max-w-[60%] ${message.role === "user" ? "user-message" : "assistant-message"}`}
                  >
                    <div className="p-1">
                      {(() => {
                        let displayContent = message.content;
                        try {
                          // Check if content is JSON with a content field
                          if (message.content.trim().startsWith('{') && message.content.trim().endsWith('}')) {
                            const jsonContent = JSON.parse(message.content);
                            if (jsonContent && typeof jsonContent.content === 'string') {
                              displayContent = jsonContent.content;
                            }
                          }
                        } catch (e) {
                          // If parsing fails, use the original content
                        }
                        return <MessageMarkdown content={displayContent} />;
                      })()}
                    </div>
                  </div>

                  {/* Action buttons - made more prominent for the tour */}
                  <div
                    className={`mt-2 flex animate-pulse items-center space-x-3 rounded-md border border-[#444444] bg-[#333333] px-3 py-2 shadow-lg ${
                      message.role === "user" ? "self-end" : "self-start"
                    }`}
                  >
                    {message.role === "user" && (
                      <>
                        <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                          <Copy size={14} className="mr-1.5" />
                          <span className="text-sm font-medium">Kopieren</span>
                        </div>
                        <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                          <Edit size={14} className="mr-1.5" />
                          <span className="text-sm font-medium">
                            Bearbeiten
                          </span>
                        </div>
                      </>
                    )}
                    {message.role === "assistant" && (
                      <>
                        <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                          <Copy size={14} className="mr-1.5" />
                          <span className="text-sm font-medium">Kopieren</span>
                        </div>
                        <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                          <RotateCcw size={14} className="mr-1.5" />
                          <span className="text-sm font-medium">
                            Neu generieren
                          </span>
                        </div>
                      </>
                    )}
                  </div>

                  {/* Show message actions explanation for AI message during tour */}
                  {showMessageActionsDialog &&
                    message.id === "fake-ai-message" && (
                      <div className="mt-3 max-w-[80%] self-start rounded-md border border-[#444444] bg-[#222222] p-4 shadow-lg">
                        <div className="mb-2 flex items-center justify-between">
                          <h3 className="font-medium text-white">
                            Nachrichtenaktionen
                          </h3>
                          <button
                            onClick={() => setShowMessageActionsDialog(false)}
                            className="text-gray-400 hover:text-white"
                          >
                            <X size={16} />
                          </button>
                        </div>
                        <p className="mb-2 text-sm text-gray-300">
                          Bewegen Sie den Mauszeiger √ºber die Nachrichten, um
                          folgende Aktionen zu nutzen:
                        </p>
                        <ul className="mb-2 ml-2 list-inside list-disc space-y-1 text-xs text-gray-300">
                          <li>
                            <strong>Kopieren:</strong> Kopiert den Inhalt der
                            Nachricht in die Zwischenablage
                          </li>
                          <li>
                            <strong>Bearbeiten:</strong> √Ñndert Ihre bereits
                            gesendeten Nachrichten
                          </li>
                          <li>
                            <strong>Neu generieren:</strong> Erstellt eine neue
                            KI-Antwort zur letzten Benutzernachricht
                          </li>
                        </ul>
                        <p className="mt-3 text-xs italic text-gray-400">
                          Diese Optionen erscheinen unter jeder Nachricht, wenn
                          Sie mit der Maus dar√ºber fahren.
                        </p>
                        <div className="mt-3 flex justify-end">
                          <button
                            onClick={() => {
                              setShowMessageActionsDialog(false)
                              setRunTour(true)
                              setStepIndex(3) // Skip to the next step (chat sidebar)
                            }}
                            className="rounded-md bg-[#555555] px-3 py-1 text-sm text-white hover:bg-[#666666]"
                          >
                            Weiter
                          </button>
                        </div>
                      </div>
                    )}
                </div>
              ))}

            {/* Typing Indicator - Use the new component */}
            {!showFakeMessagesForTour && isTyping && (
              <div className="mb-4 flex justify-start pl-4">
                {" "}
                {/* Added bottom margin mb-4 */}
                {/* Replace the old indicator with the new one */}
                <LoadingIndicator />
              </div>
            )}
          </div>
        </div>

        {/* Chat Input Footer */}
        <div className="mt-auto flex w-full flex-col items-center bg-[#1e1e1e] px-4 pb-4 pt-2">
          <div
            className="relative flex items-center space-x-2 rounded-lg border border-[#333333] bg-[#2d2d2d] p-2"
            style={{ maxWidth: "805px", width: "100%" }}
          >
            <div className="flex shrink-0 items-center space-x-1">
              <button
                onClick={handleDeepResearch}
                disabled={!inputValue.trim() || isTyping || isSearching}
                className="flex items-center space-x-1 rounded-lg px-2 py-1 text-xs text-[#cccccc] transition-colors hover:bg-[#444444] disabled:cursor-not-allowed disabled:opacity-50"
                title="Web-Suche starten"
              >
                {isSearching ? (
                  <Loader size={16} className="animate-spin" />
                ) : (
                  <Search size={16} />
                )}
                <span>Web-Suche</span>
              </button>
              <div className="relative">
                <button
                  ref={moreOptionsButtonRef}
                  onClick={() => setShowInputMenu(!showInputMenu)}
                  className="rounded-full p-1.5 text-[#cccccc] transition-colors hover:bg-[#444444]"
                  title="Weitere Optionen"
                >
                  <MoreHorizontal size={20} />
                </button>

                {showInputMenu && (
                  <div
                    ref={inputMenuRef}
                    className="absolute bottom-full left-0 z-20 mb-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg"
                  >
                    <button
                      onClick={() => {
                        handleGenerateSummary()
                        setShowInputMenu(false)
                      }}
                      className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                      disabled={messages.length < 2 || isTyping}
                    >
                      <BookOpen size={14} className="mr-2" />
                      Zusammenfassen
                    </button>
                    <button
                      onClick={() => {
                        setShowExportModal(true)
                        setShowInputMenu(false)
                      }}
                      className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                      disabled={messages.length === 0 || isTyping}
                    >
                      <FileDown size={14} className="mr-2" />
                      Exportieren
                    </button>
                    <div className="my-1 border-t border-[#333333]"></div>
                    <button
                      onClick={() => {
                        if (currentChatId && user) deleteChat(currentChatId)
                        setShowInputMenu(false)
                      }}
                      className="flex w-full items-center px-4 py-2 text-sm text-red-500 hover:bg-[#2d2d2d] disabled:cursor-not-allowed disabled:opacity-50"
                      disabled={!currentChatId || messages.length === 0}
                    >
                      <Trash size={14} className="mr-2" />
                      Chat l√∂schen
                    </button>
                  </div>
                )}
              </div>
            </div>

            <div className="mx-4 flex grow items-center">
              {" "}
              {/* Ensure parent uses flex and items-center */}
              <textarea
                id="chat-input-textarea"
                ref={inputRef}
                value={inputValue}
                onChange={e => {
                  setInputValue(e.target.value)
                  if (!hasStartedTyping && e.target.value.trim() !== "") {
                    setHasStartedTyping(true)
                  }
                }}
                onKeyDown={e => {
                  if (e.key === "Enter" && !e.shiftKey) {
                    e.preventDefault()
                    handleSendMessage(inputValue, false)
                  }
                }}
                placeholder={
                  isTaskSwitching
                    ? "Task wird gewechselt..."
                    : "Stelle irgendeine Frage ..."
                }
                disabled={isTaskSwitching}
                // Fine-tune vertical padding: pt-2 pb-1
                className={`min-h-10 w-full resize-none bg-transparent px-2 pb-1 pt-2 text-sm text-white placeholder-[#666666] focus:outline-none${isTaskSwitching ? "cursor-not-allowed opacity-50" : ""}`}
                rows={1}
                style={{
                  // minHeight: '40px', // Still handled by Tailwind class
                  maxHeight: "400px"
                }}
              />
            </div>

            <div className="shrink-0">
              <button
                onClick={() => handleSendMessage(inputValue, false)}
                disabled={!inputValue.trim() || isTyping || isTaskSwitching}
                className="flex items-center space-x-1 rounded-lg bg-white px-3 py-1.5 text-sm text-black transition-colors hover:bg-gray-200 disabled:cursor-not-allowed disabled:opacity-50"
                title="Nachricht senden"
              >
                {isTaskSwitching ? (
                  <>
                    <div className="size-4 animate-spin rounded-full border-2 border-gray-800 border-t-transparent"></div>
                    <span>Wechseln...</span>
                  </>
                ) : (
                  <>
                    <Send size={16} />
                    <span>Senden</span>
                  </>
                )}
              </button>
            </div>
          </div>

          <div
            className="mt-2 text-center text-xs text-[#666666]"
            style={{ maxWidth: "805px", width: "100%" }}
          >
            ChatGPT kann Fehler machen. OpenAI verwendet keine Daten aus diesem
            Chat zum Trainieren seiner Modelle.
          </div>
        </div>
      </main>

      {/* Task Creation Modal */}
      {showTaskModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className="w-full max-w-md rounded-lg border border-[#333333] bg-[#1e1e1e] p-6">
            <h2 className="mb-4 text-xl font-semibold text-white">
              Neuen Task erstellen
            </h2>
            <div className="mb-4">
              <label
                htmlFor="taskName"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                Task-Name
              </label>
              <input
                id="taskName"
                type="text"
                value={newTaskName}
                onChange={e => setNewTaskName(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Task-Name eingeben"
              />
            </div>

            <div className="mb-4">
              <label
                htmlFor="taskDescription"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                Beschreibung
              </label>
              <textarea
                id="taskDescription"
                value={newTaskDescription}
                onChange={e => setNewTaskDescription(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Task beschreiben..."
                rows={3}
              />
            </div>

            <div className="mb-4">
              <label
                htmlFor="taskSystemPrompt"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                System-Prompt
              </label>
              <div className="relative">
                <textarea
                  id="taskSystemPrompt"
                  value={newTaskSystemPrompt}
                  onChange={e => setNewTaskSystemPrompt(e.target.value)}
                  className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 pr-10 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                  placeholder="Strukturiere deinen Prompt! Z.B.: ZIEL: [Dein Ziel...] FORMAT: [Gew√ºnschtes Format...] WARNUNGEN: [Was vermeiden?...] KONTEXT: [Hintergrundinfos...]"
                  rows={4}
                />
                <button
                  type="button"
                  onClick={handleImprovePrompt}
                  disabled={isImprovingPrompt || !newTaskSystemPrompt.trim()}
                  className="absolute right-3 top-3 rounded-md bg-[#333333] p-1.5 text-white/80 transition-colors hover:bg-[#444444] hover:text-white disabled:cursor-not-allowed disabled:opacity-50"
                  title="AI-Unterst√ºtzung f√ºr Prompt"
                >
                  {isImprovingPrompt ? (
                    <Loader size={18} className="animate-spin" />
                  ) : (
                    <Sparkles size={18} />
                  )}
                </button>
              </div>
            </div>

            <div className="mb-4">
              <label
                htmlFor="taskModel"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                KI-Modell
              </label>
              <select
                id="taskModel"
                value={newTaskModel}
                onChange={e => setNewTaskModel(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white focus:outline-none focus:ring-1 focus:ring-[#444444]"
              >
                <option value="gpt-4o">Basic</option>
                <option value="gpt-4o-mini">Fast</option>
                <option value="o3-mini">Reason</option>
                <option value="gpt-4.5-preview">Reason+</option>
              </select>
            </div>

            <div className="flex justify-end space-x-3">
              <button
                onClick={() => {
                  setShowTaskModal(false)
                  setNewTaskName("")
                  setNewTaskDescription("")
                  setNewTaskSystemPrompt("")
                  setNewTaskModel("gpt-4o")
                }}
                className="rounded-lg border border-[#333333] px-4 py-2 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white"
              >
                Abbrechen
              </button>
              <button
                onClick={handleCreateTask}
                disabled={!newTaskName.trim()}
                className={`rounded-lg px-4 py-2 text-sm ${
                  newTaskName.trim()
                    ? "border border-[#444444] bg-[#333333] text-white hover:bg-[#444444]"
                    : "cursor-not-allowed border border-[#444444]/50 bg-[#333333]/50 text-white/70"
                }`}
              >
                Erstellen
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Export Modal */}
      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        messages={messages}
        onExport={handleExportPdf}
      />

      {/* Summary Modal */}
      <SummaryModal
        isOpen={showSummaryModal}
        onClose={() => setShowSummaryModal(false)}
        summary={chatSummary}
        loading={false}
      />

      {/* Projekt Modal (Erstellen/Bearbeiten) */}
      {showProjectModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className="w-full max-w-md rounded-lg border border-[#333333] bg-[#1e1e1e] p-6">
            <h2 className="mb-4 text-xl font-semibold text-white">
              {projectToRename
                ? "Projekt bearbeiten"
                : "Neues Projekt erstellen"}
            </h2>

            <div className="mb-4">
              <label
                htmlFor="projectName"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                Projektname
              </label>
              <input
                id="projectName"
                type="text"
                value={newProjectName}
                onChange={e => setNewProjectName(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Projektname eingeben"
              />
            </div>

            <div className="mb-4">
              <label
                htmlFor="projectDescription"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                Beschreibung (optional)
              </label>
              <textarea
                id="projectDescription"
                value={newProjectDescription}
                onChange={e => setNewProjectDescription(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Projekt beschreiben..."
                rows={3}
              />
            </div>

            <div className="flex justify-end space-x-3">
              <button
                onClick={() => {
                  setShowProjectModal(false)
                  setProjectToRename(null)
                  setNewProjectName("")
                  setNewProjectDescription("")
                }}
                className="rounded-lg border border-[#333333] px-4 py-2 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white"
              >
                Abbrechen
              </button>
              <button
                onClick={() => {
                  if (projectToRename) {
                    // Projekt aktualisieren
                    updateProject()
                  } else {
                    // Neues Projekt erstellen
                    handleCreateProject()
                  }
                }}
                disabled={!newProjectName.trim()}
                className={`rounded-lg px-4 py-2 text-sm ${
                  newProjectName.trim()
                    ? "border border-[#444444] bg-[#333333] text-white hover:bg-[#444444]"
                    : "cursor-not-allowed border border-[#444444]/50 bg-[#333333]/50 text-white/70"
                }`}
              >
                {projectToRename ? "Aktualisieren" : "Erstellen"}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Settings Modal */}
      <SettingsModal
        isOpen={showSettingsModal}
        onClose={() => setShowSettingsModal(false)}
        userId={user?.id || ""}
      />

      {/* Offline Indicator */}
      <OfflineIndicator />
    </div>
  )
}
