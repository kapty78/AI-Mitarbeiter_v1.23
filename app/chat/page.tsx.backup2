"use client"

import React from "react"
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs"
import { useEffect, useRef, useState, useMemo, useCallback } from "react"
import { useSearchParams } from "next/navigation"
import Link from "next/link"
import {
  ChevronLeft,
  Menu,
  Plus,
  Send,
  ChevronDown,
  Copy,
  RotateCcw,
  Edit,
  Paperclip,
  Image,
  Search,
  MoreVertical,
  Trash,
  X,
  FlaskConical,
  MoreHorizontal,
  Mic,
  Loader,
  FileText,
  FileDown,
  BookOpen,
  User,
  Settings,
  Home,
  ChevronRight,
  MessageCircle,
  Sparkles,
  Check
} from "lucide-react" // Added Icons
import ReactMarkdown from "react-markdown"
import remarkGfm from "remark-gfm"
import { v4 as uuidv4 } from "uuid"
import { TypewriterEffect } from "@/components/typewriter-effect"
import { RevealEffect } from "@/components/reveal-effect"; // Import RevealEffect
import { useRouter } from "next/navigation"
import { cn } from "@/lib/utils"
import Joyride, { Step, CallBackProps, STATUS } from "react-joyride" // Import Joyride
import dynamic from "next/dynamic" // Import dynamic
import {
  performSerpApiSearch,
  formatSearchResults,
  formatSearchResultsForAI
} from "../utils/serpApi"
import { downloadChatAsPdf } from "../utils/pdfExport"
import { generateChatSummary } from "../utils/chatSummary"
import ExportModal from "../components/ExportModal"
import SummaryModal from "../components/SummaryModal"
// Drag-and-Drop-Bibliotheken
import {
  DndContext,
  useDraggable,
  useDroppable,
  useSensors,
  useSensor,
  PointerSensor
} from "@dnd-kit/core"
import LoadingIndicator from "@/components/LoadingIndicator" // Corrected import path
import SettingsModal from "@/app/components/SettingsModal" // Import the SettingsModal component
import { KnowledgeBaseSelector } from "@/components/knowledge/KnowledgeBaseSelector"
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter"
import { oneDark } from "react-syntax-highlighter/dist/cjs/styles/prism"
import { MessageMarkdown } from "@/components/message-markdown"
import { MessageCodeBlock } from "@/components/message-code-block"
import { buildPrompt, DEFAULT_SYSTEM_PROMPT } from "@/lib/prompt-builder"

// Dynamically import Joyride with SSR disabled
const DynamicJoyride = dynamic(() => import("react-joyride"), { ssr: false })

// Define a simpler interface for CodeProps
interface CodeProps {
  node?: any
  inline?: boolean
  className?: string
  children?: React.ReactNode
}

interface Message {
  id: string
  role: "user" | "assistant" | "system"
  content: string
  timestamp: Date
  isTypewriting?: boolean
  user_id?: string // Add user_id to track message sender
  sentfrom?: string // Add sentfrom to store user name directly
}

interface ChatSession {
  id: string
  name: string
  created_at: string
  description?: string
  project_id?: string | null
  last_message_timestamp?: string
  user_id?: string
}

interface Task {
  id: string
  title: string
  description: string
  system_prompt: string
  ai_model: string
  created_at?: string
  updated_at?: string
  user_id?: string
  workspace_id?: string | null
  project_id?: string | null
}

interface Project {
  id: string
  name: string
  description?: string
  user_id: string
  workspace_id?: string | null
  chats?: ChatSession[] // Chats, die zu diesem Projekt gehören
}

// Define structure for info items (used for buttons, tour content can be different)
interface InfoItem {
  title: string
  // We'll define tour steps separately now
}

// Keep infoItems simple for the buttons
const infoItems: InfoItem[] = [
  { title: "Tasks nutzen" },
  { title: "KI-Modell wechseln" },
  { title: "Nachrichten bearbeiten & neu generieren" },
  { title: "Chats verwalten" }
]

const initialMessages: Message[] = []

// Define Tour Steps (Adjust step 3)
const tourSteps: Step[] = [
  {
    target: "#task-select-button",
    content: (
      <>
        <p className="mb-2">
          Mit Tasks können Sie der KI spezifische Anweisungen oder eine
          bestimmte Rolle für den gesamten Chat zuweisen.
        </p>
        <p>
          Klicken Sie hier, um einen vorhandenen Task zu wählen oder einen neuen
          zu erstellen. Tasks überschreiben die manuelle Modellauswahl.
        </p>
      </>
    ),
    placement: "bottom-end",
    title: "Tasks nutzen"
  },
  {
    target: "#model-select-button",
    content: (
      <>
        <p className="mb-2 text-sm">
          Wählen Sie hier das KI-Modell, wenn kein Task aktiv ist:
        </p>
        <ul className="mb-2 ml-4 list-inside list-disc space-y-1 text-sm">
          <li>
            <strong>Basic (GPT-4o):</strong> Ausgewogen.
          </li>
          <li>
            <strong>Fast (GPT-4o mini):</strong> Schnell & Günstig.
          </li>
          <li>
            <strong>Reason (GPT-4 Vision):</strong> Leistungsstark.
          </li>
        </ul>
      </>
    ),
    placement: "bottom-end",
    title: "KI-Modell wechseln"
  },
  {
    target: "#chat-sidebar",
    content:
      "Hier verwalten Sie Ihre Chats: Neuen Chat erstellen (+), Chat auswählen, umbenennen oder löschen (über die drei Punkte).",
    placement: "right",
    title: "Chats verwalten"
  },
  {
    target: "#new-chat-button",
    content: "Klicken Sie hier, um einen neuen, leeren Chat zu beginnen.",
    placement: "left",
    title: "Neuer Chat",
    disableScrolling: true,
    disableOverlayClose: true,
    spotlightPadding: 5
  },
  {
    target: "#chat-input-textarea",
    content:
      "Geben Sie hier Ihre Nachricht ein und drücken Sie Enter oder klicken Sie auf den Senden-Button.",
    placement: "top",
    title: "Nachricht senden"
  }
]

// Helper function to fix the columns handling consistently
const getColumnNames = (columns: any[] | null): string[] => {
  return columns
    ? columns.map((col: { column_name: string }) => col.column_name)
    : []
}

// Detect and format HTML code
const formatCodeInMessage = (content: string): string => {
  // If content already has markdown code blocks, don't modify
  if (content.includes("```")) return content;
  
  // Check if the content appears to be HTML
  if (
    content.trim().startsWith("<") && 
    (content.includes("<!DOCTYPE") || 
     content.includes("<html") ||
     (content.includes("<body") && content.includes("</body>")) ||
     (content.includes("<head") && content.includes("</head>")))
  ) {
    return "```html\n" + content + "\n```";
  }
  
  return content;
};

// This is a standalone component for code blocks

// ---> HILFSFUNKTIONEN für V2 Prompt <--- 
function trimText(txt: string | null | undefined, maxWords = 60): string {
  if (!txt) return "";
  const words = txt.trim().split(/\s+/);
  if (words.length <= maxWords) return txt;
  return words.slice(0, maxWords).join(" ") + " …";
}

// V2 System Prompt Definition - entfernt, da jetzt zentral in prompt-builder.ts definiert
// const systemPrompt = `...`.trim();
// ---> ENDE HILFSFUNKTIONEN für V2 Prompt <--- 

// Add debugging flag at the top of the file, after imports
const DEBUG_MODE = false; // Set to true to enable verbose logging

// Replace console.log with debug-aware logging function
const debugLog = (...args: any[]) => {
  if (DEBUG_MODE) {
    console.log(...args);
  }
};

// Add this custom hook for subscription management
// Place it outside the component, before export default function Chat()
const useSubscriptions = (supabase: any) => {
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const [subscriptionStatus, setSubscriptionStatus] = useState({
    chatsSubscribed: false,
    messagesSubscribed: false
  });

  // Setup chat subscription
  const setupChatSubscription = useCallback((userId: string) => {
    if (!supabase || !userId || chatsChannelRef.current) {
      return;
    }

    const channelId = `chats_updates_global`;
    debugLog(`Setting up realtime subscription for chats table: ${channelId}`);

    const chatsChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chats"
        },
        (payload: any) => {
          debugLog("Realtime chat update received:", payload);
          // Callback to update UI based on the payload would be passed
          // from the component when calling this function
        }
      )
      .subscribe((status: string) => {
        debugLog(`Subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, chatsSubscribed: status === "SUBSCRIBED"}));
      });
    
    chatsChannelRef.current = chatsChannel;
    return chatsChannel;
  }, [supabase]);

  // Setup message subscription
  const setupMessageSubscription = useCallback((chatId: string, userId: string, onMessageReceived: (msg: any) => void) => {
    if (!supabase || !chatId || !userId) {
      return;
    }

    // Cleanup previous subscription if exists
    if (messagesChannelRef.current) {
      debugLog("Cleaning up previous message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    const channelId = `chat_messages_${chatId}`;
    debugLog(`Setting up message subscription for chat: ${chatId}`);

    const messagesChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "chat_messages",
          filter: `chat_id=eq.${chatId}`
        },
        (payload: any) => {
          debugLog(`Realtime message update received for chat ${chatId}:`, payload.eventType);
          
          if (payload.eventType === "INSERT") {
            const newMsg = payload.new;
            // Check if message is from another user
            const msgSentByOtherUser = newMsg.user_id && newMsg.user_id !== userId;
            
            // Only notify if message is from another user or pass to the callback in any case
            onMessageReceived(payload);
          }
        }
      )
      .subscribe((status: string) => {
        debugLog(`Message subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, messagesSubscribed: status === "SUBSCRIBED"}));
      });

    messagesChannelRef.current = messagesChannel;
    return messagesChannel;
  }, [supabase]);

  // Cleanup all subscriptions
  const cleanupSubscriptions = useCallback(() => {
    if (chatsChannelRef.current && supabase) {
      debugLog("Cleaning up chats table subscription");
      supabase.removeChannel(chatsChannelRef.current);
      chatsChannelRef.current = null;
    }

    if (messagesChannelRef.current && supabase) {
      debugLog("Cleaning up message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    setSubscriptionStatus({
      chatsSubscribed: false,
      messagesSubscribed: false
    });
  }, [supabase]);

  return {
    setupChatSubscription,
    setupMessageSubscription,
    cleanupSubscriptions,
    subscriptionStatus
  };
};

export default function Chat() {
  const searchParams = useSearchParams()
  const rawWorkspaceId = searchParams.get("workspace")
  const taskId = searchParams.get("task")

  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [user, setUser] = useState<any>(null)
  const [workspace, setWorkspace] = useState<any>(null)
  const [userFullName, setUserFullName] = useState<string>("Du")
  const [messages, setMessages] = useState<Message[]>(initialMessages)
  const [inputValue, setInputValue] = useState("")
  const [isTyping, setIsTyping] = useState(false)
  const [showIceBreakers, setShowIceBreakers] = useState(false)
  const [showModelDropdown, setShowModelDropdown] = useState(false)
  const [selectedModel, setSelectedModel] = useState("gpt-4o")
  const [chatSessions, setChatSessions] = useState<ChatSession[]>([])
  const [currentChatId, setCurrentChatId] = useState<string | null>(null)
  const [tasks, setTasks] = useState<Task[]>([])
  const [selectedTask, setSelectedTask] = useState<Task | null>(null)
  const [showTaskDropdown, setShowTaskDropdown] = useState(false)
  const [showTaskModal, setShowTaskModal] = useState(false)
  const [newTask, setNewTask] = useState<Task>({
    id: "",
    title: "",
    description: "",
    system_prompt: "",
    ai_model: ""
  })
  const [newTaskName, setNewTaskName] = useState("")
  const [newTaskDescription, setNewTaskDescription] = useState("")
  const [newTaskSystemPrompt, setNewTaskSystemPrompt] = useState("")
  const [newTaskModel, setNewTaskModel] = useState("gpt-4o")
  const [showSidebar, setShowSidebar] = useState(true)
  const [typingMessageId, setTypingMessageId] = useState<string | null>(null)
  const [personalWorkspaceId, setPersonalWorkspaceId] = useState<string | null>(
    null
  )
  const [previousSelectedTask, setPreviousSelectedTask] = useState<Task | null>(
    null
  )
  const [previousSelectedModel, setPreviousSelectedModel] = useState<
    string | null
  >(null)
  const [messageUpdatePending, setMessageUpdatePending] = useState(false)
  const [isTaskSwitching, setIsTaskSwitching] = useState(false)
  const [lastMessageUpdate, setLastMessageUpdate] = useState(Date.now())

  // State für Projekte
  const [projects, setProjects] = useState<Project[]>([])
  const [selectedProject, setSelectedProject] = useState<Project | null>(null)
  const [showProjectDropdown, setShowProjectDropdown] = useState(false)
  const [showProjectModal, setShowProjectModal] = useState(false)
  const [newProjectName, setNewProjectName] = useState("")
  const [newProjectDescription, setNewProjectDescription] = useState("")
  const [projectMenuOpen, setProjectMenuOpen] = useState<string | null>(null)
  const [projectToRename, setProjectToRename] = useState<Project | null>(null)

  // State für Drag & Drop
  const [draggedChatId, setDraggedChatId] = useState<string | null>(null)
  const [activeDropTarget, setActiveDropTarget] = useState<string | null>(null)

  // State für aufgeklappte Projekte
  const [expandedProjects, setExpandedProjects] = useState<
    Record<string, boolean>
  >({})

  // State for editing messages
  const [editingMessageId, setEditingMessageId] = useState<string | null>(null)
  const [editingContent, setEditingContent] = useState("")
  
  // State to store original messages during editing
  const [originalMessages, setOriginalMessages] = useState<Message[]>([])

  // Add searchDebounceTimeout ref
  const searchDebounceTimeout = useRef<any>(null)

  const chatBodyRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLTextAreaElement>(null)
  const modelDropdownRef = useRef<HTMLDivElement>(null)
  const taskDropdownRef = useRef<HTMLDivElement>(null)
  const projectDropdownRef = useRef<HTMLDivElement>(null)

  const supabase = createClientComponentClient()

  // Add state for chat menu and rename functionality
  const [chatMenuOpen, setChatMenuOpen] = useState<string | null>(null)
  const [renameModalOpen, setRenameModalOpen] = useState(false)
  const [chatToRename, setChatToRename] = useState<ChatSession | null>(null)
  const [newChatName, setNewChatName] = useState("")
  // Neuer State für inline edit
  const [editingChatId, setEditingChatId] = useState<string | null>(null)

  const router = useRouter()

  // Add state and refs for the input action menu
  const [showInputMenu, setShowInputMenu] = useState(false)
  const inputMenuRef = useRef<HTMLDivElement>(null)
  const moreOptionsButtonRef = useRef<HTMLButtonElement>(null)

  // Füge einen Ref für die Edit-Box hinzu
  const editBoxRef = useRef<HTMLDivElement>(null)

  // Add state for the new info modal
  // const [showInfoModal, setShowInfoModal] = useState(false)
  // const [modalContent, setModalContent] = useState<InfoItem | null>(null)

  // Add state for React Joyride
  const [runTour, setRunTour] = useState(false)
  const [stepIndex, setStepIndex] = useState(0)

  // State to control showing fake messages during the tour
  const [showFakeMessagesForTour, setShowFakeMessagesForTour] = useState(false)

  // Define fake messages for the tour demonstration
  const fakeTourMessages: Message[] = [
    {
      id: "fake-user-1",
      role: "user",
      content: "Das ist eine Beispiel-Nachricht des Benutzers.",
      timestamp: new Date(Date.now() - 120000) // 2 minutes ago
    },
    {
      id: "fake-ai-message",
      role: "assistant",
      content:
        "Und hier ist eine Beispiel-Antwort der KI. Wenn Sie den Mauszeiger über diese Nachricht bewegen, werden Aktionsbuttons angezeigt.",
      timestamp: new Date(Date.now() - 60000) // 1 minute ago
    }
  ]

  // Add loading state specifically for search
  const [isSearching, setIsSearching] = useState(false)
  // Add chat message search state
  const [searchOpen, setSearchOpen] = useState(false)
  const [messageSearchQuery, setMessageSearchQuery] = useState("")
  const [messageSearchResults, setMessageSearchResults] = useState<any[]>([])

  // New state variables for the export and summary modals
  const [showExportModal, setShowExportModal] = useState(false)
  const [showSummaryModal, setShowSummaryModal] = useState(false)
  const [chatSummary, setChatSummary] = useState("")
  const [isSummarizing, setIsSummarizing] = useState(false)

  // State for showing the message actions dialog
  const [showMessageActionsDialog, setShowMessageActionsDialog] =
    useState(false)
  const [isImprovingPrompt, setIsImprovingPrompt] = useState(false)

  // Add the state for showing settings modal
  const [showSettingsModal, setShowSettingsModal] = useState(false) // Add state for settings modal

  // Add state for storing user names
  const [userNamesMap, setUserNamesMap] = useState<{ [key: string]: string }>(
    {}
  )

  // Neue State-Variable für die ausgewählte Wissensdatenbank
  const [selectedKnowledgeBaseId, setSelectedKnowledgeBaseId] = useState<
    string[] | null
  >(null)

  // Online-Status-State
  const [isOnline, setIsOnline] = useState<boolean>(true); // Standardmäßig annehmen, dass wir online sind

  // Korrekte Typisierung des Refs am Anfang der Komponente
  const initialChatsLoadedRef = useRef(false);
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const isInitializingRef = useRef(false);
  const isStartingNewChatRef = useRef(false);

  // Improved state management for initialization with proper debouncing
  // Add this near the beginning of the component, around line 200-300
  const initializationTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const messageUpdateTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Event-Listener für Online/Offline-Status
  useEffect(() => {
    // Initialen Status setzen
    setIsOnline(navigator.onLine);
    
    // Handler für Online/Offline-Events
    const handleOnline = () => {
      console.log("🟢 Internetverbindung wiederhergestellt");
      setIsOnline(true);
      
      // Optional: Beim Wiederherstellen der Verbindung Daten neu laden
      if (user) {
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        loadChatSessionsMemoized(user.id, workspaceContext);
        loadTasksMemoized(user.id, workspaceContext);
        loadProjectsMemoized(user.id, workspaceContext);
      }
    };
    
    const handleOffline = () => {
      console.log("🔴 Internetverbindung verloren");
      setIsOnline(false);
    };
    
    // Event-Listener hinzufügen
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    // Event-Listener beim Unmount entfernen
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [user, rawWorkspaceId, personalWorkspaceId]);
  
  useEffect(() => {
    if (selectedTask && selectedTask.ai_model) {
      setSelectedModel(selectedTask.ai_model)
    }
  }, [selectedTask])

  // UI-Komponente für Offline-Status 
  const OfflineIndicator = () => {
    if (isOnline) return null;
    
    return (
      <div className="fixed bottom-4 right-4 z-50 rounded-md bg-yellow-600 px-4 py-2 text-white shadow-lg">
        <div className="flex items-center space-x-2">
          <div className="h-2 w-2 rounded-full bg-red-500"></div>
          <span>Offline-Modus - Einige Funktionen sind nicht verfügbar</span>
        </div>
      </div>
    );
  };

  useEffect(() => {
    const fetchPersonalWorkspace = async () => {
      if (user) {
        console.log("Fetching personal workspace for user:", user.id)
        const { data, error } = await supabase
          .from("workspaces")
          .select("id")
          .eq("user_id", user.id)
          .eq("is_home", true)
          .single() // Annahme: Es gibt nur EINEN persönlichen Workspace

        if (error && error.code !== "PGRST116") {
          // Ignore ' esattamente uma linha esperada'
          console.error("Error fetching personal workspace:", error)
        } else if (data) {
          console.log("Personal workspace found:", data.id)
          setPersonalWorkspaceId(data.id)
        } else {
          console.warn("Personal workspace not found for user:", user.id)
          // Hier könnte man optional den Workspace erstellen, falls er fehlt
          // oder eine Fehlermeldung anzeigen.
        }
      }
    }
    if (user && !rawWorkspaceId) {
      // Nur laden, wenn kein Workspace in URL und User bekannt
      fetchPersonalWorkspace()
    }
  }, [user, supabase, rawWorkspaceId]) // Abhängigkeiten

  // Optimierte Kontextauswahl mit Caching, besserer Priorisierung und Ausschluss aktueller Nachrichten
  // Cache für Chat-Sessions um redundante Ladevorgänge zu vermeiden
  const chatSessionsCache: {
    sessions: any[] | null
    timestamp: number
    maxAge: number
  } = {
    sessions: null,
    timestamp: 0,
    maxAge: 5000 // Cache ist für 5 Sekunden gültig
  }

  // Cache für Projektberechnungen
  const projectsCache: {
    projectChats: Map<string, any[]> | null
    timestamp: number
    maxAge: number
  } = {
    projectChats: null,
    timestamp: 0,
    maxAge: 10000 // Cache ist für 10 Sekunden gültig
  }

  // Optimierte Funktion zum Laden von Chat-Sessions mit Caching
  const loadChatSessionsWithCache = async (
    userId: string,
    workspaceId: string | null
  ) => {
    const now = Date.now()

    // Prüfen, ob der Cache gültig ist
    if (
      chatSessionsCache.sessions &&
      now - chatSessionsCache.timestamp < chatSessionsCache.maxAge
    ) {
      console.log("📦 Verwende gecachte Chat-Sessions")
      return chatSessionsCache.sessions
    }

    console.log(
      `🔄 Loading chat sessions - userId: ${userId} workspaceId: ${workspaceId}`
    )

    // Lade Daten wie zuvor
    const { data, error } = await supabase
      .from("chats")
      .select("*")
      .eq("user_id", userId)
      .eq("workspace_id", workspaceId)
      .order("updated_at", { ascending: false })

    if (error) {
      console.error("❌ Fehler beim Laden der Chat-Sessions:", error)
      return []
    }

    console.log(`✅ Loaded ${data.length} chat sessions`)

    // Verarbeite Daten und speichere sie im Cache
    const formattedSessions = data.map((chat: any) => ({
      id: chat.id,
      name: chat.name || "Neuer Chat",
      timestamp: chat.updated_at,
      message_count: chat.message_count || 0,
      project: chat.project || null,
      temperature: chat.temperature,
      model: chat.model || null
    }))

    // Cache aktualisieren
    chatSessionsCache.sessions = formattedSessions
    chatSessionsCache.timestamp = now

    return formattedSessions
  }

  // Optimierte Funktion zur Projektberechnung mit Caching
  const recalculateProjectsWithCache = (chats: any[]) => {
    const now = Date.now()

    // Prüfen, ob der Cache gültig ist
    if (
      projectsCache.projectChats &&
      now - projectsCache.timestamp < projectsCache.maxAge
    ) {
      return projectsCache.projectChats
    }

    console.log(
      `🔢 Berechne Projekte neu aus ${chats.length} verfügbaren Chats`
    )

    const projectChats = new Map()

    // Projekte berechnen wie zuvor
    const availableProjects = [
      ...new Set(chats.filter(c => c.project).map(c => c.project))
    ]

    availableProjects.forEach(project => {
      const chatsInProject = chats.filter(c => c.project === project)
      projectChats.set(project, chatsInProject)
      console.log(`🗂️ Projekt ${project} hat ${chatsInProject.length} Chats`)
    })

    // Cache aktualisieren
    projectsCache.projectChats = projectChats
    projectsCache.timestamp = now

    return projectChats
  }

  // Hauptfunktion für die Kontext-Suche, verbessert mit Ausschluss der aktuellen Nachricht
  const findSimilarMessagesOptimized = async (
    userId: string,
    query: string,
    currentMessageId: string | null = null
  ) => {
    debugLog(`🔍 Suche nach ähnlichen Nachrichten für User ${userId}`);
    debugLog(`📝 Suchanfrage: "${query}"`);

    // Skip search for very short queries to reduce database load
    if (query.trim().length < 3) {
      debugLog("⏩ Überspringe Suche für zu kurze Anfrage (weniger als 3 Zeichen)");
      return [];
    }

    // Validiere userId
    if (!userId || typeof userId !== "string" || userId.trim() === "") {
      console.error("❌ Ungültige userId für die Suche:", userId);
      return [];
    }

    try {
      // Erstelle ein temporäres Nachrichtenobjekt für das Embedding
      const tempQueryMessage = {
        content: query,
        id: "query", // Diese ID wird nicht in der DB gespeichert
        role: "user" as "user", // Explizit typisieren
        timestamp: new Date()
      };

      // Erstelle Embedding für die Anfrage
      debugLog(`🧠 Generiere Embedding für Suchanfrage...`);

      try {
        // Direkter Aufruf der Embedding-API als temporärer Ersatz für createEmbedding
        debugLog("📨 Original Nachrichteninhalt:", tempQueryMessage.content);
        const currentDate = new Date().toISOString().split("T")[0];
        const contentWithDate = `[Datum: ${currentDate}]\n${tempQueryMessage.content}`;
        
        const response = await fetch("/api/embeddings", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            input: contentWithDate
          })
        });
        
        if (!response.ok) {
          throw new Error(`Embedding API responded with ${response.status}`);
        }
        
        const embeddingData = await response.json();
        const embedding = embeddingData.embedding;

        if (!embedding) {
          console.error("❌ Fehler beim Generieren des Embeddings für die Suche");
          return [];
        }

        debugLog(`✅ Embedding für Abfrage erfolgreich generiert`);
        debugLog(`📊 Query-Embedding-Dimensionen: ${embedding.length}`);
        
        // Adjust similarity threshold based on query length
        const dynamicThreshold = query.length < 10 ? 0.75 : 0.65;
        const maxResults = query.length < 10 ? 10 : 20;
        
        debugLog(
          `📞 Rufe search_similar_messages RPC für User ${userId} auf (Schwellwert: ${dynamicThreshold}, Max Ergebnisse: ${maxResults})`
        );

        // RPC für die Ähnlichkeitssuche aufrufen
        const { data: results, error } = await supabase.rpc(
          "search_similar_messages",
          {
            p_user_id: userId,
            query_embedding: embedding,
            similarity_threshold: dynamicThreshold, // Use dynamic threshold
            max_results: maxResults
          }
        );

        if (error) {
          console.error("❌ Fehler bei der RPC-Suche nach ähnlichen Nachrichten:", error);
          return [];
        }

        debugLog(`🔎 RPC Ergebnis: ${results?.length || 0} Nachrichten gefunden`);
        
        if (!results || results.length === 0) {
          return [];
        }
        
        if (DEBUG_MODE) {
          debugLog(`📋 Erste Ergebnisse (Rohdaten): ${JSON.stringify(results?.slice(0, 2) || [])}`);
        }

        // Filtere die aktuelle Nachricht, falls vorhanden
        let filteredResults = results || [];
        if (currentMessageId) {
          const originalLength = filteredResults.length;
          filteredResults = filteredResults.filter(
            (msg: any) => msg.message_id !== currentMessageId
          );
          if (originalLength !== filteredResults.length) {
            debugLog(`🧹 Aktuelle Nachricht mit ID ${currentMessageId} aus Ergebnissen ausgeschlossen`);
          }
        }

        // Schnellere Verarbeitung der Datumsangaben ohne übermäßiges Logging
        for (const msg of filteredResults) {
          // Generiere eine anzeigbare Version des Inhalts ohne Datum
          msg.displayContent = msg.content;
          if (msg.content && typeof msg.content === 'string' && msg.content.startsWith('[Datum:') && msg.content.includes(']\n')) {
            msg.displayContent = msg.content.replace(/^\[Datum:[^\]]+\]\n/, '');
          }
          
          // Extrahiere Datum aus dem Nachrichteninhalt, aber logge nicht jede Nachricht
          const dateMatch = msg.content?.match(/\[Datum: ([^\]]+)\]/);
          msg.dateInfo = dateMatch ? dateMatch[1] : null;
        }

        debugLog(`✅ ${filteredResults.length} ähnliche Nachrichten nach Filterung gefunden`);

        return filteredResults;
      } catch (error) {
        console.error("❌ Fehler beim Erstellen des Embeddings:", error);
        return [];
      }
    } catch (error) {
      console.error("❌ Fehler bei der Suche nach ähnlichen Nachrichten:", error);
      return [];
    }
  };

  // Verbesserte Kontext-Auswahlfunktion mit optimierter Bewertung für neueste/älteste Nachrichten
  const prepareContextMessage = (contextContent: string) => {
    return {
      role: "system",
      content: `Relevanter Kontext aus früheren Gesprächen:\n\n${contextContent}\n\nDies sind Ausschnitte aus vorherigen Konversationen, die für die aktuelle Frage relevant sein könnten. Die mit "neueste Information" markierten Abschnitte enthalten den aktuellsten Stand zu diesem Thema, während "erste Erwähnung" historischen Kontext bietet. Nutze diese Informationen, um eine informierte Antwort zu geben, besonders wenn der Benutzer sich auf bereits besprochene Themen bezieht.`
    }
  }

  const loadChatSessions = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      console.log(
        "🔄 Loading chat sessions - userId:",
        userId,
        "workspaceId:",
        workspaceId
      )

      // Verwende personalWorkspaceId als Fallback, wenn keine workspaceId übergeben wird
      const targetWorkspaceId = workspaceId || personalWorkspaceId

      // Build the query
      let query = supabase
        .from("chats")
        .select(
          "id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id"
        )

      // Properly handle null workspace IDs
      if (targetWorkspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Chats in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq("workspace_id", targetWorkspaceId)
      } else {
        // Nur im persönlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is("workspace_id", null).eq("user_id", userId)
      }

      const { data, error } = await query.order("last_message_timestamp", {
        ascending: false
      })

      if (error) {
        console.error("❌ Error loading chat sessions:", error)
        setError(`Fehler beim Laden der Chats: ${error.message}`)
        throw error
      }

      if (data) {
        console.log("✅ Loaded", data.length, "chat sessions")
        console.log("Chat data:", data) // Debug: Zeige die Chat-Daten

        const formattedSessions = data.map((chat: any) => ({
          id: chat.id || "",
          name: chat.name || "Unnamed Chat",
          created_at: chat.created_at || new Date().toISOString(),
          last_message_timestamp: chat.last_message_timestamp,
          user_id: chat.user_id, // Behalte user_id um den Ersteller anzuzeigen
          ...(chat.description && { description: chat.description }),
          project_id: chat.project_id
        }))

        console.log("Formatted sessions:", formattedSessions) // Debug: Zeige die formatierten Sessions
        setChatSessions(formattedSessions)
      } else {
        console.log("ℹ️ No chat sessions found")
        setChatSessions([])
      }
    } catch (err) {
      console.error("❌ Error in loadChatSessions:", err)
      setChatSessions([])
    }
  }

  const createNewChat = async () => {
    try {
      if (!user) {
        setError("Sie müssen angemeldet sein, um einen Chat zu erstellen.")
        return null
      }

      // Determine the workspace ID to use - simplify this logic
      const workspaceId = rawWorkspaceId || personalWorkspaceId

      if (!workspaceId) {
        setError(
          "Konnte keinen gültigen Arbeitsbereich zum Erstellen des Chats finden."
        )
        return null
      }

      console.log(`Creating new chat in workspace: ${workspaceId}`)

      // Create a new chat with a temporary name - we'll update it later
      const newChatId = uuidv4()
      const initialTitle = "Neuer Chat"

      // Create with retry to ensure it succeeds
      const { data: newChat, error } = await supabase
        .from("chats")
        .insert({
          id: newChatId,
          user_id: user.id,
          name: initialTitle,
          workspace_id: workspaceId,
          created_at: new Date().toISOString(),
          last_message_timestamp: new Date().toISOString()
        })
        .select()
        .single()

      if (error) {
        console.error(`❌ Error creating new chat: ${error.message}`)
        setError(`Fehler beim Erstellen des Chats: ${error.message}`)
        return null
      }

      if (!newChat) {
        console.error("❌ No chat data returned after creation")
        setError("Fehler beim Erstellen des Chats: Keine Daten zurückgegeben")
        return null
      }

      console.log(`✅ Successfully created new chat with ID: ${newChatId}`)

      // Set the current chat ID immediately
      setCurrentChatId(newChatId)

      // Wait for the database to properly register the new chat
      await new Promise(resolve => setTimeout(resolve, 300))

      // Reload chat sessions to update UI
      if (user) {
        await loadChatSessions(user.id, workspaceId)
      }

      return newChatId
    } catch (err) {
      console.error("Error in createNewChat:", err)
      setError(
        `Fehler beim Erstellen des Chats: ${err instanceof Error ? err.message : "Unbekannter Fehler"}`
      )
      return null
    }
  }

  const loadChat = async (chatId: string) => {
    try {
      setCurrentChatId(chatId)

      // Try to get chat details first to confirm it exists
      const { data: chatData, error: chatError } = await supabase
        .from("chats")
        .select("id, name")
        .eq("id", chatId)
        .single()

      if (chatError) {
        console.error("Error fetching chat details:", chatError)
        return
      }

      // Get chat messages - now only using chat_id
      const { data: messagesData, error: messagesError } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (messagesError) {
        console.error("Error fetching chat messages:", messagesError)
        setMessages([])
        return
      }

      if (messagesData && messagesData.length > 0) {
        // Transform to our Message format
        const transformedMessages = messagesData.map((msg: any) => ({
          id: uuidv4(),
          role: msg.role as "user" | "assistant" | "system",
          content: msg.content,
          timestamp: new Date(msg.created_at),
          user_id: msg.user_id, // Store user_id from database
          sentfrom: msg.sentfrom // Store sentfrom from database
        }))

        setMessages(transformedMessages)
        console.log(
          `Loaded ${transformedMessages.length} messages for chat ${chatId}`
        )

        // Fetch usernames for all unique user_ids in messages
        const userIds = [
          ...new Set(
            transformedMessages
              .filter(msg => msg.role === "user" && msg.user_id)
              .map(msg => msg.user_id)
          )
        ]

        if (userIds.length > 0) {
          const { data: profilesData, error: profilesError } = await supabase
            .from("profiles")
            .select("id, full_name")
            .in("id", userIds)

          if (profilesError) {
            console.error("Error fetching user profiles:", profilesError)
          } else if (profilesData) {
            // Create a map of user_id to full_name
            const userNames: { [key: string]: string } = {}
            profilesData.forEach(profile => {
              userNames[profile.id] = profile.full_name
            })
            setUserNamesMap(userNames)
          }
        }
      } else {
        console.log(`No messages found for chat ${chatId}`)
        setMessages([])
      }
    } catch (err) {
      console.error("Error loading chat:", err)
      setMessages([])
    }
  }

  const loadTasks = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status prüfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - Überspringe Laden der Tasks");
        return; // Früher Abbruch bei fehlender Internetverbindung
      }

      // Timeout für die Anfrage setzen, um lange hängende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("tasks").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Tasks in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im persönlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufräumen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedTasks = data.map(task => ({
            ...task,
            title: task.title || task.name,
            ai_model: task.ai_model || task.preferred_model || "gpt-4o"
          }));
          setTasks(formattedTasks);
        }
      } catch (fetchError: any) {
        // Timeout aufräumen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Prüfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Task-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Tasks - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading tasks:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu überfluten
      // Wenn die Seite neu geladen wird, wird ein neuer Versuch unternommen
    }
  };

  const loadProjects = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status prüfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - Überspringe Laden der Projekte");
        return; // Früher Abbruch bei fehlender Internetverbindung
      }

      // Timeout für die Anfrage setzen, um lange hängende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("projects").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Projekte in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im persönlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufräumen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedProjects = data.map(project => ({
            ...project,
            name: project.name || project.title,
            workspace_id:
              project.workspace_id || project.preferred_workspace_id || "gpt-4o"
          }));
          setProjects(formattedProjects);
        }
      } catch (fetchError: any) {
        // Timeout aufräumen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Prüfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Project-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Projekte - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading projects:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu überfluten
    }
  };

  // Wenn ein user (per Link Sharing) einen spezifischen Chat betritt, dann direkt laden
  useEffect(() => {
    // Lade alle verfügbaren Tasks als Optionen
    if (user) {
      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
      loadTasks(user.id, workspaceContext)
    }

    // Wenn eine Task-ID in der URL ist, lade diese Task
    if (taskId) {
      console.log("Task ID in URL gefunden:", taskId)
      const fetchTask = async () => {
        if (!supabase) return

        const { data, error } = await supabase
          .from("tasks")
          .select("*")
          .eq("id", taskId)
          .single()

        if (error) {
          console.error("Fehler beim Laden der Task:", error)
          return
        }

        if (data) {
          console.log("Task geladen:", data)
          setSelectedTask(data)
          setSelectedModel(data.ai_model || "gpt-4o")
        }
      }

      fetchTask()
    }
  }, [user, taskId, supabase, rawWorkspaceId, personalWorkspaceId, loadTasks])

  // Effect für die Textareabehandlung
  useEffect(() => {
    const textarea = inputRef.current
    if (textarea) {
      // Reset height - wichtig, um zu verhindern, dass es nur nach oben wächst
      textarea.style.height = "auto"
      // Setze die neue Höhe basierend auf dem Scroll-Höhen-Wert
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`
    }
  }, [inputValue])

  // Reduziere unnötige Re-Renders durch Memoization der Lade-Funktionen
  const loadChatSessionsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadChatSessions(userId, workspaceId);
    },
    [supabase, setChatSessions]
  );
  
  const loadChatMemoized = useCallback(
    async (chatId: string) => {
      return await loadChat(chatId);
    },
    [supabase, user, setMessages, setUserNamesMap]
  );
  
  const loadTasksMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadTasks(userId, workspaceId);
    },
    [supabase, setTasks]
  );
  
  const loadProjectsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadProjects(userId, workspaceId);
    },
    [supabase, setProjects]
  );

  // Haupt-Initialisierungscode für den Chat
  useEffect(() => {
    // Zeitsperre, um zu häufige Aufrufe zu verhindern
    const checkSession = async () => {
      // Vermeide mehrfache gleichzeitige Initialisierungen
      if (isInitializingRef.current) {
        debugLog("Initialization already in progress, skipping");
        return;
      }
      
      isInitializingRef.current = true;
      try {
        setLoading(true);

        // Prüfe, ob der Benutzer angemeldet ist
        const {
          data: { session }
        } = await supabase.auth.getSession();

        if (!session) {
          console.log("No session found, redirecting to login");
          router.push("/login");
          return;
        }

        // Benutzer ist angemeldet
        setUser(session.user);

        // Profilnamen laden (nicht kritisch für Initialisierung)
        if (!userFullName || userFullName === "Du") {
          try {
            const { data: profileData } = await supabase
              .from("profiles")
              .select("full_name")
              .eq("id", session.user.id)
              .single();

            if (profileData?.full_name) {
              setUserFullName(profileData.full_name);
            }
          } catch (profileError) {
            console.error("Error loading user profile:", profileError);
          }
        }

        debugLog(`*** Session exists, user: ${session.user.id}`);

        // Workspace-Kontext bestimmen
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        debugLog("Current workspace context:", workspaceContext);

        // Chats nur laden, wenn nötig
        if (workspaceContext && !initialChatsLoadedRef.current && chatSessions.length === 0) {
          debugLog("Loading chat sessions for the first time");
          // Use Promise.all to load data in parallel
          await Promise.all([
            loadChatSessionsMemoized(session.user.id, workspaceContext),
            loadProjectsMemoized(session.user.id, workspaceContext)
          ]);
          initialChatsLoadedRef.current = true;
        }

        // Wenn ein Chat bereits in state ist, lade ihn
        if (currentChatId) {
          debugLog("Chat ID in state bereits vorhanden:", currentChatId);
          await loadChatMemoized(currentChatId);
        } else if (chatSessions.length > 0 && !messages.length && !isStartingNewChatRef.current) {
          // Sonst lade den ersten Chat, aber nur wenn:
          // - keine Nachrichten bereits geladen sind 
          // - UND kein expliziter Neustart eines Chats angefordert wurde
          debugLog("Lade den ersten Chat aus vorhandenen Sessions:", chatSessions[0].id);
          setCurrentChatId(chatSessions[0].id);
          await loadChatMemoized(chatSessions[0].id);
        } else if (isStartingNewChatRef.current) {
          debugLog("Neuer Chat wurde explizit angefordert - lade keinen vorhandenen Chat");
          // Flag zurücksetzen nach Verwendung
          isStartingNewChatRef.current = false;
        }

        // Tasks laden (wenn noch nicht geladen)
        if (tasks.length === 0 && workspaceContext) {
          await loadTasksMemoized(session.user.id, workspaceContext);
        }

        // Icebreakers zeigen, wenn keine Nachrichten vorhanden
        if (messages.length === 0) {
          setShowIceBreakers(true);
        }

        // Task laden, wenn eine ID übergeben wurde
        if (taskId && (!selectedTask || selectedTask.id !== taskId)) {
          const { data: taskData, error } = await supabase
            .from("tasks")
            .select("*")
            .eq("id", taskId)
            .single();

          if (!error && taskData) {
            debugLog("Task geladen:", taskData);
            setSelectedTask(taskData);
            setSelectedModel(taskData.ai_model || selectedModel);
          }
        }
      } catch (err: any) {
        console.error("Chat init error:", err);
        setError(err.message);
      } finally {
        setLoading(false);
        
        // Use setTimeout to avoid race conditions when setting isInitializingRef
        if (initializationTimeoutRef.current) {
          clearTimeout(initializationTimeoutRef.current);
        }
        
        initializationTimeoutRef.current = setTimeout(() => {
          isInitializingRef.current = false;
          debugLog("Initialization flag reset to false");
          initializationTimeoutRef.current = null;
        }, 100);
      }
    };

    checkSession();
    
    // Cleanup function
    return () => {
      if (initializationTimeoutRef.current) {
        clearTimeout(initializationTimeoutRef.current);
      }
      if (messageUpdateTimeoutRef.current) {
        clearTimeout(messageUpdateTimeoutRef.current);
      }
    };
  }, [
    supabase,
    currentChatId,
    personalWorkspaceId,
    rawWorkspaceId,
    router,
    taskId
  ]);

  /* eslint-disable react-hooks/rules-of-hooks */
  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        modelDropdownRef.current &&
        !modelDropdownRef.current.contains(event.target as Node)
      ) {
        setShowModelDropdown(false)
      }

      if (
        taskDropdownRef.current &&
        !taskDropdownRef.current.contains(event.target as Node)
      ) {
        setShowTaskDropdown(false)
      }

      // Schließe Chat-Menü bei Klick außerhalb
      const chatMenuTarget = (event.target as Element)?.closest(
        "[data-chat-menu]"
      )
      if (chatMenuOpen && !chatMenuTarget) {
        setChatMenuOpen(null)
      }

      // Schließe Projekt-Menü bei Klick außerhalb
      const projectMenuTarget = (event.target as Element)?.closest(
        "[data-project-menu]"
      )
      if (projectMenuOpen && !projectMenuTarget) {
        setProjectMenuOpen(null)
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [chatMenuOpen, projectMenuOpen])

  // Haupt-Funktion zum Senden einer Nachricht an die API
  const sendMessageToAPI = async (
    messages: Message[],
    model: string,
    chatId: string
  ) => {
    console.log(`🔄 sendMessageToAPI v2 aufgerufen mit Chat-ID: ${chatId}`);

    const userId = user?.id;
    if (!userId) {
      console.error("❌ User ID fehlt beim Senden an API.");
      throw new Error("User ID ist erforderlich");
    }

    // 1. DATEN SAMMELN (wie bisher)
    // --------------------------------
    console.log(`👤 Hole Benutzerprofil für User ID: ${userId}`);
    const { data: fetchedUserProfile, error: profileError } = await supabase
        .from("profiles")
        .select("*")
      .eq("id", userId)
      .single();
      
    // Use fetchedUserProfile instead of the state variable userProfile directly here
    // to ensure we have the latest data for this specific call.
    if (profileError) console.error("Fehler beim Abrufen des Profils:", profileError);
    else console.log("✅ Benutzerprofil erfolgreich abgerufen");

    const lastUserMessage = [...messages].reverse().find(m => m.role === "user");
    let knowledgeResults: any[] = [];
    let similarMessages: any[] = []; // Assuming this holds structured QA or relevant snippets
    // (SelectedTask comes from component state)
    const currentSelectedTask = selectedTask; // Capture state at the time of call

    if (lastUserMessage) {
        const userQuery = lastUserMessage.content;
        
        // Wissensdatenbank-Suche (falls KB ausgewählt)
        if (selectedKnowledgeBaseId && selectedKnowledgeBaseId.length > 0) { 
            try {
                console.log(`🧠 Performing knowledge base search for KBs: ${selectedKnowledgeBaseId.join(', ')}...`);
                const { data: authData } = await supabase.auth.getSession();
                const authToken = authData?.session?.access_token;

                // Alle Ergebnisse aus allen ausgewählten Wissensdatenbanken sammeln
                let allKnowledgeResults: any[] = [];
                
                // Sequentiell durch alle ausgewählten Wissensdatenbanken gehen
                for (const kbId of selectedKnowledgeBaseId) {
                    const knowledgeResponse = await fetch("/api/knowledge/search", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            query: userQuery,
                            knowledge_base_id: kbId,
                            auth_token: authToken
                        })
                    });
                    
                    if (knowledgeResponse.ok) {
                        const knowledgeData = await knowledgeResponse.json();
                        const results = knowledgeData.results || [];
                        console.log(`🧠 Found ${results.length} raw knowledge items from KB ${kbId}.`);
                        allKnowledgeResults.push(...results);
                    } else {
                        console.error(`⚠️ Knowledge base search failed for KB ${kbId}:`, knowledgeResponse.statusText);
                    }
                }
                
                // Sortiere alle Ergebnisse nach Relevanz (falls ein similarity-Feld existiert)
                knowledgeResults = allKnowledgeResults.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));
                console.log(`🧠 Combined ${knowledgeResults.length} total knowledge items from all KBs.`);
          
            } catch (knowledgeError) {
                console.error("❌ Error during knowledge base search fetch:", knowledgeError);
            }
        } else {
            console.log("ℹ️ Keine Wissensdatenbank ausgewählt, überspringe Suche.");
        }
        
        // Suche nach ähnlichen Nachrichten (wie bisher)
        try {
            console.log(`🔍 Suche nach User-weiten Kontext für User ${userId}, basierend auf: ${userQuery.substring(0, 30)}...`);
            // Assuming findSimilarMessagesOptimized returns the structured data needed
            similarMessages = await findSimilarMessagesOptimized(userId, userQuery, lastUserMessage.id) || [];
            console.log(`✅ ${similarMessages.length} ähnliche Nachrichten gefunden`);
             // Log details of similar messages structure if needed for debugging
             // console.log("Similar messages structure:", JSON.stringify(similarMessages.slice(0,2), null, 2));
        } catch (error) {
            console.error("❌ Fehler bei der Suche nach ähnlichen Nachrichten:", error);
        }

    } else {
      console.warn("Keine letzte Benutzernachricht gefunden, kann keinen Kontext generieren.");
      // Handle case where there's somehow no user message? Maybe return early or send without context.
    }
    
    // KONSOLIDIERTE PROMPT-ERSTELLUNG MIT DEM NEUEN PROMPT-BUILDER
    // -------------------------------------------
    const userInput = lastUserMessage ? lastUserMessage.content : "";
    
    // Verwende den neuen buildPrompt statt manueller Zusammensetzung
    const finalPrompt = buildPrompt({
      userInput,
      chatId,
      taskPrompt: currentSelectedTask?.system_prompt || null,
      // Verwende den aus prompt-builder.ts importierten DEFAULT_SYSTEM_PROMPT 
      // Das systemPrompt muss hier nicht explizit übergeben werden, da es den DEFAULT_SYSTEM_PROMPT nutzt
      userProfile: fetchedUserProfile,
      knowledgeResults,
      pastMessages: similarMessages,
      allMessages: messages,
      modelType: "default", // Standard-Chat
      maxPastMessages: 4,
      maxKnowledgeResults: 3
    });
    
    console.log(`📩 Sende an API: ${messages.filter(m => m.role !== 'system').length} User/Assistant Nachrichten, ${finalPrompt.length - messages.filter(m => m.role !== 'system').length} System/Assistant Kontextobjekt(e)`);
    console.log("Final apiMessages array (V2) before API call:", JSON.stringify(finalPrompt, null, 2));
    
    // API CALL MIT STREAMING
    // --------------------------------------------------
    try {
        const apiUrl = `/api/chat?model=${encodeURIComponent(model)}&chatId=${encodeURIComponent(chatId)}`;
        
        // Streaming aktivieren
        const streaming = true;
        
        if (streaming) {
          // Streaming Anfrage mit benutzerdefinierten Parametern
          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              messages: finalPrompt,
              streaming: true
            })
          });
          
          if (!response.ok) {
            const errorBody = await response.text();
            console.error("API Error Response Body:", errorBody);
            throw new Error(`API responded with ${response.status}`);
          }

          // Stream verarbeiten
          const reader = response.body?.getReader();
          if (!reader) throw new Error("Stream reader not available");
          
          const decoder = new TextDecoder();
          let fullContent = "";
          let metaInfo = null;
          
          // Event-basierter Streaming-Modus (gibt Text-Chunks zurück während sie ankommen)
          return {
            content: "", // Wird unten schrittweise gefüllt
            streamContent: async function* () {
              let buffer = ""; // Puffer für eingehende Chunks
              const decoder = new TextDecoder();
              let accumulatedJsonRemainder = ""; // Buffer for incomplete JSON chunks

              try {
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) {
                    // Yield any remaining buffer content when the stream ends
                    if (buffer.length > 0) {
                      yield buffer;
                      // fullContent is already updated progressively
                    }
                     // Yield any remaining JSON remainder if it's valid text
                    if (accumulatedJsonRemainder.length > 0 && !accumulatedJsonRemainder.startsWith('{')) {
                       yield accumulatedJsonRemainder;
                    }
                    break;
                  }

                  const rawChunk = decoder.decode(value, { stream: true });
                  accumulatedJsonRemainder += rawChunk;

                  let textToProcess = "";
                  let processFromIndex = 0;

                  // Attempt to parse JSON if it looks like it might be JSON
                  if (accumulatedJsonRemainder.includes('{') && accumulatedJsonRemainder.includes('}')) {
                      try {
                          // Find potential JSON boundary more robustly
                          let potentialJsonEnd = accumulatedJsonRemainder.lastIndexOf('}') + 1;
                          let potentialJson = accumulatedJsonRemainder.substring(0, potentialJsonEnd);
                          
                          // Basic check if it looks like a valid JSON object
                          if (potentialJson.startsWith('{')) {
                              const parsed = JSON.parse(potentialJson);
                              if (parsed && typeof parsed.content === 'string') {
                                  textToProcess = parsed.content;
                                  // Update fullContent only with the actual text part
                                  fullContent += textToProcess;
                                  // Remove the processed JSON part from the remainder
                                  accumulatedJsonRemainder = accumulatedJsonRemainder.substring(potentialJsonEnd);
                                  processFromIndex = 0; // Start processing the new text from beginning
                              } else {
                                 // Valid JSON but not the expected format, treat accumulated as text
                                 textToProcess = accumulatedJsonRemainder;
                                 fullContent += textToProcess; // Add raw chunk to fullContent
                                 accumulatedJsonRemainder = ""; // Clear remainder
                      }
    } else {
                             // Doesn't start with '{', treat as raw text
                             textToProcess = accumulatedJsonRemainder;
                             fullContent += textToProcess; // Add raw chunk to fullContent
                             accumulatedJsonRemainder = ""; // Clear remainder
                        }
                      } catch (e) {
                          // Invalid JSON or incomplete chunk, wait for more data or treat as text if stream ends
                          // Continue accumulating, do not process buffer yet unless it's very long
                          if (accumulatedJsonRemainder.length > 1000) { // Process as text if buffer gets too long
                               textToProcess = accumulatedJsonRemainder;
                               fullContent += textToProcess; // Add raw chunk to fullContent
                               accumulatedJsonRemainder = ""; // Clear remainder
                      }
                    }
    } else {
                     // Does not contain braces, likely raw text
                     textToProcess = accumulatedJsonRemainder;
                     fullContent += textToProcess; // Add raw chunk to fullContent
                     accumulatedJsonRemainder = ""; // Clear remainder
                  }
                  
                  // If we extracted text (either from JSON or raw chunk), add to buffer and yield words
                  if (textToProcess) {
                    buffer += textToProcess;

                    // Process the buffer to yield whole words/segments
                    let lastDelimiterPos = -1;
                    const lastSpacePos = buffer.lastIndexOf(' ');
                    const lastNewlinePos = buffer.lastIndexOf('\\n');
                    lastDelimiterPos = Math.max(lastSpacePos, lastNewlinePos);

                    if (lastDelimiterPos !== -1) {
                      const partToYield = buffer.substring(0, lastDelimiterPos + 1);
                      if (partToYield.length > 0) {
                           yield partToYield;
                      }
                      buffer = buffer.substring(lastDelimiterPos + 1);
                    }
                  }
                }
              } catch (error) {
                console.error("Error reading stream:", error);
                if (buffer.length > 0) yield buffer;
                if (accumulatedJsonRemainder.length > 0) yield accumulatedJsonRemainder;
                throw error;
              } finally {
                this.content = fullContent;
              }
            },
            getContent: () => fullContent,
            model: model
          };
        } else {
          // Nicht-Streaming-Modus (für Fallback)
      const apiResponse = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
              messages: finalPrompt
        })
        });

      if (!apiResponse.ok) {
            // Log response body if available
            const errorBody = await apiResponse.text();
            console.error("API Error Response Body:", errorBody);
            throw new Error(`API responded with ${apiResponse.status}`);
        }

        const data = await apiResponse.json();
        return data; // Rückgabe an den Aufrufer (handleSendMessage)
        }
    } catch (error) {
        console.error("❌ Fehler beim API-Aufruf in sendMessageToAPI:", error);
        throw error; // Fehler weitergeben, damit handleSendMessage ihn fangen kann
    }
  }  // Ende von sendMessageToAPI

  const handleTypewriterComplete = (messageId: string) => {
    const updatedMessages = messages.map(m =>
      m.id === messageId ? { ...m, isTypewriting: false } : m
    )
    setMessages(updatedMessages)
    setTypingMessageId(null)
  }

  const handleCreateTask = async () => {
    if (!newTaskName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || null

      const { data, error } = await supabase
        .from("tasks")
        .insert({
          title: newTaskName,
          description: newTaskDescription,
          system_prompt: newTaskSystemPrompt,
          ai_model: newTaskModel,
          status: "todo",
          priority: "medium",
          user_id: user.id,
          workspace_id: workspaceContext
        })
        .select()

      if (error) throw error

      await loadTasks(user.id, workspaceContext)

      setShowTaskModal(false)
      setNewTaskName("")
      setNewTaskDescription("")
      setNewTaskSystemPrompt("")
      setNewTaskModel("gpt-4o")
    } catch (err) {
      console.error("Error creating task:", err)
    } finally {
      setLoading(false)
    }
  }

  const handleCreateProject = async () => {
    if (!newProjectName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null

      // ---> START DEBUG LOG <---
      console.log("--- Creating Project --- ")
      console.log("User ID to send:", user?.id)
      console.log("Raw Workspace ID from URL:", rawWorkspaceId)
      console.log("Personal Workspace ID state:", personalWorkspaceId)
      console.log("Workspace Context to send:", workspaceContext)
      // ---> END DEBUG LOG <---

      // ---> ADDED AUTH CHECK <---
      const { data: authData, error: authError } =
        await supabase.auth.getSession()
      console.log("--- Auth Check Before Insert ---")
      console.log("Current Session:", authData?.session)
      console.log("Session User ID:", authData?.session?.user?.id)
      console.log("Auth Error:", authError)
      if (authError || !authData?.session) {
        console.error("CRITICAL: No valid session before insert!")
        // Optionally: Prevent the insert or show an error to the user
        // return;
      }
      // ---> END AUTH CHECK <---

      // ---> ADDED DIAGNOSTIC FUNCTION <---
      // This immediately runs when you click "Create Project" in the UI
      // It helps diagnose why the workspace membership check fails
      console.log("--- Running Diagnostic Function ---")
      const diagResult = await supabase.rpc("diagnose_workspace_membership", {
        p_user_id: user.id,
        p_workspace_id: workspaceContext
      })
      console.log("Diagnosis Result:", diagResult)
      // Explicit logging of the important diagnostic data
      console.log("MEMBERSHIP DATA:", JSON.stringify(diagResult.data, null, 2))
      if (diagResult.data) {
        console.log("User ID Input:", diagResult.data.user_id_input)
        console.log("Workspace ID Input:", diagResult.data.workspace_id_input)
        console.log("Membership Exists:", diagResult.data.membership_exists)
        console.log("Membership Count:", diagResult.data.membership_count)
        console.log("All User Workspaces:", diagResult.data.all_user_workspaces)
        console.log(
          "All Workspace Members:",
          diagResult.data.all_workspace_members
        )
      }
      // ---> END DIAGNOSTIC FUNCTION <---

      // Use the database function instead of direct table access
      // This bypasses RLS issues while maintaining security checks in the function
      const { data, error } = await supabase.rpc("create_project", {
        p_name: newProjectName,
        p_description: newProjectDescription,
        p_user_id: user.id,
        p_workspace_id: workspaceContext,
        p_color: "#4c4cff",
        p_status: "active"
      })

      if (error) throw error

      await loadProjects(user.id, workspaceContext)
      setShowProjectModal(false)
      setNewProjectName("")
      setNewProjectDescription("")
    } catch (err) {
      console.error("Error creating project:", err)
    } finally {
      setLoading(false)
    }
  }

  // Generate a chat name from the first user message
  const generateChatName = (message: string): string => {
    // Split the message into words
    const words = message.trim().split(/\s+/)

    // Get up to the first 3 words
    const firstThreeWords = words.slice(0, 3).join(" ")

    // If the result is too short, use "Neuer Chat"
    return firstThreeWords.length >= 3 ? firstThreeWords : "Neuer Chat"
  }

  // Modifiziere den useEffect für Task-Wechsel
  useEffect(() => {
    // Only perform task change operations if no message update is pending
    // And ensure at least 500ms has passed since the last message update
    const timeSinceLastUpdate = Date.now() - lastMessageUpdate
    if (messageUpdatePending || timeSinceLastUpdate < 500) {
      console.log(
        "Message update in progress or too recent, deferring task change handling"
      )
      return
    }

    const handleTaskOrModelChange = async () => {
      // Prüfen, ob es sich um einen Task- oder Modellwechsel handelt
      const isTaskChange = selectedTask?.id !== previousSelectedTask?.id
      // const isModelChange = selectedModel !== previousSelectedModel && !selectedTask;

      // Run this logic ONLY on task change, not on simple model selection
      if (isTaskChange && messages.length > 0) {
        // Wenn eine Task oder ein Modell gewechselt wurde und es Nachrichten gibt

        console.log("Task wurde gewechselt, erstelle Zusammenfassung...")

        try {
          // Prüfe, ob bereits eine Zusammenfassung im Chat existiert
          const lastSummaryMessage = [...messages]
            .reverse()
            .find(
              msg =>
                msg.role === "assistant" &&
                (msg.content.includes("Chat-Zusammenfassung") ||
                  msg.content.includes("Hauptpunkte:") ||
                  msg.content.includes("Zusammenfassung des Chats"))
            )

          let summary: string

          if (lastSummaryMessage) {
            // Verwende die vorhandene Zusammenfassung
            console.log("Verwende vorhandene Zusammenfassung")
            summary = lastSummaryMessage.content
          } else {
            // Erstelle eine neue Zusammenfassung, da keine vorhanden ist
            console.log("Überspringe Zusammenfassung für Task-Wechsel (DEBUG)")
            summary = "" // Temporär deaktiviert
          }

          if (summary) {
            // Erstelle eine neue System-Nachricht mit der Zusammenfassung
            const summarySystemMessage: Message = {
              id: uuidv4(),
              role: "system",
              content: `Zusammenfassung des bisherigen Gesprächs: ${summary}

${selectedTask ? selectedTask.system_prompt : "Fahre mit dem Gespräch fort, basierend auf dieser Zusammenfassung."}`,
              timestamp: new Date()
            }

            // Entferne alle bisherigen System-Nachrichten
            const filteredMessages = messages.filter(m => m.role !== "system")

            // Füge die neue System-Nachricht am Anfang hinzu
            setMessages([summarySystemMessage, ...filteredMessages])

            console.log(
              "Zusammenfassung wurde als System-Nachricht hinzugefügt."
            )

            // Task-switching notification message is REMOVED
          }
        } catch (error) {
          console.error("Error in task change handling:", error)
        } finally {
          // Always set isTaskSwitching to false when complete
          setIsTaskSwitching(false)
        }
      } else {
        // If there's no task change or no messages, just reset the switching state
        setIsTaskSwitching(false)
      }

      // Aktuelle Task und Modell für den nächsten Vergleich speichern
      setPreviousSelectedTask(selectedTask)
      setPreviousSelectedModel(selectedModel)
    }

    handleTaskOrModelChange()
  }, [
    selectedTask,
    selectedModel,
    messages,
    messageUpdatePending,
    previousSelectedTask,
    previousSelectedModel,
    lastMessageUpdate
  ])

  // Add this function to sync messages with the database when needed
  const syncMessagesWithDatabase = async (chatId: string) => {
    if (!chatId) return

    try {
      console.log("Syncing messages with database for chat:", chatId)
      const { data, error } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (error) {
        console.error("Error syncing messages:", error)
        return
      }

      if (data) {
        // Convert database messages to app message format
        const formattedMessages: Message[] = data.map(dbMsg => ({
          id: dbMsg.id || uuidv4(),
          role: dbMsg.role as "user" | "assistant" | "system",
          content: dbMsg.content,
          timestamp: new Date(dbMsg.created_at)
        }))

        console.log(`Synced ${formattedMessages.length} messages from database`)
        setMessages(formattedMessages)
      }
    } catch (error) {
      console.error("Error in syncMessagesWithDatabase:", error)
    }
  }

  // Modify handleSendMessage to optionally include web search results
  const handleSendMessage = async (
    message: string,
    includeWebSearch: boolean = false
  ) => {
    if (message.trim().length === 0) return
    if (isTyping || messageUpdatePending || isTaskSwitching) return

    // Markieren, dass der Benutzer mit dem Tippen begonnen hat
    setHasStartedTyping(true)

    const userMessageId = uuidv4()
    const newMessage: Message = {
      id: userMessageId,
      role: "user",
      content: message,
      timestamp: new Date(),
      user_id: user?.id,
      sentfrom: userFullName
    }

    console.log("Creating new message with user_id:", user?.id)

    try {
      // Prevent task switching effects during message sending
      setMessageUpdatePending(true)
      setLastMessageUpdate(Date.now())

      // Create the new array *before* setting state
      const newMessagesArray = [...messages, newMessage]

      // Add user message to state immediately for better UX
      setMessages(newMessagesArray) // Use the new array
      setInputValue("") // Eingabefeld leeren

      // Show typing indicator
      setIsTyping(true)

      // If web search is requested, perform it before sending to API
      let webSearchResults = null
      if (includeWebSearch) {
        setIsSearching(true)
        try {
          webSearchResults = await performSerpApiSearch(message)
          console.log("Web search results:", webSearchResults.length)
        } catch (searchError) {
          console.error("Error during web search:", searchError)
        } finally {
          setIsSearching(false)
        }
      }

      let chatIdToUse = currentChatId

      // If no current chat exists, create a new one before proceeding
      if (!chatIdToUse) {
        console.log(
          "No current chat, creating new one before sending message..."
        )
        chatIdToUse = await createNewChat()
        if (!chatIdToUse) {
          throw new Error("Failed to create a new chat")
        }
        console.log(`Successfully created new chat with ID: ${chatIdToUse}`)
        // Set current chat ID immediately to ensure context is maintained
        setCurrentChatId(chatIdToUse)
      }

      // Speichern der Benutzernachricht in der Datenbank
      console.log(`Saving message to chat ID: ${chatIdToUse}`)

      // Wichtig: Wir benötigen diese Nachrichts-ID für Embedding
      let dbMessageId = null;

      try {
      const { data: messageData, error: messageError } = await retryOperation(
        async () => {
          return await supabase
            .from("chat_messages")
            .insert({
              chat_id: chatIdToUse,
              role: "user",
                content: message,
              user_id: user?.id,
              sentfrom: userFullName,
              created_at: newMessage.timestamp.toISOString()
            })
            .select()
        },
        3,
        1000
        );

      if (messageError) {
        console.error("❌ Error saving message:", messageError)
      } else {
        console.log("✅ Message saved successfully to database", messageData)
          // Speichere die ID für spätere Verwendung
        if (messageData && messageData.length > 0) {
            dbMessageId = messageData[0].id;
          }
        }
      } catch (saveError) {
        console.error("Error saving user message:", saveError);
        // Wir setzen den Prozess fort, auch wenn die Nachricht nicht gespeichert werden konnte
      }

      // Vorbereiten und Senden der Anfrage an die API
      try {
        const modelToUse = selectedTask?.ai_model || selectedModel
        console.log("📣 Sende Nachricht an API mit Chat-ID:", chatIdToUse)
        console.log("🔄 Ausgewähltes Modell für diese Anfrage:", modelToUse);

        // Streaming-Response
        const response = await sendMessageToAPI(
          newMessagesArray,
          modelToUse,
          chatIdToUse
        )

        // Assistentennachricht erstellen und anzeigen (vorerst leer)
        const assistantMessageId = uuidv4()
        const assistantMessage: Message = {
          id: assistantMessageId,
          role: "assistant",
          content: "", // Startinhalt ist leer, wird nach und nach gefüllt
          timestamp: new Date(),
          isTypewriting: true // Ensure this is set to true
        }

        // Calculate whether to show the effect
        const showEffect = assistantMessage.role === "assistant" && (assistantMessage.isTypewriting || typingMessageId === assistantMessage.id);

        // Modifiziere die AssistentMessage-Creation für mehr Konsistenz
        const assistantMessage: Message = {
          id: assistantMessageId,
          role: "assistant",
          content: "", // Startinhalt ist leer, wird nach und nach gefüllt
          timestamp: new Date(),
          isTypewriting: true // Stelle sicher, dass dies immer auf true gesetzt ist
        };

        // Add to messages immediately to show the placeholder
        setMessages(prevMessages => [...prevMessages, assistantMessage])
        setTypingMessageId(assistantMessageId) // Track the message ID that's being typed

        // Wenn Streaming-Antwort verfügbar ist, nutze diese
        if (response.streamContent) {
"use client"

import React from "react"
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs"
import { useEffect, useRef, useState, useMemo, useCallback } from "react"
import { useSearchParams } from "next/navigation"
import Link from "next/link"
import {
  ChevronLeft,
  Menu,
  Plus,
  Send,
  ChevronDown,
  Copy,
  RotateCcw,
  Edit,
  Paperclip,
  Image,
  Search,
  MoreVertical,
  Trash,
  X,
  FlaskConical,
  MoreHorizontal,
  Mic,
  Loader,
  FileText,
  FileDown,
  BookOpen,
  User,
  Settings,
  Home,
  ChevronRight,
  MessageCircle,
  Sparkles,
  Check
} from "lucide-react" // Added Icons
import ReactMarkdown from "react-markdown"
import remarkGfm from "remark-gfm"
import { v4 as uuidv4 } from "uuid"
import { TypewriterEffect } from "@/components/typewriter-effect"
import { RevealEffect } from "@/components/reveal-effect"; // Import RevealEffect
import { useRouter } from "next/navigation"
import { cn } from "@/lib/utils"
import Joyride, { Step, CallBackProps, STATUS } from "react-joyride" // Import Joyride
import dynamic from "next/dynamic" // Import dynamic
import {
  performSerpApiSearch,
  formatSearchResults,
  formatSearchResultsForAI
} from "../utils/serpApi"
import { downloadChatAsPdf } from "../utils/pdfExport"
import { generateChatSummary } from "../utils/chatSummary"
import ExportModal from "../components/ExportModal"
import SummaryModal from "../components/SummaryModal"
// Drag-and-Drop-Bibliotheken
import {
  DndContext,
  useDraggable,
  useDroppable,
  useSensors,
  useSensor,
  PointerSensor
} from "@dnd-kit/core"
import LoadingIndicator from "@/components/LoadingIndicator" // Corrected import path
import SettingsModal from "@/app/components/SettingsModal" // Import the SettingsModal component
import { KnowledgeBaseSelector } from "@/components/knowledge/KnowledgeBaseSelector"
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter"
import { oneDark } from "react-syntax-highlighter/dist/cjs/styles/prism"
import { MessageMarkdown } from "@/components/message-markdown"
import { MessageCodeBlock } from "@/components/message-code-block"
import { buildPrompt, DEFAULT_SYSTEM_PROMPT } from "@/lib/prompt-builder"

// Dynamically import Joyride with SSR disabled
const DynamicJoyride = dynamic(() => import("react-joyride"), { ssr: false })

// Define a simpler interface for CodeProps
interface CodeProps {
  node?: any
  inline?: boolean
  className?: string
  children?: React.ReactNode
}

interface Message {
  id: string
  role: "user" | "assistant" | "system"
  content: string
  timestamp: Date
  isTypewriting?: boolean
  user_id?: string // Add user_id to track message sender
  sentfrom?: string // Add sentfrom to store user name directly
}

interface ChatSession {
  id: string
  name: string
  created_at: string
  description?: string
  project_id?: string | null
  last_message_timestamp?: string
  user_id?: string
}

interface Task {
  id: string
  title: string
  description: string
  system_prompt: string
  ai_model: string
  created_at?: string
  updated_at?: string
  user_id?: string
  workspace_id?: string | null
  project_id?: string | null
}

interface Project {
  id: string
  name: string
  description?: string
  user_id: string
  workspace_id?: string | null
  chats?: ChatSession[] // Chats, die zu diesem Projekt gehören
}

// Define structure for info items (used for buttons, tour content can be different)
interface InfoItem {
  title: string
  // We'll define tour steps separately now
}

// Keep infoItems simple for the buttons
const infoItems: InfoItem[] = [
  { title: "Tasks nutzen" },
  { title: "KI-Modell wechseln" },
  { title: "Nachrichten bearbeiten & neu generieren" },
  { title: "Chats verwalten" }
]

const initialMessages: Message[] = []

// Define Tour Steps (Adjust step 3)
const tourSteps: Step[] = [
  {
    target: "#task-select-button",
    content: (
      <>
        <p className="mb-2">
          Mit Tasks können Sie der KI spezifische Anweisungen oder eine
          bestimmte Rolle für den gesamten Chat zuweisen.
        </p>
        <p>
          Klicken Sie hier, um einen vorhandenen Task zu wählen oder einen neuen
          zu erstellen. Tasks überschreiben die manuelle Modellauswahl.
        </p>
      </>
    ),
    placement: "bottom-end",
    title: "Tasks nutzen"
  },
  {
    target: "#model-select-button",
    content: (
      <>
        <p className="mb-2 text-sm">
          Wählen Sie hier das KI-Modell, wenn kein Task aktiv ist:
        </p>
        <ul className="mb-2 ml-4 list-inside list-disc space-y-1 text-sm">
          <li>
            <strong>Basic (GPT-4o):</strong> Ausgewogen.
          </li>
          <li>
            <strong>Fast (GPT-4o mini):</strong> Schnell & Günstig.
          </li>
          <li>
            <strong>Reason (GPT-4 Vision):</strong> Leistungsstark.
          </li>
        </ul>
      </>
    ),
    placement: "bottom-end",
    title: "KI-Modell wechseln"
  },
  {
    target: "#chat-sidebar",
    content:
      "Hier verwalten Sie Ihre Chats: Neuen Chat erstellen (+), Chat auswählen, umbenennen oder löschen (über die drei Punkte).",
    placement: "right",
    title: "Chats verwalten"
  },
  {
    target: "#new-chat-button",
    content: "Klicken Sie hier, um einen neuen, leeren Chat zu beginnen.",
    placement: "left",
    title: "Neuer Chat",
    disableScrolling: true,
    disableOverlayClose: true,
    spotlightPadding: 5
  },
  {
    target: "#chat-input-textarea",
    content:
      "Geben Sie hier Ihre Nachricht ein und drücken Sie Enter oder klicken Sie auf den Senden-Button.",
    placement: "top",
    title: "Nachricht senden"
  }
]

// Helper function to fix the columns handling consistently
const getColumnNames = (columns: any[] | null): string[] => {
  return columns
    ? columns.map((col: { column_name: string }) => col.column_name)
    : []
}

// Detect and format HTML code
const formatCodeInMessage = (content: string): string => {
  // If content already has markdown code blocks, don't modify
  if (content.includes("```")) return content;
  
  // Check if the content appears to be HTML
  if (
    content.trim().startsWith("<") && 
    (content.includes("<!DOCTYPE") || 
     content.includes("<html") ||
     (content.includes("<body") && content.includes("</body>")) ||
     (content.includes("<head") && content.includes("</head>")))
  ) {
    return "```html\n" + content + "\n```";
  }
  
  return content;
};

// This is a standalone component for code blocks

// ---> HILFSFUNKTIONEN für V2 Prompt <--- 
function trimText(txt: string | null | undefined, maxWords = 60): string {
  if (!txt) return "";
  const words = txt.trim().split(/\s+/);
  if (words.length <= maxWords) return txt;
  return words.slice(0, maxWords).join(" ") + " …";
}

// V2 System Prompt Definition - entfernt, da jetzt zentral in prompt-builder.ts definiert
// const systemPrompt = `...`.trim();
// ---> ENDE HILFSFUNKTIONEN für V2 Prompt <--- 

// Add debugging flag at the top of the file, after imports
const DEBUG_MODE = false; // Set to true to enable verbose logging

// Replace console.log with debug-aware logging function
const debugLog = (...args: any[]) => {
  if (DEBUG_MODE) {
    console.log(...args);
  }
};

// Add this custom hook for subscription management
// Place it outside the component, before export default function Chat()
const useSubscriptions = (supabase: any) => {
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const [subscriptionStatus, setSubscriptionStatus] = useState({
    chatsSubscribed: false,
    messagesSubscribed: false
  });

  // Setup chat subscription
  const setupChatSubscription = useCallback((userId: string) => {
    if (!supabase || !userId || chatsChannelRef.current) {
      return;
    }

    const channelId = `chats_updates_global`;
    debugLog(`Setting up realtime subscription for chats table: ${channelId}`);

    const chatsChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chats"
        },
        (payload: any) => {
          debugLog("Realtime chat update received:", payload);
          // Callback to update UI based on the payload would be passed
          // from the component when calling this function
        }
      )
      .subscribe((status: string) => {
        debugLog(`Subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, chatsSubscribed: status === "SUBSCRIBED"}));
      });
    
    chatsChannelRef.current = chatsChannel;
    return chatsChannel;
  }, [supabase]);

  // Setup message subscription
  const setupMessageSubscription = useCallback((chatId: string, userId: string, onMessageReceived: (msg: any) => void) => {
    if (!supabase || !chatId || !userId) {
      return;
    }

    // Cleanup previous subscription if exists
    if (messagesChannelRef.current) {
      debugLog("Cleaning up previous message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    const channelId = `chat_messages_${chatId}`;
    debugLog(`Setting up message subscription for chat: ${chatId}`);

    const messagesChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "chat_messages",
          filter: `chat_id=eq.${chatId}`
        },
        (payload: any) => {
          debugLog(`Realtime message update received for chat ${chatId}:`, payload.eventType);
          
          if (payload.eventType === "INSERT") {
            const newMsg = payload.new;
            // Check if message is from another user
            const msgSentByOtherUser = newMsg.user_id && newMsg.user_id !== userId;
            
            // Only notify if message is from another user or pass to the callback in any case
            onMessageReceived(payload);
          }
        }
      )
      .subscribe((status: string) => {
        debugLog(`Message subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, messagesSubscribed: status === "SUBSCRIBED"}));
      });

    messagesChannelRef.current = messagesChannel;
    return messagesChannel;
  }, [supabase]);

  // Cleanup all subscriptions
  const cleanupSubscriptions = useCallback(() => {
    if (chatsChannelRef.current && supabase) {
      debugLog("Cleaning up chats table subscription");
      supabase.removeChannel(chatsChannelRef.current);
      chatsChannelRef.current = null;
    }

    if (messagesChannelRef.current && supabase) {
      debugLog("Cleaning up message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    setSubscriptionStatus({
      chatsSubscribed: false,
      messagesSubscribed: false
    });
  }, [supabase]);

  return {
    setupChatSubscription,
    setupMessageSubscription,
    cleanupSubscriptions,
    subscriptionStatus
  };
};

export default function Chat() {
  const searchParams = useSearchParams()
  const rawWorkspaceId = searchParams.get("workspace")
  const taskId = searchParams.get("task")

  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [user, setUser] = useState<any>(null)
  const [workspace, setWorkspace] = useState<any>(null)
  const [userFullName, setUserFullName] = useState<string>("Du")
  const [messages, setMessages] = useState<Message[]>(initialMessages)
  const [inputValue, setInputValue] = useState("")
  const [isTyping, setIsTyping] = useState(false)
  const [showIceBreakers, setShowIceBreakers] = useState(false)
  const [showModelDropdown, setShowModelDropdown] = useState(false)
  const [selectedModel, setSelectedModel] = useState("gpt-4o")
  const [chatSessions, setChatSessions] = useState<ChatSession[]>([])
  const [currentChatId, setCurrentChatId] = useState<string | null>(null)
  const [tasks, setTasks] = useState<Task[]>([])
  const [selectedTask, setSelectedTask] = useState<Task | null>(null)
  const [showTaskDropdown, setShowTaskDropdown] = useState(false)
  const [showTaskModal, setShowTaskModal] = useState(false)
  const [newTask, setNewTask] = useState<Task>({
    id: "",
    title: "",
    description: "",
    system_prompt: "",
    ai_model: ""
  })
  const [newTaskName, setNewTaskName] = useState("")
  const [newTaskDescription, setNewTaskDescription] = useState("")
  const [newTaskSystemPrompt, setNewTaskSystemPrompt] = useState("")
  const [newTaskModel, setNewTaskModel] = useState("gpt-4o")
  const [showSidebar, setShowSidebar] = useState(true)
  const [typingMessageId, setTypingMessageId] = useState<string | null>(null)
  const [personalWorkspaceId, setPersonalWorkspaceId] = useState<string | null>(
    null
  )
  const [previousSelectedTask, setPreviousSelectedTask] = useState<Task | null>(
    null
  )
  const [previousSelectedModel, setPreviousSelectedModel] = useState<
    string | null
  >(null)
  const [messageUpdatePending, setMessageUpdatePending] = useState(false)
  const [isTaskSwitching, setIsTaskSwitching] = useState(false)
  const [lastMessageUpdate, setLastMessageUpdate] = useState(Date.now())

  // State für Projekte
  const [projects, setProjects] = useState<Project[]>([])
  const [selectedProject, setSelectedProject] = useState<Project | null>(null)
  const [showProjectDropdown, setShowProjectDropdown] = useState(false)
  const [showProjectModal, setShowProjectModal] = useState(false)
  const [newProjectName, setNewProjectName] = useState("")
  const [newProjectDescription, setNewProjectDescription] = useState("")
  const [projectMenuOpen, setProjectMenuOpen] = useState<string | null>(null)
  const [projectToRename, setProjectToRename] = useState<Project | null>(null)

  // State für Drag & Drop
  const [draggedChatId, setDraggedChatId] = useState<string | null>(null)
  const [activeDropTarget, setActiveDropTarget] = useState<string | null>(null)

  // State für aufgeklappte Projekte
  const [expandedProjects, setExpandedProjects] = useState<
    Record<string, boolean>
  >({})

  // State for editing messages
  const [editingMessageId, setEditingMessageId] = useState<string | null>(null)
  const [editingContent, setEditingContent] = useState("")
  
  // State to store original messages during editing
  const [originalMessages, setOriginalMessages] = useState<Message[]>([])

  // Add searchDebounceTimeout ref
  const searchDebounceTimeout = useRef<any>(null)

  const chatBodyRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLTextAreaElement>(null)
  const modelDropdownRef = useRef<HTMLDivElement>(null)
  const taskDropdownRef = useRef<HTMLDivElement>(null)
  const projectDropdownRef = useRef<HTMLDivElement>(null)

  const supabase = createClientComponentClient()

  // Add state for chat menu and rename functionality
  const [chatMenuOpen, setChatMenuOpen] = useState<string | null>(null)
  const [renameModalOpen, setRenameModalOpen] = useState(false)
  const [chatToRename, setChatToRename] = useState<ChatSession | null>(null)
  const [newChatName, setNewChatName] = useState("")
  // Neuer State für inline edit
  const [editingChatId, setEditingChatId] = useState<string | null>(null)

  const router = useRouter()

  // Add state and refs for the input action menu
  const [showInputMenu, setShowInputMenu] = useState(false)
  const inputMenuRef = useRef<HTMLDivElement>(null)
  const moreOptionsButtonRef = useRef<HTMLButtonElement>(null)

  // Füge einen Ref für die Edit-Box hinzu
  const editBoxRef = useRef<HTMLDivElement>(null)

  // Add state for the new info modal
  // const [showInfoModal, setShowInfoModal] = useState(false)
  // const [modalContent, setModalContent] = useState<InfoItem | null>(null)

  // Add state for React Joyride
  const [runTour, setRunTour] = useState(false)
  const [stepIndex, setStepIndex] = useState(0)

  // State to control showing fake messages during the tour
  const [showFakeMessagesForTour, setShowFakeMessagesForTour] = useState(false)

  // Define fake messages for the tour demonstration
  const fakeTourMessages: Message[] = [
    {
      id: "fake-user-1",
      role: "user",
      content: "Das ist eine Beispiel-Nachricht des Benutzers.",
      timestamp: new Date(Date.now() - 120000) // 2 minutes ago
    },
    {
      id: "fake-ai-message",
      role: "assistant",
      content:
        "Und hier ist eine Beispiel-Antwort der KI. Wenn Sie den Mauszeiger über diese Nachricht bewegen, werden Aktionsbuttons angezeigt.",
      timestamp: new Date(Date.now() - 60000) // 1 minute ago
    }
  ]

  // Add loading state specifically for search
  const [isSearching, setIsSearching] = useState(false)
  // Add chat message search state
  const [searchOpen, setSearchOpen] = useState(false)
  const [messageSearchQuery, setMessageSearchQuery] = useState("")
  const [messageSearchResults, setMessageSearchResults] = useState<any[]>([])

  // New state variables for the export and summary modals
  const [showExportModal, setShowExportModal] = useState(false)
  const [showSummaryModal, setShowSummaryModal] = useState(false)
  const [chatSummary, setChatSummary] = useState("")
  const [isSummarizing, setIsSummarizing] = useState(false)

  // State for showing the message actions dialog
  const [showMessageActionsDialog, setShowMessageActionsDialog] =
    useState(false)
  const [isImprovingPrompt, setIsImprovingPrompt] = useState(false)

  // Add the state for showing settings modal
  const [showSettingsModal, setShowSettingsModal] = useState(false) // Add state for settings modal

  // Add state for storing user names
  const [userNamesMap, setUserNamesMap] = useState<{ [key: string]: string }>(
    {}
  )

  // Neue State-Variable für die ausgewählte Wissensdatenbank
  const [selectedKnowledgeBaseId, setSelectedKnowledgeBaseId] = useState<
    string[] | null
  >(null)

  // Online-Status-State
  const [isOnline, setIsOnline] = useState<boolean>(true); // Standardmäßig annehmen, dass wir online sind

  // Korrekte Typisierung des Refs am Anfang der Komponente
  const initialChatsLoadedRef = useRef(false);
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const isInitializingRef = useRef(false);
  const isStartingNewChatRef = useRef(false);

  // Improved state management for initialization with proper debouncing
  // Add this near the beginning of the component, around line 200-300
  const initializationTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const messageUpdateTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Event-Listener für Online/Offline-Status
  useEffect(() => {
    // Initialen Status setzen
    setIsOnline(navigator.onLine);
    
    // Handler für Online/Offline-Events
    const handleOnline = () => {
      console.log("🟢 Internetverbindung wiederhergestellt");
      setIsOnline(true);
      
      // Optional: Beim Wiederherstellen der Verbindung Daten neu laden
      if (user) {
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        loadChatSessionsMemoized(user.id, workspaceContext);
        loadTasksMemoized(user.id, workspaceContext);
        loadProjectsMemoized(user.id, workspaceContext);
      }
    };
    
    const handleOffline = () => {
      console.log("🔴 Internetverbindung verloren");
      setIsOnline(false);
    };
    
    // Event-Listener hinzufügen
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    // Event-Listener beim Unmount entfernen
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [user, rawWorkspaceId, personalWorkspaceId]);
  
  useEffect(() => {
    if (selectedTask && selectedTask.ai_model) {
      setSelectedModel(selectedTask.ai_model)
    }
  }, [selectedTask])

  // UI-Komponente für Offline-Status 
  const OfflineIndicator = () => {
    if (isOnline) return null;
    
    return (
      <div className="fixed bottom-4 right-4 z-50 rounded-md bg-yellow-600 px-4 py-2 text-white shadow-lg">
        <div className="flex items-center space-x-2">
          <div className="h-2 w-2 rounded-full bg-red-500"></div>
          <span>Offline-Modus - Einige Funktionen sind nicht verfügbar</span>
        </div>
      </div>
    );
  };

  useEffect(() => {
    const fetchPersonalWorkspace = async () => {
      if (user) {
        console.log("Fetching personal workspace for user:", user.id)
        const { data, error } = await supabase
          .from("workspaces")
          .select("id")
          .eq("user_id", user.id)
          .eq("is_home", true)
          .single() // Annahme: Es gibt nur EINEN persönlichen Workspace

        if (error && error.code !== "PGRST116") {
          // Ignore ' esattamente uma linha esperada'
          console.error("Error fetching personal workspace:", error)
        } else if (data) {
          console.log("Personal workspace found:", data.id)
          setPersonalWorkspaceId(data.id)
        } else {
          console.warn("Personal workspace not found for user:", user.id)
          // Hier könnte man optional den Workspace erstellen, falls er fehlt
          // oder eine Fehlermeldung anzeigen.
        }
      }
    }
    if (user && !rawWorkspaceId) {
      // Nur laden, wenn kein Workspace in URL und User bekannt
      fetchPersonalWorkspace()
    }
  }, [user, supabase, rawWorkspaceId]) // Abhängigkeiten

  // Optimierte Kontextauswahl mit Caching, besserer Priorisierung und Ausschluss aktueller Nachrichten
  // Cache für Chat-Sessions um redundante Ladevorgänge zu vermeiden
  const chatSessionsCache: {
    sessions: any[] | null
    timestamp: number
    maxAge: number
  } = {
    sessions: null,
    timestamp: 0,
    maxAge: 5000 // Cache ist für 5 Sekunden gültig
  }

  // Cache für Projektberechnungen
  const projectsCache: {
    projectChats: Map<string, any[]> | null
    timestamp: number
    maxAge: number
  } = {
    projectChats: null,
    timestamp: 0,
    maxAge: 10000 // Cache ist für 10 Sekunden gültig
  }

  // Optimierte Funktion zum Laden von Chat-Sessions mit Caching
  const loadChatSessionsWithCache = async (
    userId: string,
    workspaceId: string | null
  ) => {
    const now = Date.now()

    // Prüfen, ob der Cache gültig ist
    if (
      chatSessionsCache.sessions &&
      now - chatSessionsCache.timestamp < chatSessionsCache.maxAge
    ) {
      console.log("📦 Verwende gecachte Chat-Sessions")
      return chatSessionsCache.sessions
    }

    console.log(
      `🔄 Loading chat sessions - userId: ${userId} workspaceId: ${workspaceId}`
    )

    // Lade Daten wie zuvor
    const { data, error } = await supabase
      .from("chats")
      .select("*")
      .eq("user_id", userId)
      .eq("workspace_id", workspaceId)
      .order("updated_at", { ascending: false })

    if (error) {
      console.error("❌ Fehler beim Laden der Chat-Sessions:", error)
      return []
    }

    console.log(`✅ Loaded ${data.length} chat sessions`)

    // Verarbeite Daten und speichere sie im Cache
    const formattedSessions = data.map((chat: any) => ({
      id: chat.id,
      name: chat.name || "Neuer Chat",
      timestamp: chat.updated_at,
      message_count: chat.message_count || 0,
      project: chat.project || null,
      temperature: chat.temperature,
      model: chat.model || null
    }))

    // Cache aktualisieren
    chatSessionsCache.sessions = formattedSessions
    chatSessionsCache.timestamp = now

    return formattedSessions
  }

  // Optimierte Funktion zur Projektberechnung mit Caching
  const recalculateProjectsWithCache = (chats: any[]) => {
    const now = Date.now()

    // Prüfen, ob der Cache gültig ist
    if (
      projectsCache.projectChats &&
      now - projectsCache.timestamp < projectsCache.maxAge
    ) {
      return projectsCache.projectChats
    }

    console.log(
      `🔢 Berechne Projekte neu aus ${chats.length} verfügbaren Chats`
    )

    const projectChats = new Map()

    // Projekte berechnen wie zuvor
    const availableProjects = [
      ...new Set(chats.filter(c => c.project).map(c => c.project))
    ]

    availableProjects.forEach(project => {
      const chatsInProject = chats.filter(c => c.project === project)
      projectChats.set(project, chatsInProject)
      console.log(`🗂️ Projekt ${project} hat ${chatsInProject.length} Chats`)
    })

    // Cache aktualisieren
    projectsCache.projectChats = projectChats
    projectsCache.timestamp = now

    return projectChats
  }

  // Hauptfunktion für die Kontext-Suche, verbessert mit Ausschluss der aktuellen Nachricht
  const findSimilarMessagesOptimized = async (
    userId: string,
    query: string,
    currentMessageId: string | null = null
  ) => {
    debugLog(`🔍 Suche nach ähnlichen Nachrichten für User ${userId}`);
    debugLog(`📝 Suchanfrage: "${query}"`);

    // Skip search for very short queries to reduce database load
    if (query.trim().length < 3) {
      debugLog("⏩ Überspringe Suche für zu kurze Anfrage (weniger als 3 Zeichen)");
      return [];
    }

    // Validiere userId
    if (!userId || typeof userId !== "string" || userId.trim() === "") {
      console.error("❌ Ungültige userId für die Suche:", userId);
      return [];
    }

    try {
      // Erstelle ein temporäres Nachrichtenobjekt für das Embedding
      const tempQueryMessage = {
        content: query,
        id: "query", // Diese ID wird nicht in der DB gespeichert
        role: "user" as "user", // Explizit typisieren
        timestamp: new Date()
      };

      // Erstelle Embedding für die Anfrage
      debugLog(`🧠 Generiere Embedding für Suchanfrage...`);

      try {
        // Direkter Aufruf der Embedding-API als temporärer Ersatz für createEmbedding
        debugLog("📨 Original Nachrichteninhalt:", tempQueryMessage.content);
        const currentDate = new Date().toISOString().split("T")[0];
        const contentWithDate = `[Datum: ${currentDate}]\n${tempQueryMessage.content}`;
        
        const response = await fetch("/api/embeddings", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            input: contentWithDate
          })
        });
        
        if (!response.ok) {
          throw new Error(`Embedding API responded with ${response.status}`);
        }
        
        const embeddingData = await response.json();
        const embedding = embeddingData.embedding;

        if (!embedding) {
          console.error("❌ Fehler beim Generieren des Embeddings für die Suche");
          return [];
        }

        debugLog(`✅ Embedding für Abfrage erfolgreich generiert`);
        debugLog(`📊 Query-Embedding-Dimensionen: ${embedding.length}`);
        
        // Adjust similarity threshold based on query length
        const dynamicThreshold = query.length < 10 ? 0.75 : 0.65;
        const maxResults = query.length < 10 ? 10 : 20;
        
        debugLog(
          `📞 Rufe search_similar_messages RPC für User ${userId} auf (Schwellwert: ${dynamicThreshold}, Max Ergebnisse: ${maxResults})`
        );

        // RPC für die Ähnlichkeitssuche aufrufen
        const { data: results, error } = await supabase.rpc(
          "search_similar_messages",
          {
            p_user_id: userId,
            query_embedding: embedding,
            similarity_threshold: dynamicThreshold, // Use dynamic threshold
            max_results: maxResults
          }
        );

        if (error) {
          console.error("❌ Fehler bei der RPC-Suche nach ähnlichen Nachrichten:", error);
          return [];
        }

        debugLog(`🔎 RPC Ergebnis: ${results?.length || 0} Nachrichten gefunden`);
        
        if (!results || results.length === 0) {
          return [];
        }
        
        if (DEBUG_MODE) {
          debugLog(`📋 Erste Ergebnisse (Rohdaten): ${JSON.stringify(results?.slice(0, 2) || [])}`);
        }

        // Filtere die aktuelle Nachricht, falls vorhanden
        let filteredResults = results || [];
        if (currentMessageId) {
          const originalLength = filteredResults.length;
          filteredResults = filteredResults.filter(
            (msg: any) => msg.message_id !== currentMessageId
          );
          if (originalLength !== filteredResults.length) {
            debugLog(`🧹 Aktuelle Nachricht mit ID ${currentMessageId} aus Ergebnissen ausgeschlossen`);
          }
        }

        // Schnellere Verarbeitung der Datumsangaben ohne übermäßiges Logging
        for (const msg of filteredResults) {
          // Generiere eine anzeigbare Version des Inhalts ohne Datum
          msg.displayContent = msg.content;
          if (msg.content && typeof msg.content === 'string' && msg.content.startsWith('[Datum:') && msg.content.includes(']\n')) {
            msg.displayContent = msg.content.replace(/^\[Datum:[^\]]+\]\n/, '');
          }
          
          // Extrahiere Datum aus dem Nachrichteninhalt, aber logge nicht jede Nachricht
          const dateMatch = msg.content?.match(/\[Datum: ([^\]]+)\]/);
          msg.dateInfo = dateMatch ? dateMatch[1] : null;
        }

        debugLog(`✅ ${filteredResults.length} ähnliche Nachrichten nach Filterung gefunden`);

        return filteredResults;
      } catch (error) {
        console.error("❌ Fehler beim Erstellen des Embeddings:", error);
        return [];
      }
    } catch (error) {
      console.error("❌ Fehler bei der Suche nach ähnlichen Nachrichten:", error);
      return [];
    }
  };

  // Verbesserte Kontext-Auswahlfunktion mit optimierter Bewertung für neueste/älteste Nachrichten
  const prepareContextMessage = (contextContent: string) => {
    return {
      role: "system",
      content: `Relevanter Kontext aus früheren Gesprächen:\n\n${contextContent}\n\nDies sind Ausschnitte aus vorherigen Konversationen, die für die aktuelle Frage relevant sein könnten. Die mit "neueste Information" markierten Abschnitte enthalten den aktuellsten Stand zu diesem Thema, während "erste Erwähnung" historischen Kontext bietet. Nutze diese Informationen, um eine informierte Antwort zu geben, besonders wenn der Benutzer sich auf bereits besprochene Themen bezieht.`
    }
  }

  const loadChatSessions = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      console.log(
        "🔄 Loading chat sessions - userId:",
        userId,
        "workspaceId:",
        workspaceId
      )

      // Verwende personalWorkspaceId als Fallback, wenn keine workspaceId übergeben wird
      const targetWorkspaceId = workspaceId || personalWorkspaceId

      // Build the query
      let query = supabase
        .from("chats")
        .select(
          "id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id"
        )

      // Properly handle null workspace IDs
      if (targetWorkspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Chats in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq("workspace_id", targetWorkspaceId)
      } else {
        // Nur im persönlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is("workspace_id", null).eq("user_id", userId)
      }

      const { data, error } = await query.order("last_message_timestamp", {
        ascending: false
      })

      if (error) {
        console.error("❌ Error loading chat sessions:", error)
        setError(`Fehler beim Laden der Chats: ${error.message}`)
        throw error
      }

      if (data) {
        console.log("✅ Loaded", data.length, "chat sessions")
        console.log("Chat data:", data) // Debug: Zeige die Chat-Daten

        const formattedSessions = data.map((chat: any) => ({
          id: chat.id || "",
          name: chat.name || "Unnamed Chat",
          created_at: chat.created_at || new Date().toISOString(),
          last_message_timestamp: chat.last_message_timestamp,
          user_id: chat.user_id, // Behalte user_id um den Ersteller anzuzeigen
          ...(chat.description && { description: chat.description }),
          project_id: chat.project_id
        }))

        console.log("Formatted sessions:", formattedSessions) // Debug: Zeige die formatierten Sessions
        setChatSessions(formattedSessions)
      } else {
        console.log("ℹ️ No chat sessions found")
        setChatSessions([])
      }
    } catch (err) {
      console.error("❌ Error in loadChatSessions:", err)
      setChatSessions([])
    }
  }

  const createNewChat = async () => {
    try {
      if (!user) {
        setError("Sie müssen angemeldet sein, um einen Chat zu erstellen.")
        return null
      }

      // Determine the workspace ID to use - simplify this logic
      const workspaceId = rawWorkspaceId || personalWorkspaceId

      if (!workspaceId) {
        setError(
          "Konnte keinen gültigen Arbeitsbereich zum Erstellen des Chats finden."
        )
        return null
      }

      console.log(`Creating new chat in workspace: ${workspaceId}`)

      // Create a new chat with a temporary name - we'll update it later
      const newChatId = uuidv4()
      const initialTitle = "Neuer Chat"

      // Create with retry to ensure it succeeds
      const { data: newChat, error } = await supabase
        .from("chats")
        .insert({
          id: newChatId,
          user_id: user.id,
          name: initialTitle,
          workspace_id: workspaceId,
          created_at: new Date().toISOString(),
          last_message_timestamp: new Date().toISOString()
        })
        .select()
        .single()

      if (error) {
        console.error(`❌ Error creating new chat: ${error.message}`)
        setError(`Fehler beim Erstellen des Chats: ${error.message}`)
        return null
      }

      if (!newChat) {
        console.error("❌ No chat data returned after creation")
        setError("Fehler beim Erstellen des Chats: Keine Daten zurückgegeben")
        return null
      }

      console.log(`✅ Successfully created new chat with ID: ${newChatId}`)

      // Set the current chat ID immediately
      setCurrentChatId(newChatId)

      // Wait for the database to properly register the new chat
      await new Promise(resolve => setTimeout(resolve, 300))

      // Reload chat sessions to update UI
      if (user) {
        await loadChatSessions(user.id, workspaceId)
      }

      return newChatId
    } catch (err) {
      console.error("Error in createNewChat:", err)
      setError(
        `Fehler beim Erstellen des Chats: ${err instanceof Error ? err.message : "Unbekannter Fehler"}`
      )
      return null
    }
  }

  const loadChat = async (chatId: string) => {
    try {
      setCurrentChatId(chatId)

      // Try to get chat details first to confirm it exists
      const { data: chatData, error: chatError } = await supabase
        .from("chats")
        .select("id, name")
        .eq("id", chatId)
        .single()

      if (chatError) {
        console.error("Error fetching chat details:", chatError)
        return
      }

      // Get chat messages - now only using chat_id
      const { data: messagesData, error: messagesError } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (messagesError) {
        console.error("Error fetching chat messages:", messagesError)
        setMessages([])
        return
      }

      if (messagesData && messagesData.length > 0) {
        // Transform to our Message format
        const transformedMessages = messagesData.map((msg: any) => ({
          id: uuidv4(),
          role: msg.role as "user" | "assistant" | "system",
          content: msg.content,
          timestamp: new Date(msg.created_at),
          user_id: msg.user_id, // Store user_id from database
          sentfrom: msg.sentfrom // Store sentfrom from database
        }))

        setMessages(transformedMessages)
        console.log(
          `Loaded ${transformedMessages.length} messages for chat ${chatId}`
        )

        // Fetch usernames for all unique user_ids in messages
        const userIds = [
          ...new Set(
            transformedMessages
              .filter(msg => msg.role === "user" && msg.user_id)
              .map(msg => msg.user_id)
          )
        ]

        if (userIds.length > 0) {
          const { data: profilesData, error: profilesError } = await supabase
            .from("profiles")
            .select("id, full_name")
            .in("id", userIds)

          if (profilesError) {
            console.error("Error fetching user profiles:", profilesError)
          } else if (profilesData) {
            // Create a map of user_id to full_name
            const userNames: { [key: string]: string } = {}
            profilesData.forEach(profile => {
              userNames[profile.id] = profile.full_name
            })
            setUserNamesMap(userNames)
          }
        }
      } else {
        console.log(`No messages found for chat ${chatId}`)
        setMessages([])
      }
    } catch (err) {
      console.error("Error loading chat:", err)
      setMessages([])
    }
  }

  const loadTasks = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status prüfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - Überspringe Laden der Tasks");
        return; // Früher Abbruch bei fehlender Internetverbindung
      }

      // Timeout für die Anfrage setzen, um lange hängende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("tasks").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Tasks in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im persönlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufräumen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedTasks = data.map(task => ({
            ...task,
            title: task.title || task.name,
            ai_model: task.ai_model || task.preferred_model || "gpt-4o"
          }));
          setTasks(formattedTasks);
        }
      } catch (fetchError: any) {
        // Timeout aufräumen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Prüfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Task-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Tasks - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading tasks:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu überfluten
      // Wenn die Seite neu geladen wird, wird ein neuer Versuch unternommen
    }
  };

  const loadProjects = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status prüfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - Überspringe Laden der Projekte");
        return; // Früher Abbruch bei fehlender Internetverbindung
      }

      // Timeout für die Anfrage setzen, um lange hängende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("projects").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Projekte in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im persönlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufräumen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedProjects = data.map(project => ({
            ...project,
            name: project.name || project.title,
            workspace_id:
              project.workspace_id || project.preferred_workspace_id || "gpt-4o"
          }));
          setProjects(formattedProjects);
        }
      } catch (fetchError: any) {
        // Timeout aufräumen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Prüfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Project-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Projekte - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading projects:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu überfluten
    }
  };

  // Wenn ein user (per Link Sharing) einen spezifischen Chat betritt, dann direkt laden
  useEffect(() => {
    // Lade alle verfügbaren Tasks als Optionen
    if (user) {
      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
      loadTasks(user.id, workspaceContext)
    }

    // Wenn eine Task-ID in der URL ist, lade diese Task
    if (taskId) {
      console.log("Task ID in URL gefunden:", taskId)
      const fetchTask = async () => {
        if (!supabase) return

        const { data, error } = await supabase
          .from("tasks")
          .select("*")
          .eq("id", taskId)
          .single()

        if (error) {
          console.error("Fehler beim Laden der Task:", error)
          return
        }

        if (data) {
          console.log("Task geladen:", data)
          setSelectedTask(data)
          setSelectedModel(data.ai_model || "gpt-4o")
        }
      }

      fetchTask()
    }
  }, [user, taskId, supabase, rawWorkspaceId, personalWorkspaceId, loadTasks])

  // Effect für die Textareabehandlung
  useEffect(() => {
    const textarea = inputRef.current
    if (textarea) {
      // Reset height - wichtig, um zu verhindern, dass es nur nach oben wächst
      textarea.style.height = "auto"
      // Setze die neue Höhe basierend auf dem Scroll-Höhen-Wert
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`
    }
  }, [inputValue])

  // Reduziere unnötige Re-Renders durch Memoization der Lade-Funktionen
  const loadChatSessionsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadChatSessions(userId, workspaceId);
    },
    [supabase, setChatSessions]
  );
  
  const loadChatMemoized = useCallback(
    async (chatId: string) => {
      return await loadChat(chatId);
    },
    [supabase, user, setMessages, setUserNamesMap]
  );
  
  const loadTasksMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadTasks(userId, workspaceId);
    },
    [supabase, setTasks]
  );
  
  const loadProjectsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadProjects(userId, workspaceId);
    },
    [supabase, setProjects]
  );

  // Haupt-Initialisierungscode für den Chat
  useEffect(() => {
    // Zeitsperre, um zu häufige Aufrufe zu verhindern
    const checkSession = async () => {
      // Vermeide mehrfache gleichzeitige Initialisierungen
      if (isInitializingRef.current) {
        debugLog("Initialization already in progress, skipping");
        return;
      }
      
      isInitializingRef.current = true;
      try {
        setLoading(true);

        // Prüfe, ob der Benutzer angemeldet ist
        const {
          data: { session }
        } = await supabase.auth.getSession();

        if (!session) {
          console.log("No session found, redirecting to login");
          router.push("/login");
          return;
        }

        // Benutzer ist angemeldet
        setUser(session.user);

        // Profilnamen laden (nicht kritisch für Initialisierung)
        if (!userFullName || userFullName === "Du") {
          try {
            const { data: profileData } = await supabase
              .from("profiles")
              .select("full_name")
              .eq("id", session.user.id)
              .single();

            if (profileData?.full_name) {
              setUserFullName(profileData.full_name);
            }
          } catch (profileError) {
            console.error("Error loading user profile:", profileError);
          }
        }

        debugLog(`*** Session exists, user: ${session.user.id}`);

        // Workspace-Kontext bestimmen
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        debugLog("Current workspace context:", workspaceContext);

        // Chats nur laden, wenn nötig
        if (workspaceContext && !initialChatsLoadedRef.current && chatSessions.length === 0) {
          debugLog("Loading chat sessions for the first time");
          // Use Promise.all to load data in parallel
          await Promise.all([
            loadChatSessionsMemoized(session.user.id, workspaceContext),
            loadProjectsMemoized(session.user.id, workspaceContext)
          ]);
          initialChatsLoadedRef.current = true;
        }

        // Wenn ein Chat bereits in state ist, lade ihn
        if (currentChatId) {
          debugLog("Chat ID in state bereits vorhanden:", currentChatId);
          await loadChatMemoized(currentChatId);
        } else if (chatSessions.length > 0 && !messages.length && !isStartingNewChatRef.current) {
          // Sonst lade den ersten Chat, aber nur wenn:
          // - keine Nachrichten bereits geladen sind 
          // - UND kein expliziter Neustart eines Chats angefordert wurde
          debugLog("Lade den ersten Chat aus vorhandenen Sessions:", chatSessions[0].id);
          setCurrentChatId(chatSessions[0].id);
          await loadChatMemoized(chatSessions[0].id);
        } else if (isStartingNewChatRef.current) {
          debugLog("Neuer Chat wurde explizit angefordert - lade keinen vorhandenen Chat");
          // Flag zurücksetzen nach Verwendung
          isStartingNewChatRef.current = false;
        }

        // Tasks laden (wenn noch nicht geladen)
        if (tasks.length === 0 && workspaceContext) {
          await loadTasksMemoized(session.user.id, workspaceContext);
        }

        // Icebreakers zeigen, wenn keine Nachrichten vorhanden
        if (messages.length === 0) {
          setShowIceBreakers(true);
        }

        // Task laden, wenn eine ID übergeben wurde
        if (taskId && (!selectedTask || selectedTask.id !== taskId)) {
          const { data: taskData, error } = await supabase
            .from("tasks")
            .select("*")
            .eq("id", taskId)
            .single();

          if (!error && taskData) {
            debugLog("Task geladen:", taskData);
            setSelectedTask(taskData);
            setSelectedModel(taskData.ai_model || selectedModel);
          }
        }
      } catch (err: any) {
        console.error("Chat init error:", err);
        setError(err.message);
      } finally {
        setLoading(false);
        
        // Use setTimeout to avoid race conditions when setting isInitializingRef
        if (initializationTimeoutRef.current) {
          clearTimeout(initializationTimeoutRef.current);
        }
        
        initializationTimeoutRef.current = setTimeout(() => {
          isInitializingRef.current = false;
          debugLog("Initialization flag reset to false");
          initializationTimeoutRef.current = null;
        }, 100);
      }
    };

    checkSession();
    
    // Cleanup function
    return () => {
      if (initializationTimeoutRef.current) {
        clearTimeout(initializationTimeoutRef.current);
      }
      if (messageUpdateTimeoutRef.current) {
        clearTimeout(messageUpdateTimeoutRef.current);
      }
    };
  }, [
    supabase,
    currentChatId,
    personalWorkspaceId,
    rawWorkspaceId,
    router,
    taskId
  ]);

  /* eslint-disable react-hooks/rules-of-hooks */
  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        modelDropdownRef.current &&
        !modelDropdownRef.current.contains(event.target as Node)
      ) {
        setShowModelDropdown(false)
      }

      if (
        taskDropdownRef.current &&
        !taskDropdownRef.current.contains(event.target as Node)
      ) {
        setShowTaskDropdown(false)
      }

      // Schließe Chat-Menü bei Klick außerhalb
      const chatMenuTarget = (event.target as Element)?.closest(
        "[data-chat-menu]"
      )
      if (chatMenuOpen && !chatMenuTarget) {
        setChatMenuOpen(null)
      }

      // Schließe Projekt-Menü bei Klick außerhalb
      const projectMenuTarget = (event.target as Element)?.closest(
        "[data-project-menu]"
      )
      if (projectMenuOpen && !projectMenuTarget) {
        setProjectMenuOpen(null)
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [chatMenuOpen, projectMenuOpen])

  // Haupt-Funktion zum Senden einer Nachricht an die API
  const sendMessageToAPI = async (
    messages: Message[],
    model: string,
    chatId: string
  ) => {
    console.log(`🔄 sendMessageToAPI v2 aufgerufen mit Chat-ID: ${chatId}`);

    const userId = user?.id;
    if (!userId) {
      console.error("❌ User ID fehlt beim Senden an API.");
      throw new Error("User ID ist erforderlich");
    }

    // 1. DATEN SAMMELN (wie bisher)
    // --------------------------------
    console.log(`👤 Hole Benutzerprofil für User ID: ${userId}`);
    const { data: fetchedUserProfile, error: profileError } = await supabase
        .from("profiles")
        .select("*")
      .eq("id", userId)
      .single();
      
    // Use fetchedUserProfile instead of the state variable userProfile directly here
    // to ensure we have the latest data for this specific call.
    if (profileError) console.error("Fehler beim Abrufen des Profils:", profileError);
    else console.log("✅ Benutzerprofil erfolgreich abgerufen");

    const lastUserMessage = [...messages].reverse().find(m => m.role === "user");
    let knowledgeResults: any[] = [];
    let similarMessages: any[] = []; // Assuming this holds structured QA or relevant snippets
    // (SelectedTask comes from component state)
    const currentSelectedTask = selectedTask; // Capture state at the time of call

    if (lastUserMessage) {
        const userQuery = lastUserMessage.content;
        
        // Wissensdatenbank-Suche (falls KB ausgewählt)
        if (selectedKnowledgeBaseId && selectedKnowledgeBaseId.length > 0) { 
            try {
                console.log(`🧠 Performing knowledge base search for KBs: ${selectedKnowledgeBaseId.join(', ')}...`);
                const { data: authData } = await supabase.auth.getSession();
                const authToken = authData?.session?.access_token;

                // Alle Ergebnisse aus allen ausgewählten Wissensdatenbanken sammeln
                let allKnowledgeResults: any[] = [];
                
                // Sequentiell durch alle ausgewählten Wissensdatenbanken gehen
                for (const kbId of selectedKnowledgeBaseId) {
                    const knowledgeResponse = await fetch("/api/knowledge/search", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            query: userQuery,
                            knowledge_base_id: kbId,
                            auth_token: authToken
                        })
                    });
                    
                    if (knowledgeResponse.ok) {
                        const knowledgeData = await knowledgeResponse.json();
                        const results = knowledgeData.results || [];
                        console.log(`🧠 Found ${results.length} raw knowledge items from KB ${kbId}.`);
                        allKnowledgeResults.push(...results);
                    } else {
                        console.error(`⚠️ Knowledge base search failed for KB ${kbId}:`, knowledgeResponse.statusText);
                    }
                }
                
                // Sortiere alle Ergebnisse nach Relevanz (falls ein similarity-Feld existiert)
                knowledgeResults = allKnowledgeResults.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));
                console.log(`🧠 Combined ${knowledgeResults.length} total knowledge items from all KBs.`);
          
            } catch (knowledgeError) {
                console.error("❌ Error during knowledge base search fetch:", knowledgeError);
            }
        } else {
            console.log("ℹ️ Keine Wissensdatenbank ausgewählt, überspringe Suche.");
        }
        
        // Suche nach ähnlichen Nachrichten (wie bisher)
        try {
            console.log(`🔍 Suche nach User-weiten Kontext für User ${userId}, basierend auf: ${userQuery.substring(0, 30)}...`);
            // Assuming findSimilarMessagesOptimized returns the structured data needed
            similarMessages = await findSimilarMessagesOptimized(userId, userQuery, lastUserMessage.id) || [];
            console.log(`✅ ${similarMessages.length} ähnliche Nachrichten gefunden`);
             // Log details of similar messages structure if needed for debugging
             // console.log("Similar messages structure:", JSON.stringify(similarMessages.slice(0,2), null, 2));
        } catch (error) {
            console.error("❌ Fehler bei der Suche nach ähnlichen Nachrichten:", error);
        }

    } else {
      console.warn("Keine letzte Benutzernachricht gefunden, kann keinen Kontext generieren.");
      // Handle case where there's somehow no user message? Maybe return early or send without context.
    }
    
    // KONSOLIDIERTE PROMPT-ERSTELLUNG MIT DEM NEUEN PROMPT-BUILDER
    // -------------------------------------------
    const userInput = lastUserMessage ? lastUserMessage.content : "";
    
    // Verwende den neuen buildPrompt statt manueller Zusammensetzung
    const finalPrompt = buildPrompt({
      userInput,
      chatId,
      taskPrompt: currentSelectedTask?.system_prompt || null,
      // Verwende den aus prompt-builder.ts importierten DEFAULT_SYSTEM_PROMPT 
      // Das systemPrompt muss hier nicht explizit übergeben werden, da es den DEFAULT_SYSTEM_PROMPT nutzt
      userProfile: fetchedUserProfile,
      knowledgeResults,
      pastMessages: similarMessages,
      allMessages: messages,
      modelType: "default", // Standard-Chat
      maxPastMessages: 4,
      maxKnowledgeResults: 3
    });
    
    console.log(`📩 Sende an API: ${messages.filter(m => m.role !== 'system').length} User/Assistant Nachrichten, ${finalPrompt.length - messages.filter(m => m.role !== 'system').length} System/Assistant Kontextobjekt(e)`);
    console.log("Final apiMessages array (V2) before API call:", JSON.stringify(finalPrompt, null, 2));
    
    // API CALL MIT STREAMING
    // --------------------------------------------------
    try {
        const apiUrl = `/api/chat?model=${encodeURIComponent(model)}&chatId=${encodeURIComponent(chatId)}`;
        
        // Streaming aktivieren
        const streaming = true;
        
        if (streaming) {
          // Streaming Anfrage mit benutzerdefinierten Parametern
          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              messages: finalPrompt,
              streaming: true
            })
          });
          
          if (!response.ok) {
            const errorBody = await response.text();
            console.error("API Error Response Body:", errorBody);
            throw new Error(`API responded with ${response.status}`);
          }

          // Stream verarbeiten
          const reader = response.body?.getReader();
          if (!reader) throw new Error("Stream reader not available");
          
          const decoder = new TextDecoder();
          let fullContent = "";
          let metaInfo = null;
          
          // Event-basierter Streaming-Modus (gibt Text-Chunks zurück während sie ankommen)
          return {
            content: "", // Wird unten schrittweise gefüllt
            streamContent: async function* () {
              let buffer = ""; // Puffer für eingehende Chunks
              const decoder = new TextDecoder();
              let accumulatedJsonRemainder = ""; // Buffer for incomplete JSON chunks

              try {
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) {
                    // Yield any remaining buffer content when the stream ends
                    if (buffer.length > 0) {
                      yield buffer;
                      // fullContent is already updated progressively
                    }
                     // Yield any remaining JSON remainder if it's valid text
                    if (accumulatedJsonRemainder.length > 0 && !accumulatedJsonRemainder.startsWith('{')) {
                       yield accumulatedJsonRemainder;
                    }
                    break;
                  }

                  const rawChunk = decoder.decode(value, { stream: true });
                  accumulatedJsonRemainder += rawChunk;

                  let textToProcess = "";
                  let processFromIndex = 0;

                  // Attempt to parse JSON if it looks like it might be JSON
                  if (accumulatedJsonRemainder.includes('{') && accumulatedJsonRemainder.includes('}')) {
                      try {
                          // Find potential JSON boundary more robustly
                          let potentialJsonEnd = accumulatedJsonRemainder.lastIndexOf('}') + 1;
                          let potentialJson = accumulatedJsonRemainder.substring(0, potentialJsonEnd);
                          
                          // Basic check if it looks like a valid JSON object
                          if (potentialJson.startsWith('{')) {
                              const parsed = JSON.parse(potentialJson);
                              if (parsed && typeof parsed.content === 'string') {
                                  textToProcess = parsed.content;
                                  // Update fullContent only with the actual text part
                                  fullContent += textToProcess;
                                  // Remove the processed JSON part from the remainder
                                  accumulatedJsonRemainder = accumulatedJsonRemainder.substring(potentialJsonEnd);
                                  processFromIndex = 0; // Start processing the new text from beginning
                              } else {
                                 // Valid JSON but not the expected format, treat accumulated as text
                                 textToProcess = accumulatedJsonRemainder;
                                 fullContent += textToProcess; // Add raw chunk to fullContent
                                 accumulatedJsonRemainder = ""; // Clear remainder
                      }
    } else {
                             // Doesn't start with '{', treat as raw text
                             textToProcess = accumulatedJsonRemainder;
                             fullContent += textToProcess; // Add raw chunk to fullContent
                             accumulatedJsonRemainder = ""; // Clear remainder
                        }
                      } catch (e) {
                          // Invalid JSON or incomplete chunk, wait for more data or treat as text if stream ends
                          // Continue accumulating, do not process buffer yet unless it's very long
                          if (accumulatedJsonRemainder.length > 1000) { // Process as text if buffer gets too long
                               textToProcess = accumulatedJsonRemainder;
                               fullContent += textToProcess; // Add raw chunk to fullContent
                               accumulatedJsonRemainder = ""; // Clear remainder
                      }
                    }
    } else {
                     // Does not contain braces, likely raw text
                     textToProcess = accumulatedJsonRemainder;
                     fullContent += textToProcess; // Add raw chunk to fullContent
                     accumulatedJsonRemainder = ""; // Clear remainder
                  }
                  
                  // If we extracted text (either from JSON or raw chunk), add to buffer and yield words
                  if (textToProcess) {
                    buffer += textToProcess;

                    // Process the buffer to yield whole words/segments
                    let lastDelimiterPos = -1;
                    const lastSpacePos = buffer.lastIndexOf(' ');
                    const lastNewlinePos = buffer.lastIndexOf('\\n');
                    lastDelimiterPos = Math.max(lastSpacePos, lastNewlinePos);

                    if (lastDelimiterPos !== -1) {
                      const partToYield = buffer.substring(0, lastDelimiterPos + 1);
                      if (partToYield.length > 0) {
                           yield partToYield;
                      }
                      buffer = buffer.substring(lastDelimiterPos + 1);
                    }
                  }
                }
              } catch (error) {
                console.error("Error reading stream:", error);
                if (buffer.length > 0) yield buffer;
                if (accumulatedJsonRemainder.length > 0) yield accumulatedJsonRemainder;
                throw error;
              } finally {
                this.content = fullContent;
              }
            },
            getContent: () => fullContent,
            model: model
          };
        } else {
          // Nicht-Streaming-Modus (für Fallback)
      const apiResponse = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
              messages: finalPrompt
        })
        });

      if (!apiResponse.ok) {
            // Log response body if available
            const errorBody = await apiResponse.text();
            console.error("API Error Response Body:", errorBody);
            throw new Error(`API responded with ${apiResponse.status}`);
        }

        const data = await apiResponse.json();
        return data; // Rückgabe an den Aufrufer (handleSendMessage)
        }
    } catch (error) {
        console.error("❌ Fehler beim API-Aufruf in sendMessageToAPI:", error);
        throw error; // Fehler weitergeben, damit handleSendMessage ihn fangen kann
    }
  }  // Ende von sendMessageToAPI

  const handleTypewriterComplete = (messageId: string) => {
    const updatedMessages = messages.map(m =>
      m.id === messageId ? { ...m, isTypewriting: false } : m
    )
    setMessages(updatedMessages)
    setTypingMessageId(null)
  }

  const handleCreateTask = async () => {
    if (!newTaskName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || null

      const { data, error } = await supabase
        .from("tasks")
        .insert({
          title: newTaskName,
          description: newTaskDescription,
          system_prompt: newTaskSystemPrompt,
          ai_model: newTaskModel,
          status: "todo",
          priority: "medium",
          user_id: user.id,
          workspace_id: workspaceContext
        })
        .select()

      if (error) throw error

      await loadTasks(user.id, workspaceContext)

      setShowTaskModal(false)
      setNewTaskName("")
      setNewTaskDescription("")
      setNewTaskSystemPrompt("")
      setNewTaskModel("gpt-4o")
    } catch (err) {
      console.error("Error creating task:", err)
    } finally {
      setLoading(false)
    }
  }

  const handleCreateProject = async () => {
    if (!newProjectName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null

      // ---> START DEBUG LOG <---
      console.log("--- Creating Project --- ")
      console.log("User ID to send:", user?.id)
      console.log("Raw Workspace ID from URL:", rawWorkspaceId)
      console.log("Personal Workspace ID state:", personalWorkspaceId)
      console.log("Workspace Context to send:", workspaceContext)
      // ---> END DEBUG LOG <---

      // ---> ADDED AUTH CHECK <---
      const { data: authData, error: authError } =
        await supabase.auth.getSession()
      console.log("--- Auth Check Before Insert ---")
      console.log("Current Session:", authData?.session)
      console.log("Session User ID:", authData?.session?.user?.id)
      console.log("Auth Error:", authError)
      if (authError || !authData?.session) {
        console.error("CRITICAL: No valid session before insert!")
        // Optionally: Prevent the insert or show an error to the user
        // return;
      }
      // ---> END AUTH CHECK <---

      // ---> ADDED DIAGNOSTIC FUNCTION <---
      // This immediately runs when you click "Create Project" in the UI
      // It helps diagnose why the workspace membership check fails
      console.log("--- Running Diagnostic Function ---")
      const diagResult = await supabase.rpc("diagnose_workspace_membership", {
        p_user_id: user.id,
        p_workspace_id: workspaceContext
      })
      console.log("Diagnosis Result:", diagResult)
      // Explicit logging of the important diagnostic data
      console.log("MEMBERSHIP DATA:", JSON.stringify(diagResult.data, null, 2))
      if (diagResult.data) {
        console.log("User ID Input:", diagResult.data.user_id_input)
        console.log("Workspace ID Input:", diagResult.data.workspace_id_input)
        console.log("Membership Exists:", diagResult.data.membership_exists)
        console.log("Membership Count:", diagResult.data.membership_count)
        console.log("All User Workspaces:", diagResult.data.all_user_workspaces)
        console.log(
          "All Workspace Members:",
          diagResult.data.all_workspace_members
        )
      }
      // ---> END DIAGNOSTIC FUNCTION <---

      // Use the database function instead of direct table access
      // This bypasses RLS issues while maintaining security checks in the function
      const { data, error } = await supabase.rpc("create_project", {
        p_name: newProjectName,
        p_description: newProjectDescription,
        p_user_id: user.id,
        p_workspace_id: workspaceContext,
        p_color: "#4c4cff",
        p_status: "active"
      })

      if (error) throw error

      await loadProjects(user.id, workspaceContext)
      setShowProjectModal(false)
      setNewProjectName("")
      setNewProjectDescription("")
    } catch (err) {
      console.error("Error creating project:", err)
    } finally {
      setLoading(false)
    }
  }

  // Generate a chat name from the first user message
  const generateChatName = (message: string): string => {
    // Split the message into words
    const words = message.trim().split(/\s+/)

    // Get up to the first 3 words
    const firstThreeWords = words.slice(0, 3).join(" ")

    // If the result is too short, use "Neuer Chat"
    return firstThreeWords.length >= 3 ? firstThreeWords : "Neuer Chat"
  }

  // Modifiziere den useEffect für Task-Wechsel
  useEffect(() => {
    // Only perform task change operations if no message update is pending
    // And ensure at least 500ms has passed since the last message update
    const timeSinceLastUpdate = Date.now() - lastMessageUpdate
    if (messageUpdatePending || timeSinceLastUpdate < 500) {
      console.log(
        "Message update in progress or too recent, deferring task change handling"
      )
      return
    }

    const handleTaskOrModelChange = async () => {
      // Prüfen, ob es sich um einen Task- oder Modellwechsel handelt
      const isTaskChange = selectedTask?.id !== previousSelectedTask?.id
      // const isModelChange = selectedModel !== previousSelectedModel && !selectedTask;

      // Run this logic ONLY on task change, not on simple model selection
      if (isTaskChange && messages.length > 0) {
        // Wenn eine Task oder ein Modell gewechselt wurde und es Nachrichten gibt

        console.log("Task wurde gewechselt, erstelle Zusammenfassung...")

        try {
          // Prüfe, ob bereits eine Zusammenfassung im Chat existiert
          const lastSummaryMessage = [...messages]
            .reverse()
            .find(
              msg =>
                msg.role === "assistant" &&
                (msg.content.includes("Chat-Zusammenfassung") ||
                  msg.content.includes("Hauptpunkte:") ||
                  msg.content.includes("Zusammenfassung des Chats"))
            )

          let summary: string

          if (lastSummaryMessage) {
            // Verwende die vorhandene Zusammenfassung
            console.log("Verwende vorhandene Zusammenfassung")
            summary = lastSummaryMessage.content
          } else {
            // Erstelle eine neue Zusammenfassung, da keine vorhanden ist
            console.log("Überspringe Zusammenfassung für Task-Wechsel (DEBUG)")
            summary = "" // Temporär deaktiviert
          }

          if (summary) {
            // Erstelle eine neue System-Nachricht mit der Zusammenfassung
            const summarySystemMessage: Message = {
              id: uuidv4(),
              role: "system",
              content: `Zusammenfassung des bisherigen Gesprächs: ${summary}

${selectedTask ? selectedTask.system_prompt : "Fahre mit dem Gespräch fort, basierend auf dieser Zusammenfassung."}`,
              timestamp: new Date()
            }

            // Entferne alle bisherigen System-Nachrichten
            const filteredMessages = messages.filter(m => m.role !== "system")

            // Füge die neue System-Nachricht am Anfang hinzu
            setMessages([summarySystemMessage, ...filteredMessages])

            console.log(
              "Zusammenfassung wurde als System-Nachricht hinzugefügt."
            )

            // Task-switching notification message is REMOVED
          }
        } catch (error) {
          console.error("Error in task change handling:", error)
        } finally {
          // Always set isTaskSwitching to false when complete
          setIsTaskSwitching(false)
        }
      } else {
        // If there's no task change or no messages, just reset the switching state
        setIsTaskSwitching(false)
      }

      // Aktuelle Task und Modell für den nächsten Vergleich speichern
      setPreviousSelectedTask(selectedTask)
      setPreviousSelectedModel(selectedModel)
    }

    handleTaskOrModelChange()
  }, [
    selectedTask,
    selectedModel,
    messages,
    messageUpdatePending,
    previousSelectedTask,
    previousSelectedModel,
    lastMessageUpdate
  ])

  // Add this function to sync messages with the database when needed
  const syncMessagesWithDatabase = async (chatId: string) => {
    if (!chatId) return

    try {
      console.log("Syncing messages with database for chat:", chatId)
      const { data, error } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (error) {
        console.error("Error syncing messages:", error)
        return
      }

      if (data) {
        // Convert database messages to app message format
        const formattedMessages: Message[] = data.map(dbMsg => ({
          id: dbMsg.id || uuidv4(),
          role: dbMsg.role as "user" | "assistant" | "system",
          content: dbMsg.content,
          timestamp: new Date(dbMsg.created_at)
        }))

        console.log(`Synced ${formattedMessages.length} messages from database`)
        setMessages(formattedMessages)
      }
    } catch (error) {
      console.error("Error in syncMessagesWithDatabase:", error)
    }
  }

  // Modify handleSendMessage to optionally include web search results
  const handleSendMessage = async (
    message: string,
    includeWebSearch: boolean = false
  ) => {
    if (message.trim().length === 0) return
    if (isTyping || messageUpdatePending || isTaskSwitching) return

    // Markieren, dass der Benutzer mit dem Tippen begonnen hat
    setHasStartedTyping(true)

    const userMessageId = uuidv4()
    const newMessage: Message = {
      id: userMessageId,
      role: "user",
      content: message,
      timestamp: new Date(),
      user_id: user?.id,
      sentfrom: userFullName
    }

    console.log("Creating new message with user_id:", user?.id)

    try {
      // Prevent task switching effects during message sending
      setMessageUpdatePending(true)
      setLastMessageUpdate(Date.now())

      // Create the new array *before* setting state
      const newMessagesArray = [...messages, newMessage]

      // Add user message to state immediately for better UX
      setMessages(newMessagesArray) // Use the new array
      setInputValue("") // Eingabefeld leeren

      // Show typing indicator
      setIsTyping(true)

      // If web search is requested, perform it before sending to API
      let webSearchResults = null
      if (includeWebSearch) {
        setIsSearching(true)
        try {
          webSearchResults = await performSerpApiSearch(message)
          console.log("Web search results:", webSearchResults.length)
        } catch (searchError) {
          console.error("Error during web search:", searchError)
        } finally {
          setIsSearching(false)
        }
      }

      let chatIdToUse = currentChatId

      // If no current chat exists, create a new one before proceeding
      if (!chatIdToUse) {
        console.log(
          "No current chat, creating new one before sending message..."
        )
        chatIdToUse = await createNewChat()
        if (!chatIdToUse) {
          throw new Error("Failed to create a new chat")
        }
        console.log(`Successfully created new chat with ID: ${chatIdToUse}`)
        // Set current chat ID immediately to ensure context is maintained
        setCurrentChatId(chatIdToUse)
      }

      // Speichern der Benutzernachricht in der Datenbank
      console.log(`Saving message to chat ID: ${chatIdToUse}`)

      // Wichtig: Wir benötigen diese Nachrichts-ID für Embedding
      let dbMessageId = null;

      try {
      const { data: messageData, error: messageError } = await retryOperation(
        async () => {
          return await supabase
            .from("chat_messages")
            .insert({
              chat_id: chatIdToUse,
              role: "user",
                content: message,
              user_id: user?.id,
              sentfrom: userFullName,
              created_at: newMessage.timestamp.toISOString()
            })
            .select()
        },
        3,
        1000
        );

      if (messageError) {
        console.error("❌ Error saving message:", messageError)
      } else {
        console.log("✅ Message saved successfully to database", messageData)
          // Speichere die ID für spätere Verwendung
        if (messageData && messageData.length > 0) {
            dbMessageId = messageData[0].id;
          }
        }
      } catch (saveError) {
        console.error("Error saving user message:", saveError);
        // Wir setzen den Prozess fort, auch wenn die Nachricht nicht gespeichert werden konnte
      }

      // Vorbereiten und Senden der Anfrage an die API
      try {
        const modelToUse = selectedTask?.ai_model || selectedModel
        console.log("📣 Sende Nachricht an API mit Chat-ID:", chatIdToUse)
        console.log("🔄 Ausgewähltes Modell für diese Anfrage:", modelToUse);

        // Streaming-Response
        const response = await sendMessageToAPI(
          newMessagesArray,
          modelToUse,
          chatIdToUse
        )

        // Assistentennachricht erstellen und anzeigen (vorerst leer)
        const assistantMessageId = uuidv4()
        const assistantMessage: Message = {
          id: assistantMessageId,
          role: "assistant",
          content: "", // Startinhalt ist leer, wird nach und nach gefüllt
          timestamp: new Date(),
          isTypewriting: true // Ensure this is set to true
        }

        // Sofort hinzufügen, um den Platzhalter anzuzeigen
        setMessages(prevMessages => [...prevMessages, assistantMessage])
        setTypingMessageId(assistantMessageId) // Make sure to set the typing message ID

        // Wenn Streaming-Antwort verfügbar ist, nutze diese
        if (response.streamContent) {
          try {
            console.log("🎬 Starte Streaming-Verarbeitung...");
            // Sammle Nachrichteninhalt während des Streamings
            let collectedContent = "";
            
            // Hole den Generator für die Stream-Verarbeitung
            const contentGenerator = response.streamContent();
            
            // Schreibe die assistantMessageId in eine konstante Variable
            // für die asynchronen Funktionen
            const messageIdToUpdate = assistantMessageId;
            
            // Verarbeite jeden Chunk aus dem Stream
            for await (const chunk of contentGenerator) {
              // Try to process chunk if it's JSON
              let processedChunk = chunk;
              try {
                if (chunk.trim().startsWith('{') && chunk.trim().endsWith('}')) {
                  const jsonChunk = JSON.parse(chunk);
                  if (jsonChunk && typeof jsonChunk.content === 'string') {
                    processedChunk = jsonChunk.content;
                  }
                }
              } catch (e) {
                // Use original chunk if JSON parsing fails
                processedChunk = chunk;
              }
              
              collectedContent += processedChunk;
              
              // Aktualisiere die Nachricht in der UI mit jedem Chunk
              setMessages(prevMessages => 
                prevMessages.map(msg => 
                  msg.id === messageIdToUpdate 
                    ? { ...msg, content: collectedContent, isTypewriting: true }
                    : msg
                )
              );
            }
            
            // Nach Ende des Streams: endgültigen Inhalt speichern
            assistantMessage.content = collectedContent || response.content;
            
            // Aktualisiere mit dem endgültigen Inhalt für den Fall von Metadaten
            setMessages(prevMessages => 
              prevMessages.map(msg => 
                msg.id === messageIdToUpdate 
                  ? { ...msg, content: assistantMessage.content }
                  : msg
              )
            );
            
            console.log("✅ Streaming abgeschlossen, Gesamtlänge:", assistantMessage.content.length);
          } catch (streamingError) {
            console.error("❌ Fehler bei der Stream-Verarbeitung:", streamingError);
            // Fallback: Verwende das content-Feld, wenn verfügbar
            if (response.content) {
              assistantMessage.content = response.content;
              setMessages(prevMessages => 
                prevMessages.map(msg => 
                  msg.id === assistantMessageId 
                    ? { ...msg, content: response.content }
                    : msg
                )
              );
            }
          }
        } else {
          // Fallback für nicht-Streaming-Antworten
          assistantMessage.content = response.content;
          setMessages(prevMessages => 
            prevMessages.map(msg => 
              msg.id === assistantMessageId 
                ? { ...msg, content: response.content }
                : msg
            )
          );
        }

        // Speichern der Assistentennachricht in der Datenbank
        let dbAssistantId = null;
        try {
          const { data: assistantData, error: assistantError } = await supabase
            .from("chat_messages")
            .insert({
              chat_id: chatIdToUse,
              role: "assistant",
              content: assistantMessage.content,
              created_at: assistantMessage.timestamp.toISOString()
            })
            .select();

          if (assistantError) {
            console.error("❌ Error saving assistant message:", assistantError)
          } else {
            console.log("✅ AI message saved to database", assistantData)
            if (assistantData && assistantData.length > 0) {
              dbAssistantId = assistantData[0].id;
            }
          }
        } catch (saveError) {
          console.error("Error saving assistant message:", saveError);
        }

        // Nach erfolgreicher Kommunikation, starte asynchrone Aufgaben
        // Embedding für Benutzernachricht
        if (dbMessageId) {
          const dbMessage = { ...newMessage, id: dbMessageId };
          const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
          createEmbedding(dbMessage, chatIdToUse, workspaceIdToUse)
            .catch(err => console.error("User embedding failed:", err));
        }

        // Embedding für Assistentennachricht
        if (dbAssistantId) {
          const dbAssistantMessage = { ...assistantMessage, id: dbAssistantId };
          const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
          createEmbedding(dbAssistantMessage, chatIdToUse, workspaceIdToUse)
            .catch(err => console.error("Assistant embedding failed:", err));
        }

        // Titelgenerierung für neue Chats
        if (!currentChatId && chatIdToUse) {
          generateAndSetChatTitle(chatIdToUse, message)
            .catch(err => console.error("Title generation failed:", err));
        }

        // Chat-Liste aktualisieren
        if (user) {
          loadChatSessions(user.id, rawWorkspaceId || null)
            .catch(err => console.error("Chat session loading failed:", err));
        }
      } catch (apiError) {
        console.error("Error getting AI response:", apiError)
        setIsTyping(false)

        // Fehlermeldung hinzufügen
        const errorMessageId = uuidv4()
        const errorMessage: Message = {
          id: errorMessageId,
          role: "assistant",
          content: "Die Verbindung zum AI-Service konnte nicht hergestellt werden. Bitte versuche es später noch einmal.",
          timestamp: new Date()
        }
        setMessages(prevMessages => [...prevMessages, errorMessage])
      } finally {
        // In jedem Fall Typing-Status zurücksetzen
        setIsTyping(false)
        setMessageUpdatePending(false)
      }
    } catch (error) {
      console.error("Error in handleSendMessage:", error)
      setIsTyping(false)
      setMessageUpdatePending(false)
    }
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    handleSendMessage(inputValue)
  }

  const getModelLabel = (modelId: string | null): string => {
    // Map actual model IDs back to friendly names
    switch (modelId) {
      // Direkte Namen (keine Umwandlung nötig)
      case "Basic":
        return "Basic"
      case "Fast":
        return "Fast"
      case "Reason":
        return "Reason"
      case "Reason+":
        return "Reason+"

      // Alte technische IDs für Abwärtskompatibilität
      case "gpt-4o-2024-11-20":
        return "Basic"
      case "gpt-4o-mini-2024-07-18":
        return "Fast"
      case "o3-mini-2025-01-31":
        return "Reason"
      case "gpt-4.5-preview-2025-02-27":
        return "Reason+"

      // Sehr alte IDs für Abwärtskompatibilität
      case "gpt-4o":
        return "Basic"
      case "gpt-4o-mini":
        return "Fast"
      case "gpt-4-vision-preview":
        return "Reason"
      default:
        // Standardwert
        return modelId || "Basic"
    }
  }

  // Function to copy message content to clipboard
  const copyToClipboard = (text: string) => {
    navigator.clipboard
      .writeText(text)
      .then(() => {
        // Could show a toast notification here
        console.log("Copied to clipboard")
      })
      .catch(err => {
        console.error("Failed to copy: ", err)
      })
  }

  // Function to start editing a user message
  const startEditMessage = (message: Message) => {
    // Save the current state of all messages for potential restoration
    setOriginalMessages([...messages]);
    
    // Find the index of the message to edit
    const messageIndex = messages.findIndex(m => m.id === message.id);
    if (messageIndex === -1) return;
    
    // Keep only messages up to and including the one being edited
    const visibleMessages = messages.slice(0, messageIndex + 1);
    setMessages(visibleMessages);
    
    // Set editing state
    setEditingMessageId(message.id);
    setEditingContent(message.content);
  }

  // Function to cancel editing
  const cancelEditMessage = () => {
    // Restore messages to their original state
    if (originalMessages.length > 0) {
      setMessages(originalMessages);
    }
    
    // Reset editing state
    setEditingMessageId(null);
    setEditingContent("");
    setOriginalMessages([]);
  }

  // Add this helper function to track processed messages
  const processedMessageIds = new Set<string>();

  // Add the saveAssistantMessage helper function before the handleSaveEdit function
  const saveAssistantMessage = async (assistantMessage: Message, chatId: string) => {
    try {
      debugLog("Saving AI response for chat:", chatId);
      
      // Get current date in YYYY-MM-DD format
      const currentDate = new Date().toISOString().split("T")[0];
      
      // Store date directly in content field but in a way that can be filtered out in UI
      const contentWithDate = `[Datum: ${currentDate}]\n${assistantMessage.content}`;
      
      const { error: aiInsertError, data: aiInsertData } = await supabase
          .from("chat_messages")
        .insert({
          id: assistantMessage.id, // Use specific ID to help with deduplication
          chat_id: chatId,
          role: "assistant",
          // Store content with date prefix - we'll strip it when displaying
          content: contentWithDate,
          user_id: null, // AI responses don't have a user ID
          created_at: new Date().toISOString()
        })
        .select();

      if (aiInsertError) {
        console.error("Error saving AI response:", aiInsertError);
        return false;
      }
      
      debugLog("AI response saved successfully:", aiInsertData);
      return true;
    } catch (aiInsertErr) {
      console.error("Error during AI message insertion:", aiInsertErr);
      return false;
    }
  };

  // Function to handle saving edited messages
  const handleSaveEdit = async () => {
    if (!editingMessageId || !editingContent.trim()) return;

    try {
      // Use a copy of original messages to work with
      const originalMessagesCopy = [...originalMessages];
      const messageIndex = originalMessagesCopy.findIndex(m => m.id === editingMessageId);

      if (messageIndex === -1) {
        console.error("Message to edit not found in original messages");
        return;
      }

      const messageToEdit = originalMessagesCopy[messageIndex]; // Get the original message object

      // Create the updated message object
      const updatedMessage = {
        ...messageToEdit,
        content: editingContent,
        timestamp: new Date() // Use new timestamp for the edited message
      };

      // Determine if AI messages after the edited one need removal
      const hasAssistantMessagesAfter = originalMessagesCopy
        .slice(messageIndex + 1)
        .some(m => m.role === "assistant");

      // Prepare the new messages array for the UI
      let newMessagesForUI;
      
      if (hasAssistantMessagesAfter) {
        // Keep messages before the edited one, then add the updated message
        newMessagesForUI = [
          ...originalMessagesCopy.slice(0, messageIndex),
          updatedMessage
        ];
      } else {
        // Create a new array excluding the original, then add the updated one
        newMessagesForUI = [
            ...originalMessagesCopy.filter(msg => msg.id !== editingMessageId),
            updatedMessage
        ];
      }

      // Update UI state *before* database operations
      setMessages(newMessagesForUI);

      // Reset editing state immediately after UI update
      const savedEditingMessageId = editingMessageId; // Save for DB ops
      setEditingMessageId(null);
      setEditingContent("");
      setOriginalMessages([]); // Clear the saved original state

      // Database Operations: Delete original, Insert new
      if (currentChatId) {
        try {
          // 1. Delete subsequent AI messages if necessary
          if (hasAssistantMessagesAfter) {
            console.log("DB: Deleting subsequent AI messages after", messageToEdit.timestamp.toISOString());
            const { error: deleteSubsequentError } = await supabase
              .from("chat_messages")
              .delete()
              .eq("chat_id", currentChatId)
              .gt("created_at", messageToEdit.timestamp.toISOString()); // Match based on original timestamp
            if (deleteSubsequentError) console.error("DB: Error deleting subsequent messages:", deleteSubsequentError);
            else console.log("DB: Subsequent AI messages deleted.");
          }

          // 2. Delete the *original* message from the database
          console.log(`DB: Deleting original message (created at ${messageToEdit.timestamp.toISOString()})`);
          const { error: deleteOriginalError } = await supabase
            .from("chat_messages")
            .delete()
            .eq("chat_id", currentChatId)
            .eq("created_at", messageToEdit.timestamp.toISOString()); // Match original by timestamp
          
          if (deleteOriginalError) {
            console.error("DB: Error deleting original message:", deleteOriginalError);
            // Consider handling this error more gracefully, maybe revert UI?
          } else {
            console.log("DB: Original message deleted successfully.");

            // 3. Insert the *new* edited message
            console.log("DB: Inserting edited message");
            const { data: insertData, error: insertError } = await supabase
              .from("chat_messages")
              .insert({
                chat_id: currentChatId,
                role: updatedMessage.role,
                content: updatedMessage.content,
                user_id: updatedMessage.user_id,
                sentfrom: updatedMessage.sentfrom,
                created_at: updatedMessage.timestamp.toISOString() // Use the new timestamp
              })
              .select(); // Select the inserted row to get its DB ID if needed
            
            if (insertError) {
              console.error("DB: Error inserting edited message:", insertError);
              // Consider reverting UI or showing error
            } else {
              console.log("DB: Edited message inserted successfully.");
              const insertedDbMessageId = insertData?.[0]?.id; // Get DB ID if available
              
              // Create embedding for the newly inserted edited message
              if (insertedDbMessageId) {
                // We need the full Message object with the DB ID for embedding potentially
                 const embeddingMessage = { ...updatedMessage, id: insertedDbMessageId }; // Use DB id if needed by embedding
                 const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
                 createEmbedding(embeddingMessage, currentChatId, workspaceIdToUse)
                  .catch(err => console.error("Edited message embedding failed:", err));
              }

              // 4. Regenerate AI response if necessary (only after successful insert)
              if (hasAssistantMessagesAfter) {
                console.log("Regenerating AI response after edit...");
                setIsTyping(true); // Show typing indicator for regeneration
                setMessageUpdatePending(true); // Prevent other actions during regen
                try {
                    const modelToUse = selectedTask?.ai_model || selectedModel
                    const response = await sendMessageToAPI(
                        newMessagesForUI, // Use the corrected message list for the API
                        modelToUse,
                        currentChatId
                    );

                    // Handle streaming response for the regenerated message
                    const assistantMessageId = uuidv4();
                    const assistantMessage: Message = {
                        id: assistantMessageId,
                        role: "assistant",
                        content: "",
                        timestamp: new Date(),
                        isTypewriting: true
                    };
                    
                    setMessages(prev => [...prev, assistantMessage]);
                    setTypingMessageId(assistantMessageId);

                    if (response.streamContent) {
                      let collectedContent = "";
                      const contentGenerator = response.streamContent();
                      const messageIdToUpdate = assistantMessageId;
                      
                      for await (const chunk of contentGenerator) {
                        let processedChunk = chunk;
                        try {
                          if (chunk.trim().startsWith('{') && chunk.trim().endsWith('}')) {
                            const jsonChunk = JSON.parse(chunk);
                            if (jsonChunk && typeof jsonChunk.content === 'string') {
                              processedChunk = jsonChunk.content;
                            }
                          }
                        } catch (e) { /* Ignore parsing errors, use chunk */ }
                        
                        collectedContent += processedChunk;
                        setMessages(prev => prev.map(msg => msg.id === messageIdToUpdate ? { ...msg, content: collectedContent, isTypewriting: true } : msg));
                      }
                      assistantMessage.content = collectedContent || response.content;
                       setMessages(prev => prev.map(msg => msg.id === messageIdToUpdate ? { ...msg, content: assistantMessage.content } : msg)); // Final update
                      
                    } else {
                       assistantMessage.content = response.content;
                       setMessages(prev => prev.map(msg => msg.id === assistantMessageId ? { ...msg, content: assistantMessage.content } : msg)); // Use assistantMessageId here
                    }
                    
                   // Save regenerated AI message to DB & create embedding
                    let dbAssistantId = null;
                    try {
                      const { data: assistantData, error: assistantError } = await supabase
                        .from("chat_messages")
                        .insert({
                          chat_id: currentChatId,
                          role: "assistant",
                          content: assistantMessage.content,
                          created_at: assistantMessage.timestamp.toISOString()
                        })
                        .select();

                      if (assistantError) console.error("❌ Error saving regenerated assistant message:", assistantError)
                      else {
                         console.log("✅ Regenerated AI message saved to database", assistantData)
                         dbAssistantId = assistantData?.[0]?.id;
                         if (dbAssistantId) {
                             const dbAssistantMessage = { ...assistantMessage, id: dbAssistantId };
                             const workspaceIdToUse = rawWorkspaceId && rawWorkspaceId.trim() !== "" ? rawWorkspaceId : null;
                             createEmbedding(dbAssistantMessage, currentChatId, workspaceIdToUse)
                               .catch(err => console.error("Regenerated assistant embedding failed:", err));
                         }
                      }
                    } catch (saveError) { console.error("Error saving regenerated assistant message:", saveError); }

                } catch (regenError) {
                    console.error("Error regenerating AI response:", regenError);
                    // Add error message to UI?
                } finally {
                    setIsTyping(false);
                    setMessageUpdatePending(false);
                    // Assuming assistantMessageId IS defined in this scope, despite linter warning
                    handleTypewriterComplete(assistantMessageId); // Ensure typewriter stops
                }
              }
            }
          }
        } catch (dbError) {
          console.error("DB: Operation failed:", dbError);
        }
      }
    } catch (err) {
      console.error("Error in handleSaveEdit:", err);
      // Ensure UI state is reset even if there's an error
       if (editingMessageId) {
          cancelEditMessage(); // Attempt to restore original state if possible
       }
    }
  };

  // Updated function to regenerate AI response
  const regenerateResponse = async (aiMessageId: string) => {
    setTypingMessageId(null)

    const aiMessageIndex = messages.findIndex(m => m.id === aiMessageId)
    if (aiMessageIndex === -1 || aiMessageIndex === 0) return // Cannot regenerate if it's the first message or not found

    const userMessageIndex = aiMessageIndex - 1
    if (messages[userMessageIndex].role !== "user") return // Should be preceded by a user message

    const userMessageToResend = messages[userMessageIndex]

    // Keep messages up to the preceding user message
    const messagesToKeep = messages.slice(0, userMessageIndex + 1)

    // Update UI state
    setMessages(messagesToKeep)

    // Delete the AI message and subsequent ones from DB
    if (currentChatId) {
      supabase
        .from("chat_messages")
        .delete()
        .eq("chat_id", currentChatId)
        .gte("created_at", messages[aiMessageIndex].timestamp.toISOString())
        .then(({ error }) => {
          if (error) {
            console.error("Error deleting messages for regeneration:", error)
          } else {
            console.log("Messages deleted for regeneration from DB")
          }
        })
    }

    // Resend the user message that led to this AI response
    await handleSendMessage(userMessageToResend.content)
  }

  // Add another function to retry failed database operations with logging
  const retryOperation = async (
    operation: () => Promise<any>,
    maxRetries = 3,
    delay = 500
  ) => {
    let lastError
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await operation()
      } catch (err) {
        lastError = err
        console.error(
          `Operation failed (attempt ${attempt}/${maxRetries}):`,
          err
        )

        if (attempt < maxRetries) {
          console.log(`Retrying in ${delay}ms...`)
          await new Promise(resolve => setTimeout(resolve, delay))
          delay *= 2 // Exponential backoff
        }
      }
    }
    throw lastError
  }

  // Simplified deleteChat function that works with the consolidated database structure
  const deleteChat = async (chatId: string) => {
    try {
      // Close any open menus
      setChatMenuOpen(null)

      console.log("Starting delete process for chat:", chatId)

      // With the ON DELETE CASCADE constraint, we only need to delete the chat
      // All associated messages will be automatically deleted
      const { error } = await supabase
        .from("chats")
        .delete()
        .eq("id", chatId)
        .eq("user_id", user.id)

      if (error) {
        console.error("Error deleting chat:", error)
        return
      }

      console.log("Chat and all associated messages deleted successfully")

      // Remove from state
      setChatSessions(prevSessions =>
        prevSessions.filter(chat => chat.id !== chatId)
      )

      // If the deleted chat was the current one, load another chat
      if (currentChatId === chatId) {
        // Get a fresh list of remaining chats after removing the deleted one
        const remainingChats = [...chatSessions].filter(
          chat => chat.id !== chatId
        )

        if (remainingChats.length > 0) {
          const nextChatId = remainingChats[0].id
          console.log("Switching to next chat:", nextChatId)
          setCurrentChatId(nextChatId)
        } else {
          console.log("No chats remaining, clearing state")
          setCurrentChatId(null)
          setMessages([])
        }
      }

      // Reload chats from database to ensure we have fresh data
      await loadChatSessions(user.id, rawWorkspaceId || null)

      console.log("Chat successfully deleted:", chatId)
    } catch (err) {
      console.error("Error in deleteChat:", err)
    }
  }

  // Add function to open rename modal
  const openRenameModal = (chat: ChatSession) => {
    setChatToRename(chat)
    setNewChatName(chat.name)
    setRenameModalOpen(true)
    setChatMenuOpen(null)
  }

  // Start inline edit for a chat
  const startInlineEdit = (chat: ChatSession, e: React.MouseEvent) => {
    e.stopPropagation() // Verhindere Bubble-Up zum Button
    setEditingChatId(chat.id)
    setNewChatName(chat.name)
    setChatMenuOpen(null)
  }

  // Handle focus loss on inline edit
  const handleInlineEditBlur = async () => {
    if (editingChatId && newChatName.trim()) {
      // Finde den Chat
      const chatToUpdate = chatSessions.find(chat => chat.id === editingChatId)
      if (chatToUpdate) {
        try {
          // Update in DB
          const { error } = await supabase
            .from("chats")
            .update({ name: newChatName })
            .eq("id", editingChatId)
            .eq("user_id", user.id)

          if (error) {
            console.error("Error renaming chat:", error)
          } else {
            // Update local state
            setChatSessions(prevSessions =>
              prevSessions.map(chat =>
                chat.id === editingChatId
                  ? { ...chat, name: newChatName }
                  : chat
              )
            )
          }
        } catch (err) {
          console.error("Error in inline chat rename:", err)
        }
      }
    }
    // Reset edit state
    setEditingChatId(null)
    setNewChatName("")
  }

  // Submit inline edit with enter key
  const handleInlineEditKeyDown = (e: React.KeyboardEvent) => {
    if (e.key === "Enter") {
      e.preventDefault()
      handleInlineEditBlur()
    } else if (e.key === "Escape") {
      e.preventDefault()
      setEditingChatId(null)
      setNewChatName("")
    }
  }

  // Simplified function to handle chat renaming
  const handleRenameChat = async () => {
    if (!chatToRename || !newChatName.trim()) return

    try {
      const { error } = await supabase
        .from("chats")
        .update({ name: newChatName })
        .eq("id", chatToRename.id)
        .eq("user_id", user.id)

      if (error) {
        console.error("Error renaming chat:", error)
        return
      }

      console.log("Chat renamed successfully")

      // Update in state
      setChatSessions(prevSessions =>
        prevSessions.map(chat =>
          chat.id === chatToRename.id ? { ...chat, name: newChatName } : chat
        )
      )

      // Close modal
      setRenameModalOpen(false)
      setChatToRename(null)
      setNewChatName("")

      // Reload chats to ensure state is in sync
      await loadChatSessions(user.id, rawWorkspaceId || null)
    } catch (err) {
      console.error("Error in handleRenameChat:", err)
    }
  }

  const deleteProject = async (projectId: string) => {
    try {
      setError(null)
      setProjectMenuOpen(null)

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null

      // --- BERECHTIGUNGSPRÜFUNG ---
      // Diese Prüfung schlägt aktuell fehl (PGRST116) und muss behoben werden!
      const { data: memberData, error: memberError } = await supabase
        .from("workspace_members")
        .select("role")
        .eq("workspace_id", workspaceContext)
        .eq("user_id", user.id)
        .single() // <- Findet 0 Zeilen!

      if (memberError) {
        console.error("Fehler beim Prüfen der Berechtigung:", memberError)
        // Zeige den Fehler an, aber kehre *noch nicht* zurück,
        // damit der Rest der Funktion für den Fall ausgeführt wird, dass die Prüfung *korrekt* wäre.
        // In der finalen Version sollte hier ein `return` stehen.
        setError(`Berechtigungsfehler: ${memberError.message}`)
        return // <-- Wichtig: Reaktiviert!
      } else if (!memberData || !["admin", "owner"].includes(memberData.role)) {
        setError(
          "Nur Workspace-Administratoren oder Eigentümer können Projekte löschen."
        )
        return // Hier ist der Return OK.
      }
      // --- ENDE BERECHTIGUNGSPRÜFUNG ---

      if (
        !confirm(
          `Projekt "${projects.find(p => p.id === projectId)?.name}" wirklich löschen?`
        )
      ) {
        return
      }

      // Lösche das Projekt
      const { error: deleteError } = await supabase
        .from("projects")
        .delete()
        .eq("id", projectId)

      if (deleteError) {
        console.error("Error deleting project:", deleteError)
        setError(`Fehler beim Löschen des Projekts: ${deleteError.message}`)
        return // Beende bei Löschfehler
      }

      console.log("✅ Projekt erfolgreich gelöscht. Lade Daten neu...")

      // --- DATEN NEU LADEN statt lokalen State zu patchen ---
      setLoading(true) // Ladeindikator anzeigen
      try {
        // Lade Projekte und Chats neu
        if (user) {
          await loadProjects(user.id, workspaceContext)
          await loadChatSessions(user.id, workspaceContext)
        }

        // Setze abhängige Zustände zurück
        if (selectedProject?.id === projectId) {
          setSelectedProject(null)
        }
        // Finde Chats, die zu diesem Projekt gehören (basierend auf dem *alten* State vor dem Reload)
        const chatsInProjectToDelete = chatSessions.filter(
          chat => chat.project_id === projectId
        )
        if (
          editingChatId &&
          chatsInProjectToDelete.some(chat => chat.id === editingChatId)
        ) {
          setEditingChatId(null)
          setNewChatName("")
        }
        // expandedProjects muss nicht manuell bereinigt werden, da es von 'projects' abhängt
      } catch (reloadError) {
        console.error(
          "Fehler beim Neuladen der Daten nach Projektlöschung:",
          reloadError
        )
        setError(
          "Projekt gelöscht, aber Fehler beim Aktualisieren der Ansicht."
        )
      } finally {
        setLoading(false)
      }
    } catch (err) {
      // Dieser Catch ist jetzt hauptsächlich für unerwartete Fehler
      console.error("Unexpected error in deleteProject:", err)
      setError("Ein unerwarteter Fehler ist aufgetreten.")
    }
  }

  const updateProject = async () => {
    if (!projectToRename || !newProjectName.trim()) return

    try {
      setLoading(true)

      const { data, error } = await supabase
        .from("projects")
        .update({
          name: newProjectName,
          description: newProjectDescription,
          updated_at: new Date().toISOString()
        })
        .eq("id", projectToRename.id)
        .select()

      if (error) throw error

      // Aktualisiere Projektliste
      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
      await loadProjects(user.id, workspaceContext)

      // Wenn das bearbeitete Projekt ausgewählt war, aktualisiere die Auswahl
      if (selectedProject?.id === projectToRename.id && data?.[0]) {
        setSelectedProject(data[0])
      }

      // Modal schließen
      setShowProjectModal(false)
      setProjectToRename(null)
      setNewProjectName("")
      setNewProjectDescription("")
    } catch (err) {
      console.error("Error updating project:", err)
    } finally {
      setLoading(false)
    }
  }

  // Chat einem Projekt zuweisen
  const assignChatToProject = async (
    chatId: string,
    projectId: string | null
  ) => {
    try {
      console.log(
        `Zuweisen von Chat ${chatId} zu Projekt ${projectId || "none"}`
      )

      // Update in der Datenbank
      const { error } = await supabase
        .from("chats")
        .update({
          project_id: projectId,
          // Auch last_message_timestamp aktualisieren, damit die Sortierung korrekt bleibt
          last_message_timestamp: new Date().toISOString()
        })
        .eq("id", chatId)

      if (error) throw error

      // Update im lokalen State
      setChatSessions(prev =>
        prev.map(chat =>
          chat.id === chatId ? { ...chat, project_id: projectId } : chat
        )
      )

      // Lade Chats neu, um sicherzustellen, dass die UI korrekt aktualisiert wird
      if (user) {
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
        // Verzögerung einbauen, damit die Datenbank Zeit hat, die Änderung zu verarbeiten
        setTimeout(async () => {
          await loadChatSessions(user.id, workspaceContext)
        }, 300)
      }

      console.log(
        `Chat ${chatId} wurde ${projectId ? `Projekt ${projectId}` : "keinem Projekt"} zugewiesen`
      )
    } catch (err) {
      console.error("Fehler beim Zuweisen des Chats:", err)
      setError("Fehler beim Zuweisen des Chats zu einem Projekt")
    }
  }

  // Ergänze die Message-Komponente
  const Message = ({
    message,
    isTyping
  }: {
    message: Message
    isTyping?: boolean
  }) => {
    const isUser = message.role === "user"
    const messageRef = useRef<HTMLDivElement>(null)

    // Detect and format HTML code
    const formatCodeInMessage = (content: string): string => {
      // If content already has markdown code blocks, don't modify
      if (content.includes("```")) return content;
      
      // Check if the content appears to be HTML
      if (
        content.trim().startsWith("<") && 
        (content.includes("<!DOCTYPE") || 
         content.includes("<html") ||
         (content.includes("<body") && content.includes("</body>")) ||
         (content.includes("<head") && content.includes("</head>")))
      ) {
        return "```html\n" + content + "\n```";
      }
      
      return content;
    };

    // Add effect to ensure message is visible
    useEffect(() => {
      // Only scroll into view for the most recent message
      if (messageRef.current && !isTyping) {
        messageRef.current.scrollIntoView({ behavior: "smooth", block: "end" })
      }
    }, [message.id, isTyping])

    if (message.role === "system") {
      return null // System-Nachrichten nicht anzeigen
    }

    // Calculate whether to show the effect
    const showEffect = message.role === "assistant" && (message.isTypewriting || typingMessageId === message.id);

    return (
      <div
        ref={messageRef}
        className={`w-full ${isUser ? "bg-transparent" : "bg-gray-800"}`}
        data-message-id={message.id}
      >
        <div className="mx-auto max-w-xl px-8 pt-0 pb-1">
          <div className={`flex items-start gap-1 ${isUser ? "justify-end" : "justify-start"}`}>
            {!isUser && (
              <div className="flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full bg-gray-600 text-white">
                AI
              </div>
            )}
            <div className={`${isUser ? "max-w-[65%]" : "max-w-[65%]"}`}>
              {showEffect ? (
                <div className="text-left">
                {/* Replace TypewriterEffect with RevealEffect */}
                <RevealEffect
                  content={message.content}
                  onComplete={() => handleTypewriterComplete(message.id)}
                />
                </div>
              ) : (
                <div className="text-left">
                  {(() => {
                    let displayContent = message.content;
                    try {
                      // Check if content is JSON with a content field
                      if (message.content.trim().startsWith('{') && message.content.trim().endsWith('}')) {
                        const jsonContent = JSON.parse(message.content);
                        if (jsonContent && typeof jsonContent.content === 'string') {
                          displayContent = jsonContent.content;
                        }
                      }
                    } catch (e) {
                      // If parsing fails, use the original content
                    }
                    return <MessageMarkdown content={displayContent} />;
                  })()}
                </div>
              )}
            </div>
            {isUser && (
              <div className="flex h-8 w-8 shrink-0 select-none items-center justify-center rounded-full bg-blue-600 text-white">
                U
              </div>
            )}
          </div>
        </div>
      </div>
    )
  }

  // Add this new useEffect to listen for changes to personalWorkspaceId
  useEffect(() => {
    // Skip if no personal workspace or if we already have chat sessions
    if (!personalWorkspaceId || initialChatsLoadedRef.current || !user) {
      return;
    }
    
    console.log("Personal workspace ID available, loading initial data:", personalWorkspaceId);
    
    // Mark as loaded to prevent multiple executions
    initialChatsLoadedRef.current = true;
    
    const loadInitialData = async () => {
      try {
        // Use the direct query approach to ensure we get the latest data
        let query = supabase
          .from("chats")
          .select(
            "id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id"
          )
          .eq("workspace_id", personalWorkspaceId)
          .order("last_message_timestamp", { ascending: false });

        const { data, error } = await query;

        if (error) {
          console.error("Error loading initial chats:", error);
          return;
        }

        if (data && data.length > 0) {
          console.log("Found existing chats:", data.length);
          const formattedSessions = data.map((chat: any) => ({
            id: chat.id || "",
            name: chat.name || "Unnamed Chat",
            created_at: chat.created_at || new Date().toISOString(),
            project_id: chat.project_id,
            user_id: chat.user_id,
            last_message_timestamp: chat.last_message_timestamp,
            ...(chat.description && { description: chat.description })
          }));

          setChatSessions(formattedSessions);

          // Set current chat if not already set
          if (!currentChatId) {
            console.log("Setting current chat to:", data[0].id);
            setCurrentChatId(data[0].id);
            await loadChat(data[0].id);
          }
        } else {
          console.log("No chats found for personal workspace, will create one on first message");
        }
      } catch (err) {
        console.error("Error in loadInitialData:", err);
      }
    };

    loadInitialData();
  }, [personalWorkspaceId, user, supabase]); // Removed currentChatId and chatSessions dependencies

  // Funktion zum Generieren und Setzen des Chat-Titels via AI
  const generateAndSetChatTitle = async (
    chatId: string,
    firstUserMessage: string
  ) => {
    console.log(
      `✨ Generating title for chat ${chatId} based on: "${firstUserMessage}"`
    )
    try {
      // NEUE DIREKTE IMPLEMENTATION:
      // Statt sendMessageToAPI zu nutzen, machen wir den API Call direkt hier
      // um Fehler durch komplexe State-Handling-Logic in sendMessageToAPI zu vermeiden

      const prompt = `Analysiere die folgende Benutzernachricht und generiere einen kurzen, prägnanten Titel (maximal 4 Wörter) für diesen Chat. Gib NUR den Titel zurück, ohne Anführungszeichen oder zusätzliche Erklärungen:\n\nNachricht: "${firstUserMessage}"\n\nTitel:`

      // Direkte Anfrage an unsere API-Route
      const response = await fetch("/api/chat", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          messages: [{ role: "user", content: prompt }],
          model: "Fast" // Schnelles Modell verwenden
        })
      })

      if (!response.ok) {
        throw new Error(`API request failed: ${response.status}`)
      }

      const data = await response.json()
      let generatedTitle = data?.content?.trim() || null

      console.log(`👋 API response for title generation:`, data)

      if (generatedTitle) {
        console.log(`✨ AI generated title: "${generatedTitle}"`)

        // Entferne mögliche Anführungszeichen am Anfang/Ende
        generatedTitle = generatedTitle.replace(/^"|"$/g, "")

        // Kurzen Fallback, falls Titel leer wird
        if (!generatedTitle.trim()) {
          generatedTitle = generateChatName(firstUserMessage) // Fallback zur alten Methode
          console.log(
            `✨ AI title was empty, using fallback: "${generatedTitle}"`
          )
        }

        // Update Datenbank
        const { error: updateError } = await supabase
          .from("chats")
          .update({ name: generatedTitle })
          .eq("id", chatId)

        if (updateError) {
          console.error("❌ Error updating chat name in DB:", updateError)
        } else {
          console.log(
            `✅ Chat ${chatId} name updated in DB to: "${generatedTitle}"`
          )
          // Update UI State
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: generatedTitle } : chat
            )
          )
        }
      } else {
        console.warn("⚠️ AI did not return a valid title.")
        // Optional: Fallback zur alten Methode, wenn AI versagt
        const fallbackTitle = generateChatName(firstUserMessage)
        const { error: updateError } = await supabase
          .from("chats")
          .update({ name: fallbackTitle })
          .eq("id", chatId)
        if (!updateError) {
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: fallbackTitle } : chat
            )
          )
        }
      }
    } catch (error) {
      console.error("❌ Error generating or setting chat title:", error)
      // Hier nicht abbrechen, Chat funktioniert trotzdem weiter

      // Fallback zur einfachen Methode bei Fehlern
      try {
        const fallbackTitle = generateChatName(firstUserMessage)
        console.log(`⚠️ Using fallback title due to error: "${fallbackTitle}"`)

        const { error: updateError } = await supabase
          .from("chats")
          .update({ name: fallbackTitle })
          .eq("id", chatId)

        if (!updateError) {
          setChatSessions(prevSessions =>
            prevSessions.map(chat =>
              chat.id === chatId ? { ...chat, name: fallbackTitle } : chat
            )
          )
        }
      } catch (fbError) {
        console.error("❌ Even fallback title setting failed:", fbError)
      }
    }
  }

  // Füge Event-Listener für Klicks außerhalb der Edit-Box hinzu
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        editBoxRef.current &&
        !editBoxRef.current.contains(event.target as Node) &&
        editingMessageId
      ) {
        cancelEditMessage()
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [editingMessageId])

  // Handle Joyride callback
  const handleJoyrideCallback = (data: CallBackProps) => {
    const { action, index, status, type } = data

    if (type === "step:before" && index === 2) {
      // Show fake messages for message actions
      setShowFakeMessagesForTour(true)
      // Instead of continuing with the tour, show our custom dialog
      setShowMessageActionsDialog(true)
      // Pause the tour
      setRunTour(false)
    } else if (type === "step:after" && index === 2) {
      // Clear fake messages after the step
      setShowFakeMessagesForTour(false)
    }

    if (action === "reset" || status === STATUS.FINISHED) {
      setRunTour(false)
      setShowFakeMessagesForTour(false)
      setShowMessageActionsDialog(false)
    }

    if (type === "step:after") {
      setStepIndex(index + 1)
    }
  }

  // Function to start the tour at a specific step
  const startTourAt = (index: number) => {
    setStepIndex(index)
    // Use timeout to ensure UI elements are rendered, especially if sidebar visibility changes
    setTimeout(() => {
      setRunTour(true)
    }, 100) // Small delay might be needed
  }

  // Function to handle "Deep Research" button click
  const handleDeepResearch = async () => {
    if (!inputValue.trim()) return // Do nothing if input is empty

    // Use the enhanced handleSendMessage with web search enabled
    await handleSendMessage(inputValue.trim(), true)
  }

  // Handle PDF export with message selection
  const handleExportPdf = (
    selection: "all" | "last5" | "last10" | number[]
  ) => {
    try {
      const chatName =
        chatSessions.find(chat => chat.id === currentChatId)?.name || "Chat"
      downloadChatAsPdf(messages, chatName, selection)
    } catch (error) {
      console.error("Error exporting chat:", error)
      // You could add an error state and show a notification here
    }
  }

  // Handle chat summary generation
  const handleGenerateSummary = async () => {
    if (messages.length < 2) {
      // Füge eine Nachricht hinzu, wenn nicht genug Nachrichten vorhanden sind
      const errorMessage: Message = {
        id: uuidv4(),
        role: "assistant",
        content: "Es gibt nicht genügend Nachrichten für eine Zusammenfassung.",
        timestamp: new Date()
      }
      setMessages(prevMessages => [...prevMessages, errorMessage])
      return
    }

    // Zeige einen Ladeindikator im Chat
    const loadingMessage: Message = {
      id: uuidv4(),
      role: "assistant",
      content: "Erstelle eine Zusammenfassung des bisherigen Chats...",
      timestamp: new Date(),
      isTypewriting: true
    }

    const loadingMessageId = loadingMessage.id
    setMessages(prevMessages => [...prevMessages, loadingMessage])
    setIsTyping(true)

    try {
      // Generiere die Zusammenfassung
      const summary = await generateChatSummary(messages)

      // Ersetze die Lade-Nachricht mit der tatsächlichen Zusammenfassung
      setMessages(prevMessages =>
        prevMessages.map(msg =>
          msg.id === loadingMessageId
            ? { ...msg, content: summary, isTypewriting: false }
            : msg
        )
      )

      // Speichere die Nachricht in der Datenbank, wenn ein Chat aktiv ist
      if (currentChatId) {
        console.log("💬 Saving summary message for chat:", currentChatId)

        try {
          const { error: messageError } = await supabase
            .from("chat_messages")
            .insert({
              chat_id: currentChatId,
              role: "assistant",
              content: summary,
              user_id: user?.id, // Make sure user_id is included in database insert
              created_at: new Date().toISOString()
            })

          if (messageError) {
            console.error("❌ Error saving summary message:", messageError)
          } else {
            console.log("✅ Summary message saved")
            // REMOVE: Reloading chat list is likely causing the issue
            // if (user) {
            //   await loadChatSessions(user.id, rawWorkspaceId || null);
            // }
          }
        } catch (dbError) {
          console.error("Database error saving summary:", dbError)
        }
      }
    } catch (error) {
      console.error("Error generating summary:", error)

      // Ersetze die Lade-Nachricht mit einer Fehlermeldung
      setMessages(prevMessages =>
        prevMessages.map(msg =>
          msg.id === loadingMessageId
            ? {
                ...msg,
                content:
                  "Bei der Erstellung der Zusammenfassung ist ein Fehler aufgetreten. Bitte versuche es später erneut.",
                isTypewriting: false
              }
            : msg
        )
      )
    } finally {
      setIsTyping(false)
    }
  }

  const chatSessionsWithProjectInfo = chatSessions.map(chat => {
    const assignedProject = projects.find(
      project => chat.project_id === project.id
    )
    return {
      ...chat,
      assignedProjectName: assignedProject?.name || null
    }
  })

  // Nicht zugewiesene Chats filtern - Optimize with proper memoization
  const unassignedChats = useMemo(() => {
    console.debug("Calculating unassigned chats from", chatSessions.length, "available chats");
    return chatSessions.filter(chat => chat.project_id === null);
  }, [chatSessions]); // Only recalculate when chatSessions changes

  // Chats nach Projekten gruppieren - Optimize with proper dependencies
  const chatsByProject = useMemo(() => {
    console.debug("Calculating chats by project from", chatSessions.length, "available chats");
    // Kopiere die Projekte und füge die zugehörigen Chats hinzu
    return projects.map(project => {
      const projectChats = chatSessions.filter(
        chat => chat.project_id === project.id
      );
      console.debug(`Project ${project.name} has ${projectChats.length} chats`);
      return {
        ...project,
        chats: projectChats
      };
    });
  }, [projects, chatSessions]); // Only recalculate when projects or chatSessions change

  // Toggle Funktion für das Aufklappen der Projekte
  const toggleProjectExpansion = (projectId: string) => {
    console.log("Toggling project expansion for", projectId)
    setExpandedProjects(prev => ({
      ...prev,
      [projectId]: !prev[projectId]
    }))

    // Wenn ein Projekt ausgewählt wird, setzen wir es auch als aktives Projekt
    setSelectedProject(projects.find(p => p.id === projectId) || null)
  }

  // Hinzufügen einer Funktion, um anzuzeigen, ob ein Chat geladen ist
  const isActiveChat = (chatId: string): boolean => {
    return currentChatId === chatId
  }

  // Verbesserte Funktion zum Laden eines Chats
  const handleSelectChat = async (chatId: string) => {
    console.log(`Selecting chat: ${chatId}`)

    // Prüfe, ob es ein gültiger Chat ist
    const selectedChat = chatSessions.find(chat => chat.id === chatId)
    if (!selectedChat) {
      console.error(`Chat ${chatId} nicht in aktuellen Chat-Sessions gefunden!`)
      return
    }

    // Setze aktuellen Chat
    setCurrentChatId(chatId)

    // Lade Chat-Inhalte
    await loadChat(chatId)

    // Wenn der Chat zu einem Projekt gehört, stelle sicher, dass das Projekt aufgeklappt ist
    if (selectedChat.project_id) {
      console.log(
        `Chat gehört zu Projekt ${selectedChat.project_id}, klappe auf`
      )
      setExpandedProjects(prev => ({
        ...prev,
        [selectedChat.project_id!]: true
      }))
    }
  }

  if (error) {
    return (
      <div className="flex h-screen items-center justify-center bg-[var(--bg-primary)]">
        <div className="max-w-md rounded-lg border border-[var(--border-light)] bg-[var(--bg-tertiary)] p-6 text-center">
          <h2 className="mb-4 text-xl font-medium text-[var(--text-primary)]">
            Fehler
          </h2>
          <p className="mb-4 text-[var(--text-secondary)]">{error}</p>
          <Link
            href="/login"
            className="inline-flex rounded-md bg-[var(--accent-primary)] px-4 py-2 text-sm font-medium text-white hover:bg-[var(--accent-primary-hover)]"
          >
            Zum Login
          </Link>
        </div>
      </div>
    )
  }

  // Funktion, um einen neuen Chat zu beginnen (ohne ihn sofort zu erstellen)
  const startNewChat = () => {
    // Zurücksetzen des Typing-Status für den neuen Chat
    setHasStartedTyping(false)
    
    // Bisheriger Code
    setMessages([])
    setCurrentChatId(null)
    setEditingMessageId(null)
    setEditingContent("")
    setSelectedTask(null)
    setInputValue("")
    
    // Ensure we're not showing fake messages
    setShowFakeMessagesForTour(false)
    
    // Set isStartingNewChat flag to prevent re-rendering
    isStartingNewChatRef.current = true;
    
    // URL aktualisieren
    const currentPath = window.location.pathname;
    const workspaceQuery = rawWorkspaceId ? `?workspace=${rawWorkspaceId}` : "";
    router.push(`${currentPath}${workspaceQuery}`);
    
    // Fokus auf Inputfeld
    setTimeout(() => {
      if (inputRef.current) {
        inputRef.current.focus();
      }
    }, 100);
  }

  // Add message search functionality
  const handleMessageSearch = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!messageSearchQuery.trim()) return

    try {
      setIsSearching(true)

      // Search in message content - fixed table name from messages to chat_messages
      const { data: messagesData, error: messagesError } = await supabase
        .from("chat_messages")
        .select("id, content, chat_id, created_at, chats(name)")
        .ilike("content", `%${messageSearchQuery}%`)
        .order("created_at", { ascending: false })
        .limit(20)

      if (messagesError) {
        console.error("Fehler bei der Suche in Nachrichten:", messagesError)
      }

      // Combine client-side chat results with server-side message results
      const messageResults = messagesData || []

      // Format message results
      const formattedResults = messageResults.map(result => ({
        id: `message-${result.id}`,
        content: result.content,
        chat_id: result.chat_id,
        created_at: result.created_at,
        chats: result.chats,
        type: "message"
      }))

      // Add any existing client-side filtered chat results
      const existingChatResults = messageSearchResults
        .filter(result => result.id?.startsWith("local-"))
        .map(result => ({ ...result, type: "chat" }))

      // Combine both types of results
      setMessageSearchResults([...formattedResults, ...existingChatResults])
      console.log(
        "Search results:",
        [...formattedResults, ...existingChatResults].length
      )
    } catch (err) {
      console.error("Fehler bei der Suche:", err)
    } finally {
      setIsSearching(false)
    }
  }

  // Update handleSearchInputChange to trigger search automatically after 3+ characters
  const handleSearchInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const query = e.target.value
    setMessageSearchQuery(query)

    // Client-side filtering of visible chats list when typing
    if (query.trim() === "") {
      setMessageSearchResults([])
    } else {
      // Filter chat sessions that match the query and convert to search result format
      const filteredChats = chatSessions
        .filter(chat => chat.name.toLowerCase().includes(query.toLowerCase()))
        .map(chat => ({
          id: `local-${chat.id}`,
          content: "Chat gefunden",
          chat_id: chat.id,
          created_at: chat.created_at,
          chats: { name: chat.name },
          type: "chat"
        }))

      setMessageSearchResults(filteredChats)

      // If query is 3+ characters, automatically trigger the full search
      if (query.trim().length >= 3) {
        // Create a debounced search function to avoid too many API calls
        clearTimeout(searchDebounceTimeout.current)
        searchDebounceTimeout.current = setTimeout(async () => {
          try {
            setIsSearching(true)

            // Search in message content - fixed table name from messages to chat_messages
            const { data: messagesData, error: messagesError } = await supabase
              .from("chat_messages")
              .select("id, content, chat_id, created_at, chats(name)")
              .ilike("content", `%${query}%`)
              .order("created_at", { ascending: false })
              .limit(20)

            if (messagesError) {
              console.error(
                "Fehler bei der Suche in Nachrichten:",
                messagesError
              )
            }

            // Combine client-side chat results with server-side message results
            const messageResults = messagesData || []

            // Format message results
            const formattedResults = messageResults.map(result => ({
              id: `message-${result.id}`,
              content: result.content,
              chat_id: result.chat_id,
              created_at: result.created_at,
              chats: result.chats,
              type: "message"
            }))

            // Combine both types of results
            setMessageSearchResults([...formattedResults, ...filteredChats])
          } catch (err) {
            console.error("Fehler bei der Suche:", err)
          } finally {
            setIsSearching(false)
          }
        }, 300) // 300ms debounce
      }
    }
  }

  const toggleMessageSearch = () => {
    setSearchOpen(!searchOpen)
    if (!searchOpen) {
      setMessageSearchQuery("")
      setMessageSearchResults([])
    }
  }

  const handleImprovePrompt = async () => {
    if (!newTaskSystemPrompt.trim()) return

    try {
      setIsImprovingPrompt(true)

      // Make API call to your reasoning model to improve the prompt
      const response = await fetch("/api/improve-prompt", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          prompt: newTaskSystemPrompt,
          userId: user.id
        })
      })

      if (!response.ok) {
        const errorData = await response.json().catch(() => null)
        const errorMessage =
          errorData?.error || "Fehler beim Verbessern des Prompts"
        console.error("API Error:", errorData)
        throw new Error(errorMessage)
      }

      const data = await response.json()
      setNewTaskSystemPrompt(data.improvedPrompt)

      // Show success message -- Removed alert
      // alert(`Prompt erfolgreich verbessert! (Verwendet: ${data.modelUsed || 'GPT-Modell'})`);
    } catch (error: any) {
      console.error("Error improving prompt:", error)
      alert(
        `Fehler beim Verbessern des Prompts: ${error.message || "Unbekannter Fehler"}`
      )
    } finally {
      setIsImprovingPrompt(false)
    }
  }

  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])

  // Finde und ersetze das useEffect für die Nachrichten-Subscription
  useEffect(() => {
    // Wenn kein Chat ausgewählt ist, nichts tun
    if (!currentChatId) {
      return;
    }
    
    debugLog(`Setting up message subscription for chat: ${currentChatId}`);
    
    // Cleanup function for the channel
    const cleanupChannel = () => {
      if (messagesChannelRef.current && supabase) {
        debugLog("Cleaning up previous message subscription");
        supabase.removeChannel(messagesChannelRef.current);
        messagesChannelRef.current = null;
      }
    };

    // Clean up previous channel before creating a new one
    cleanupChannel();
    
    // Configure realtime channel for chat_messages
    const channelId = `chat_messages_${currentChatId}`;
    const messagesChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "*", // INSERT, UPDATE, DELETE
          schema: "public",
          table: "chat_messages",
          filter: `chat_id=eq.${currentChatId}`
        },
        payload => {
          debugLog(`Realtime message update received for chat ${currentChatId}:`, payload.eventType);

          // Only handle new message insertions
          if (payload.eventType === "INSERT") {
            const newMsg = payload.new;
            
            // *** CRITICAL: Prevent duplicate messages by checking if we've processed this ID already
            if (processedMessageIds.has(newMsg.id)) {
              debugLog(`Skipping already processed message with ID: ${newMsg.id}`);
              return;
            }
            
            // Add to processed set
            processedMessageIds.add(newMsg.id);
            
            // Check if message from another user (not from this client)
            const msgSentByOtherUser = newMsg.user_id && newMsg.user_id !== user?.id;
            
            setMessages(prevMessages => {
              // Double-check for duplicate messages by content and timestamp
              const exists = prevMessages.some(
                msg =>
                  (msg.id === newMsg.id) || // Same ID 
                  (msg.content === newMsg.content &&
                  msg.role === newMsg.role &&
                  new Date(msg.timestamp).getTime() > Date.now() - 5000) // Recent similar message
              );

              if (!exists) {
                debugLog("Adding new message from realtime subscription");
                
                // Process content - strip date prefix if present
                let messageContent = newMsg.content;
                if (messageContent && typeof messageContent === 'string' && messageContent.startsWith('[Datum:') && messageContent.includes(']\n')) {
                  messageContent = messageContent.replace(/^\[Datum:[^\]]+\]\n/, '');
                }
                
                return [
                  ...prevMessages,
                  {
                    id: newMsg.id || uuidv4(),
                    role: newMsg.role as "user" | "assistant" | "system",
                    content: messageContent,
                    timestamp: new Date(newMsg.created_at),
                    user_id: newMsg.user_id,
                    sentfrom: newMsg.sentfrom
                  }
                ];
              }
              return prevMessages;
            });
          }
        }
      )
      .subscribe((status) => {
        debugLog(`Message subscription status for ${channelId}: ${status}`);
      });
    
    // Store the channel in the ref
    messagesChannelRef.current = messagesChannel;

    // Cleanup on unmount or when currentChatId changes
    return cleanupChannel;
  }, [currentChatId, supabase, user?.id]);

  // Realtime subscription für Änderungen an Chats (insbesondere Projekt-Zuordnungen)
  useEffect(() => {
    // Wenn bereits eine Subscription existiert, nichts tun
    if (chatsChannelRef.current) {
      console.log("Chats subscription already exists, skipping creation");
      return;
    }

    if (user && supabase) {
      // Verwende einen konsistenten Namen
      const channelId = `chats_updates_global`;
      console.log(`Setting up realtime subscription for chats table: ${channelId}`);

      // Konfiguriere den Realtime-Channel für die chats Tabelle
      const chatsChannel = supabase
        .channel(channelId)
        .on(
          "postgres_changes",
          {
            event: "UPDATE", // Nur Updates überwachen
            schema: "public",
            table: "chats"
          },
          payload => {
            console.log("Realtime chat update received:", payload);

            // Aktualisiere den lokalen State, wenn sich ein Chat ändert
            if (payload.eventType === "UPDATE") {
              const updatedChat = payload.new;

              // Aktualisiere den chatSessions-State
              setChatSessions(prevSessions => {
                // Avoid state updates if nothing changed
                const chatNeedsUpdate = prevSessions.some(
                  chat => 
                    chat.id === updatedChat.id && 
                    (chat.name !== updatedChat.name || chat.project_id !== updatedChat.project_id)
                );
                
                if (!chatNeedsUpdate) {
                  return prevSessions;
                }
                
                return prevSessions.map(chat =>
                  chat.id === updatedChat.id
                    ? {
                        ...chat,
                        name: updatedChat.name,
                        project_id: updatedChat.project_id
                      }
                    : chat
                );
              });
            }
          }
        )
        .subscribe((status) => {
          console.log(`Subscription status for ${channelId}:`, status);
        });
      
      // Speichere den Channel in der Ref
      chatsChannelRef.current = chatsChannel;

      // Cleanup beim Unmount oder wenn der Komponent neu geladen wird
      return () => {
        if (chatsChannelRef.current && supabase) {
          console.log("Cleaning up chats table subscription");
          supabase.removeChannel(chatsChannelRef.current);
          chatsChannelRef.current = null;
        }
      };
    }
    
    // Leere Cleanup-Funktion zurückgeben, wenn keine Subscription erstellt wurde
    return () => {};
  }, [user, supabase]);  // Reduzierte Abhängigkeiten

  // Hilfsfunktion, um Initialen aus User-ID oder E-Mail zu extrahieren
  const getUserInitials = (userId: string | undefined): string => {
    if (!userId) return "?"

    // Einfache Extraktionslogik - nimmt die ersten 2 Zeichen der userId
    // In einer realen Anwendung würde man hier den Namen des Benutzers abrufen
    return userId.substring(0, 2).toUpperCase()
  }

  // Funktion zum Erstellen und Speichern von Embeddings
  const createEmbedding = async (
    message: Message,
    chatId: string | null,
    workspaceId: string | null = null
  ) => {
    try {
      console.log("🔄 Erstelle Embedding für Nachricht:", message.id)

      // UUID-Validierung: Überprüfe, ob message.id ein gültiger String ist
      if (
        !message.id ||
        typeof message.id !== "string" ||
        message.id.trim() === ""
      ) {
        console.error("❌ Ungültige message.id für Embedding:", message.id)
        console.error("Message Objekt:", JSON.stringify(message, null, 2))
        return null // Früher Abbruch bei ungültiger ID
      }

      console.log("📨 Original Nachrichteninhalt:", message.content)

      // Current date formatted for embedding
      const currentDate = new Date().toISOString().split("T")[0] // Format: YYYY-MM-DD

      // Append date information to the content for embedding
      const contentWithDate = `[Datum: ${currentDate}]\n${message.content}`
      console.log(
        "📅 Nachrichteninhalt mit Datum für Embedding:",
        contentWithDate
      )

      // Wenn dies nur ein Embedding für die Suche ist (chatId ist null),
      // dann erstellen wir nur das Embedding ohne es zu speichern
      const isSearchOnly = chatId === null

      // OpenAI API für Embedding aufrufen
      console.log(
        "🧠 Embedding wird generiert für Inhalt mit Länge:",
        contentWithDate.length
      )
      const response = await fetch("/api/embeddings", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          input: contentWithDate
        })
      })

      if (!response.ok) {
        throw new Error(`Embedding API responded with ${response.status}`)
      }

      const embeddingData = await response.json()
      console.log("✅ Embedding erfolgreich generiert:")
      console.log("📊 Embedding-Dimensionen:", embeddingData.embedding.length)
      console.log(
        "🔍 Embedding-Vorschau (erste 5 Werte):",
        embeddingData.embedding.slice(0, 5)
      )
      console.log(
        "🔍 Embedding-Vorschau (letzte 5 Werte):",
        embeddingData.embedding.slice(-5)
      )

      // Für Suchanfragen frühzeitig zurückkehren, ohne zu speichern
      if (isSearchOnly) {
        console.log(
          "ℹ️ Suchmodus: Embedding wird nur generiert, nicht gespeichert"
        )
        return embeddingData.embedding
      }

      // Validiere chatId
      if (!chatId || typeof chatId !== "string" || chatId.trim() === "") {
        console.error("❌ Ungültige chatId für Embedding:", chatId)
        return null // Früher Abbruch bei ungültiger chatId
      }

      // In der Datenbank speichern
      const dbPayload = {
        message_id: message.id,
        chat_id: chatId,
        workspace_id: workspaceId || null, // Stelle sicher, dass null und nicht Leerstring gespeichert wird
        role: message.role,
        embedding: embeddingData.embedding,
        content_with_date: contentWithDate // Store the content with date in the new column
      }

      console.log("💾 Speichere in DB mit Payload:", {
        message_id: dbPayload.message_id,
        chat_id: dbPayload.chat_id,
        workspace_id: dbPayload.workspace_id,
        role: dbPayload.role,
        content_with_date: contentWithDate.substring(0, 50) + "...", // Log truncated for readability
        embedding_length: embeddingData.embedding.length
      })

      const { data, error } = await supabase
        .from("message_embeddings")
        .insert(dbPayload)
        .select()

      if (error) {
        console.error("❌ Fehler beim Speichern des Embeddings:", error)
        throw error
      }
      console.log("✅ Embedding gespeichert für Nachricht:", message.id)
      if (data) {
        console.log("📝 DB-Eintrag erstellt mit ID:", data[0]?.id)
      }

      return embeddingData.embedding
    } catch (error) {
      console.error("❌ Fehler beim Erstellen des Embeddings:", error)
      return null
    }
  }

  // Funktion zum Finden ähnlicher Nachrichten für einen *Benutzer*
  const findSimilarMessages = async (query: string, userId: string) => {
    // Stelle sicher, dass eine userId vorhanden ist
    if (!userId) {
      console.error(
        "❌ User ID fehlt für die Suche nach ähnlichen Nachrichten."
      )
      return []
    }

    try {
      console.log(`🔍 Suche nach ähnlichen Nachrichten für User ${userId}`)
      console.log(`📝 Suchanfrage: "${query}"`)

      // Embedding für die Abfrage erstellen
      console.log("🧠 Generiere Embedding für Suchanfrage...")
      const response = await fetch("/api/embeddings", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          input: query
        })
      })

      if (!response.ok) {
        throw new Error(`Embedding API responded with ${response.status}`)
      }

      const embeddingData = await response.json()
      console.log("✅ Embedding für Abfrage erfolgreich generiert")
      console.log(
        "📊 Query-Embedding-Dimensionen:",
        embeddingData.embedding.length
      )
      console.log(
        "🔍 Query-Embedding-Vorschau (erste 5 Werte):",
        embeddingData.embedding.slice(0, 5)
      )

      // Ähnliche Nachrichten mit *neuer* Stored Procedure finden
      console.log(
        `📞 Rufe search_similar_messages RPC für User ${userId} auf (Schwellwert: 0.7, Max Ergebnisse: 10)`
      )
      const { data, error } = await supabase.rpc("search_similar_messages", {
        query_embedding: embeddingData.embedding,
        p_user_id: userId, // Übergabe der User ID
        similarity_threshold: 0.7, // Erhöht von 0.3 auf 0.7 für präzisere Ergebnisse
        max_results: 10
      })

      if (error) {
        console.error("❌ Fehler in search_similar_messages RPC:", error)
        throw error
      }

      console.log(`🔎 RPC Ergebnis: ${data?.length || 0} Nachrichten gefunden`)
      if (data && data.length > 0) {
        console.log("📋 Erste Ergebnisse (Rohdaten):", data.slice(0, 2))
      }

      // Filtere die Ergebnisse: Behalte Kontext-Nachrichten und ignoriere zu ähnliche primäre Nachrichten
      const filteredData =
        data?.filter(
          (m: any) =>
            m.is_context || // immer Kontext-Nachrichten behalten
            m.similarity < 0.99 // Nur Hauptnachrichten filtern, nicht Kontext
        ) || []

      console.log(`🧹 Nach Filterung: ${filteredData.length} Nachrichten übrig`)

      // Process messages to extract date information if present
      console.log(
        "🔄 Verarbeite Nachrichten, um Datumsinformationen zu extrahieren..."
      )
      const processedData = filteredData.map((m: any) => {
        let displayContent = m.content
        let dateInfo = null

        // Extract date information if it's included in the format [Datum: YYYY-MM-DD]
        const dateMatch = m.content.match(/\[Datum: (\d{4}-\d{2}-\d{2})\]/)
        if (dateMatch) {
          dateInfo = dateMatch[1]
          // Remove the date prefix for display
          displayContent = m.content.replace(
            /\[Datum: \d{4}-\d{2}-\d{2}\]\n/,
            ""
          )
          console.log(
            `📅 Datum gefunden in Nachricht ${m.message_id}: ${dateInfo}`
          )
        } else {
          console.log(`⚠️ Kein Datum gefunden in Nachricht ${m.message_id}`)
        }

        return {
          ...m,
          displayContent,
          dateInfo,
          isContext: m.is_context || false // Übernehme das Kontext-Flag
        }
      })

      console.log(
        `✅ ${processedData.length} ähnliche Nachrichten nach Filterung gefunden`
      )

      // Gruppiere zusammengehörige Nachrichten für bessere Übersicht in Logs
      const contextGroups = new Map()

      processedData.forEach((m: any, index: number) => {
        const contextKey = m.isContext ? "context" : `main-${index}`

        console.log(
          `🔹 ${m.isContext ? "Kontext-Nachricht" : "Ergebnis"} #${index + 1}:`
        )
        console.log(`  • ID: ${m.message_id}`)
        console.log(`  • Chat: ${m.chat_id}`)
        console.log(`  • Rolle: ${m.role}`)
        console.log(`  • Datum: ${m.dateInfo || "Keines"}`)
        console.log(
          `  • Ähnlichkeit: ${m.similarity.toFixed(4)}${m.isContext ? " (Kontext)" : ""}`
        )
        console.log(
          `  • Inhalt: ${(m.displayContent || m.content).substring(0, 100)}${(m.displayContent || m.content).length > 100 ? "..." : ""}`
        )
      })

      // Sortiere die Ergebnisse: Primäre Nachricht, dann Kontext
      processedData.sort((a: any, b: any) => {
        // Behalte die bestehende Sortierung bei
        return a.isContext === b.isContext
          ? b.similarity - a.similarity // Bei gleichem Typ: Nach Ähnlichkeit absteigend
          : a.isContext
            ? 1
            : -1 // Primäre Nachrichten zuerst
      })

      return processedData
    } catch (error) {
      console.error("❌ Fehler beim Suchen ähnlicher Nachrichten:", error)
      return []
    }
  }

  // Neue state-Variable, um zu verfolgen, ob der Benutzer bereits angefangen hat zu tippen
  const [hasStartedTyping, setHasStartedTyping] = useState(false)

  return (
    <div className="flex h-screen overflow-hidden bg-[#1e1e1e]">
      {/* Use DynamicJoyride instead of Joyride */}
      <DynamicJoyride
        steps={tourSteps}
        run={runTour}
        stepIndex={stepIndex}
        callback={handleJoyrideCallback}
        continuous={true}
        showProgress={false}
        showSkipButton={true}
        locale={{
          back: "Zurück",
          close: "Schließen",
          last: "Fertig",
          next: "Weiter",
          skip: "Überspringen"
        }}
        disableOverlayClose={true}
        styles={{
          options: {
            zIndex: 10000,
            arrowColor: "#333333",
            backgroundColor: "#1e1e1e",
            primaryColor: "#ffffff",
            textColor: "#cccccc"
          },
          tooltipContainer: {
            textAlign: "left"
          },
          buttonNext: {
            backgroundColor: "#555555"
          },
          buttonBack: {
            marginRight: 10
          }
        }}
      />

      {/* Sidebar */}
      {showSidebar && (
        <aside
          id="chat-sidebar"
          className="flex h-screen shrink-0 flex-col rounded-r-xl border-r border-[#333333] bg-[#0d0d0d] p-0"
          style={{ width: "305px" }}
        >
          <div className="flex items-center justify-between border-b border-[#333333] p-4">
            {/* Replace H1 with Home Button */}
            <button
              onClick={() => router.push("/dashboard")}
              className="rounded p-1.5 text-gray-400 hover:bg-[#2d2d2d] hover:text-white"
              title="Dashboard"
            >
              <Home size={18} />
            </button>
            <div className="flex items-center space-x-2">
              {/* Search and Add buttons remain here */}
              <button
                onClick={toggleMessageSearch} // Corrected: Use toggleMessageSearch
                className="rounded p-1.5 text-gray-400 hover:bg-gray-800 hover:text-white"
                aria-label="Chats durchsuchen"
              >
                <Search size={16} />
              </button>
              <button
                id="new-chat-button"
                onClick={startNewChat}
                className="rounded p-1.5 text-gray-400 hover:bg-gray-800 hover:text-white"
                aria-label="Neuer Chat"
              >
                <Plus size={16} />
              </button>
            </div>
          </div>

          {/* Search Panel */}
          {searchOpen && (
            <div className="border-b border-[#333333] px-3 py-2">
              <form onSubmit={handleMessageSearch} className="mb-2">
                <div className="relative">
                  <input
                    type="text"
                    value={messageSearchQuery}
                    onChange={handleSearchInputChange}
                    placeholder="Suche in Chats..."
                    className="w-full rounded-md border border-[#333333] bg-[#1a1a1a] px-3 py-1.5 text-xs text-white focus:outline-none"
                    autoFocus
                  />
                  <button
                    type="submit"
                    className="absolute right-2 top-1/2 -translate-y-1/2"
                    disabled={isSearching}
                  >
                    <Search className="size-3 text-gray-400" />
                  </button>
                </div>
              </form>

              {isSearching ? (
                <div className="py-2 text-center">
                  <div className="inline-block size-3 animate-spin rounded-full border-2 border-gray-400 border-t-transparent"></div>
                </div>
              ) : messageSearchResults.length > 0 ? (
                <div className="max-h-60 overflow-y-auto rounded-md border border-[#333333] bg-[#1a1a1a]">
                  {messageSearchResults.map(result => (
                    <div
                      key={result.id}
                      onClick={() => {
                        if (result.chat_id) {
                          // Die neue Funktion verwenden, statt direkter API-Aufrufe
                          handleSelectChat(result.chat_id)
                          // Close search after selecting a result
                          setSearchOpen(false)
                        }
                      }}
                      className="block cursor-pointer border-b border-[#333333] p-2 last:border-0 hover:bg-[#272727]"
                    >
                      <div className="mb-1 flex items-center text-xs font-medium text-white">
                        {result.type === "chat" ? (
                          <>
                            <MessageCircle className="mr-1 size-3 text-gray-300" />
                            <span>Chat: {result.chats?.name || "Chat"}</span>
                          </>
                        ) : (
                          <>
                            <FileText className="mr-1 size-3 text-gray-400" />
                            <span>
                              Nachricht in: {result.chats?.name || "Chat"}
                            </span>
                          </>
                        )}
                      </div>
                      <p className="line-clamp-2 text-xs text-gray-400">
                        {result.type === "chat"
                          ? "Chat mit diesem Namen gefunden"
                          : result.content}
                      </p>
                      <div className="mt-1 text-[10px] text-gray-500">
                        {new Date(result.created_at).toLocaleString()}
                      </div>
                    </div>
                  ))}
                </div>
              ) : messageSearchQuery && !isSearching ? (
                <div className="py-2 text-center text-xs text-gray-400">
                  Keine Ergebnisse gefunden
                </div>
              ) : null}
            </div>
          )}

          {/* Chat List */}
          <div className="custom-scrollbar scrollbar-hide grow overflow-y-auto p-3">
            <div className="mb-4">
              <h2 className="mb-2 text-sm font-semibold uppercase text-[#999999]">
                Chats
              </h2>
              <div className="space-y-1">
                {unassignedChats.map(chatSession => (
                  <div
                    key={chatSession.id}
                    className="group flex items-center"
                    draggable="true"
                    onDragStart={e => {
                      e.dataTransfer.setData("chatId", chatSession.id)
                      setDraggedChatId(chatSession.id)
                    }}
                    onDragEnd={() => setDraggedChatId(null)}
                  >
                    <button
                      onClick={() => handleSelectChat(chatSession.id)}
                      className={cn(
                        "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                        isActiveChat(chatSession.id)
                          ? "bg-[#2d2d2d] text-white"
                          : "text-[#cccccc] hover:bg-[#222222]"
                      )}
                      style={{ maxWidth: "calc(100% - 40px)" }}
                    >
                      {editingChatId === chatSession.id ? (
                        <input
                          type="text"
                          value={newChatName}
                          onChange={e => setNewChatName(e.target.value)}
                          onBlur={handleInlineEditBlur}
                          onKeyDown={handleInlineEditKeyDown}
                          className="w-full rounded border border-[#444444] bg-[#333333] px-2 py-0.5 text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                          autoFocus
                          onClick={e => e.stopPropagation()}
                        />
                      ) : (
                        <div className="flex items-center">
                          <span
                            className="block flex-1 truncate"
                            title={chatSession.name}
                          >
                            {chatSession.name}
                          </span>
                          {chatSession.user_id &&
                            chatSession.user_id !== user?.id && (
                              <span
                                className="ml-2 flex size-5 items-center justify-center rounded-full bg-gray-700 text-xs text-gray-300"
                                title={`Erstellt von ${chatSession.user_id}`}
                              >
                                {getUserInitials(chatSession.user_id)}
                              </span>
                            )}
                        </div>
                      )}
                    </button>
                    <div className="ml-1 flex min-w-[60px] opacity-0 transition-opacity group-hover:opacity-100">
                      <button
                        onClick={e => startInlineEdit(chatSession, e)}
                        className="p-1 text-[#cccccc] hover:text-white"
                        title="Umbenennen"
                      >
                        <Edit size={14} />
                      </button>
                      <button
                        onClick={e => {
                          e.stopPropagation()
                          deleteChat(chatSession.id)
                        }}
                        className="p-1 text-[#cccccc] hover:text-red-500"
                        title="Löschen"
                      >
                        <Trash size={14} />
                      </button>
                    </div>
                  </div>
                ))}

                {unassignedChats.length === 0 && (
                  <div className="px-3 py-2 text-xs italic text-[#666666]">
                    Keine freien Chats
                  </div>
                )}
              </div>
              {/* Remove redundant "Neuer Chat" button since we already have one at the top of the sidebar */}
            </div>

            <div className="mt-6">
              <h2 className="mb-2 text-sm font-semibold uppercase text-[#999999]">
                Projekte
              </h2>
              <div className="space-y-1">
                {chatsByProject.map(project => (
                  <div key={project.id} className="mb-1">
                    <div
                      className="group flex items-center"
                      onDragOver={e => {
                        e.preventDefault()
                        setActiveDropTarget(project.id)
                      }}
                      onDragLeave={() => setActiveDropTarget(null)}
                      onDrop={e => {
                        e.preventDefault()
                        const chatId = e.dataTransfer.getData("chatId")
                        if (chatId) {
                          assignChatToProject(chatId, project.id)
                        }
                        setActiveDropTarget(null)
                      }}
                    >
                      <button
                        onClick={() => toggleProjectExpansion(project.id)}
                        className={cn(
                          "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                          selectedProject?.id === project.id
                            ? "bg-[#2d2d2d] text-white"
                            : "text-[#cccccc] hover:bg-[#222222]",
                          activeDropTarget === project.id &&
                            "border border-white/40 bg-[#2d2d2d]"
                        )}
                        style={{ maxWidth: "calc(100% - 40px)" }}
                      >
                        <span className="flex items-center">
                          {expandedProjects[project.id] ? (
                            <ChevronDown size={16} className="mr-2 min-w-4" />
                          ) : (
                            <ChevronRight size={16} className="mr-2 min-w-4" />
                          )}
                          <span className="block truncate" title={project.name}>
                            {project.name}
                          </span>
                          {project.chats.length > 0 && (
                            <span className="ml-2 text-xs text-gray-400">
                              ({project.chats.length})
                            </span>
                          )}
                        </span>
                      </button>
                      <div className="relative ml-1">
                        <button
                          onClick={e => {
                            e.stopPropagation()
                            setProjectMenuOpen(
                              project.id === projectMenuOpen ? null : project.id
                            )
                          }}
                          className="p-1 text-[#cccccc] opacity-0 transition-opacity hover:text-white group-hover:opacity-100"
                          data-project-menu="trigger"
                        >
                          <MoreVertical size={16} />
                        </button>
                        {projectMenuOpen === project.id && (
                          <div
                            className="absolute right-0 top-full z-10 mt-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg"
                            data-project-menu="content"
                          >
                            <button
                              onClick={e => {
                                e.stopPropagation()
                                // Projekt-Bearbeitung implementieren
                                setProjectToRename(project)
                                setNewProjectName(project.name)
                                setNewProjectDescription(
                                  project.description || ""
                                )
                                setShowProjectModal(true)
                              }}
                              className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                            >
                              <Edit size={16} className="mr-2" />
                              Bearbeiten
                            </button>
                            <button
                              onClick={e => {
                                e.stopPropagation()
                                deleteProject(project.id)
                              }}
                              className="flex w-full items-center px-4 py-2 text-sm text-red-500 hover:bg-[#2d2d2d]"
                            >
                              <Trash size={16} className="mr-2" />
                              Löschen
                            </button>
                          </div>
                        )}
                      </div>
                    </div>

                    {/* Projektzugewiesene Chats anzeigen, wenn Projekt aufgeklappt ist */}
                    {expandedProjects[project.id] &&
                      project.chats.length > 0 && (
                        <div className="mt-1 space-y-1 pl-6">
                          {project.chats.map(chatSession => (
                            <div
                              key={chatSession.id}
                              className="group flex items-center"
                            >
                              <button
                                onClick={() => handleSelectChat(chatSession.id)}
                                className={cn(
                                  "flex-1 overflow-hidden rounded-lg px-3 py-2 text-left text-sm transition-colors",
                                  isActiveChat(chatSession.id)
                                    ? "bg-[#2d2d2d] text-white"
                                    : "text-[#cccccc] hover:bg-[#222222]"
                                )}
                                style={{ maxWidth: "calc(100% - 70px)" }}
                              >
                                {editingChatId === chatSession.id ? (
                                  <input
                                    type="text"
                                    value={newChatName}
                                    onChange={e =>
                                      setNewChatName(e.target.value)
                                    }
                                    onBlur={handleInlineEditBlur}
                                    onKeyDown={handleInlineEditKeyDown}
                                    className="w-full rounded border border-[#444444] bg-[#333333] px-2 py-0.5 text-white focus:outline-none focus:ring-1 focus:ring-blue-500"
                                    autoFocus
                                    onClick={e => e.stopPropagation()}
                                  />
                                ) : (
                                  <div className="flex items-center">
                                    <span
                                      className="block flex-1 truncate"
                                      title={chatSession.name}
                                    >
                                      {chatSession.name}
                                    </span>
                                    {chatSession.user_id &&
                                      chatSession.user_id !== user?.id && (
                                        <span
                                          className="ml-2 flex size-5 items-center justify-center rounded-full bg-gray-700 text-xs text-gray-300"
                                          title={`Erstellt von ${chatSession.user_id}`}
                                        >
                                          {getUserInitials(chatSession.user_id)}
                                        </span>
                                      )}
                                  </div>
                                )}
                              </button>
                              <div className="ml-1 flex min-w-[60px] opacity-0 transition-opacity group-hover:opacity-100">
                                <button
                                  onClick={e => startInlineEdit(chatSession, e)}
                                  className="p-1 text-[#cccccc] hover:text-white"
                                  title="Umbenennen"
                                >
                                  <Edit size={14} />
                                </button>
                                <button
                                  onClick={e => {
                                    e.stopPropagation()
                                    // Von Projekt entfernen
                                    assignChatToProject(chatSession.id, null)
                                  }}
                                  className="p-1 text-[#cccccc] hover:text-white"
                                  title="Von Projekt entfernen"
                                >
                                  <FileText size={14} />
                                </button>
                                <button
                                  onClick={e => {
                                    e.stopPropagation()
                                    deleteChat(chatSession.id)
                                  }}
                                  className="p-1 text-[#cccccc] hover:text-red-500"
                                  title="Löschen"
                                >
                                  <Trash size={14} />
                                </button>
                              </div>
                            </div>
                          ))}
                        </div>
                      )}
                  </div>
                ))}

                {chatsByProject.length === 0 && (
                  <div className="px-3 py-2 text-xs italic text-[#666666]">
                    Keine Projekte gefunden
                  </div>
                )}
              </div>
              <button
                onClick={() => setShowProjectModal(true)}
                className="mt-2 flex w-full items-center rounded-lg px-3 py-2 text-sm text-[#cccccc] hover:bg-[#222222]"
              >
                <Plus size={16} className="mr-2" />
                Neues Projekt
              </button>
            </div>
          </div>

          {/* User Section */}
          <div className="mt-auto border-t border-[#333333] p-3">
            <button
              onClick={() => setShowSettingsModal(true)}
              className="flex w-full items-center rounded-lg px-3 py-2 text-sm text-[#cccccc] hover:bg-[#222222]"
            >
              <User size={16} className="mr-2" />
              <span className="grow truncate text-left text-xs">
                {user?.email || "Kein Benutzer"}
              </span>
              <Settings size={16} />
            </button>
          </div>
        </aside>
      )}

      {/* Main Content Area */}
      <main className="flex flex-1 flex-col overflow-hidden">
        {/* Header */}
        <header className="flex h-14 items-center justify-between border-b border-neutral-700 bg-neutral-900 px-4">
          <div className="flex items-center space-x-4">
            {/* Back button is removed, H1 is the first item */}
            <h1 className="text-xl font-semibold text-white">
              {selectedTask
                ? selectedTask.title
                : chatSessions.find(chat => chat.id === currentChatId)?.name ||
                  "Neuer Chat"}
            </h1>
          </div>
          <div className="flex items-center space-x-4">
            {/* Knowledge Base Selector - Added here */}
            {user && (
              <div className="relative" id="kb-select-container">
                <KnowledgeBaseSelector
                  userId={user.id}
                  selectedKnowledgeBaseId={selectedKnowledgeBaseId}
                  onSelectKnowledgeBase={setSelectedKnowledgeBaseId}
                  isCompact={true}
                />
              </div>
            )}

            {/* Model Selection Dropdown */}
            <div
              className="relative"
              ref={modelDropdownRef}
              id="model-select-button"
            >
              <button
                onClick={() =>
                  !selectedTask && setShowModelDropdown(!showModelDropdown)
                }
                className={`flex items-center space-x-2 rounded-lg border border-[#333333] px-3 py-1.5 text-sm ${
                  selectedTask
                    ? "cursor-not-allowed text-[#666666]"
                    : "cursor-pointer text-[#cccccc] transition-all hover:border-[#444444] hover:text-white"
                }`}
              >
                <span>
                  {selectedTask
                    ? `${getModelLabel(selectedModel)} (in Task festgelegt)`
                    : getModelLabel(selectedModel)}
                </span>
                {!selectedTask && <ChevronDown size={16} />}
              </button>

              {showModelDropdown && !selectedTask && (
                <div className="absolute right-0 top-full z-10 mt-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg">
                  {/* Button for Basic - Verwende den Label-Namen "Basic" */}
                  <button
                    onClick={() => {
                      setSelectedModel("Basic")
                      setShowModelDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    Basic
                  </button>
                  {/* Button for Fast - Verwende den Label-Namen "Fast" */}
                  <button
                    onClick={() => {
                      setSelectedModel("Fast")
                      setShowModelDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    Fast
                  </button>
                  {/* Button for Reason - Verwende den Label-Namen "Reason" */}
                  <button
                    onClick={() => {
                      setSelectedModel("Reason")
                      setShowModelDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    Reason
                  </button>
                  {/* Button for Reason+ - Verwende den Label-Namen "Reason+" */}
                  <button
                    onClick={() => {
                      setSelectedModel("Reason+")
                      setShowModelDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    Reason+
                  </button>
                </div>
              )}
            </div>

            {/* Task Selection Dropdown */}
            <div
              className="relative"
              ref={taskDropdownRef}
              id="task-select-button"
            >
              <div className="flex items-center">
                <button
                  onClick={() => setShowTaskDropdown(!showTaskDropdown)}
                  disabled={isTaskSwitching}
                  className="flex items-center space-x-2 rounded-lg border border-[#333333] px-3 py-1.5 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white disabled:cursor-not-allowed disabled:opacity-50"
                >
                  <span>
                    {selectedTask ? selectedTask.title : "Task auswählen"}
                  </span>
                  <ChevronDown size={16} />
                </button>

                {isTaskSwitching && (
                  <div className="ml-2">
                    <div className="size-4 animate-spin rounded-full border-2 border-white border-t-transparent"></div>
                  </div>
                )}
              </div>

              {showTaskDropdown && (
                <div className="absolute right-0 top-full z-10 mt-1 w-64 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg">
                  <button
                    onClick={() => {
                      setIsTaskSwitching(true)
                      setSelectedTask(null)
                      setShowTaskDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    Kein Task
                  </button>
                  <div className="my-1 border-t border-[#333333]"></div>
                  {tasks.map(task => (
                    <button
                      key={task.id}
                      onClick={() => {
                        setIsTaskSwitching(true)
                        setSelectedTask(task)
                        setShowTaskDropdown(false)
                      }}
                      className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                    >
                      {task.title}
                    </button>
                  ))}
                  <div className="my-1 border-t border-[#333333]"></div>
                  <button
                    onClick={() => {
                      setShowTaskModal(true)
                      setShowTaskDropdown(false)
                    }}
                    className="flex w-full items-center bg-[#1e1e1e] px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                  >
                    <Plus size={16} className="mr-2" />
                    Neuer Task
                  </button>
                </div>
              )}
            </div>
          </div>
        </header>

        {/* Message Area */}
        <div
          id="message-area-wrapper"
          ref={chatBodyRef}
          className="flex w-full flex-1 justify-center overflow-y-auto"
        >
          <div
            className="w-full"
            style={{ maxWidth: "90%", width: "100%", margin: "0 auto" }}
          >
            {/* Start Screen with Info Buttons */}
            {messages.length === 0 && !runTour && !showFakeMessagesForTour && !inputValue.trim() && !isTyping && !messageUpdatePending && !hasStartedTyping && (
              <div className="flex h-full flex-col items-center justify-center text-center">
                <h2 className="mb-4 text-2xl font-bold text-white">
                  Entdecken Sie die Funktionen dieses Chats
                </h2>
                <div className="grid max-w-2xl grid-cols-2 gap-4">
                  <button
                    key="tour-tasks"
                    className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]"
                    onClick={() => startTourAt(0)}
                  >
                    {infoItems[0].title}
                  </button>
                  <button
                    key="tour-model"
                    className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]"
                    onClick={() => startTourAt(1)}
                  >
                    {infoItems[1].title}
                  </button>
                  <button
                    key="tour-messages"
                    className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]"
                    onClick={() => startTourAt(2)}
                  >
                    {infoItems[2].title}
                  </button>
                  <button
                    key="tour-chats"
                    className="rounded-lg bg-[#2d2d2d] p-4 text-left text-sm text-[#cccccc] transition-colors hover:bg-[#333333]"
                    onClick={() => startTourAt(3)}
                  >
                    {infoItems[3].title}
                  </button>
                </div>
              </div>
            )}

            {/* Real Messages */}
            {!showFakeMessagesForTour &&
              messages
                .filter(message => message.role !== "system")
                .map(message => (
                  <div
                    key={message.id}
                    className={`group mb-1 flex flex-col ${
                      message.role === "user" ? "items-end" : "items-start"
                    }`}
                  >
                    {/* Sender and timestamp */}
                    <div
                      className={`mb-0 text-xs ${message.role === "user" ? "text-right" : "text-left"} text-gray-400`}
                    >
                      {message.role === "user"
                        ? message.sentfrom
                          ? message.sentfrom // Use sentfrom if available
                          : message.user_id === user?.id
                            ? userFullName
                            : message.user_id &&
                                userNamesMap &&
                                userNamesMap[message.user_id]
                              ? userNamesMap[message.user_id]
                              : message.user_id
                                ? `Benutzer ${message.user_id.substring(0, 4)}`
                                : "Anderer Benutzer"
                        : message.sentfrom
                          ? message.sentfrom // Use sentfrom for assistant too
                          : "KI-Assistent"}{" "}
                      {message.timestamp.toLocaleTimeString("de-DE", {
                        hour: "2-digit",
                        minute: "2-digit",
                        second: "2-digit"
                      })}
                    </div>

                    {/* Message content or edit box */}
                    {editingMessageId === message.id ? (
                      <div
                        ref={editBoxRef}
                        className="flex w-full max-w-[60%] flex-col items-end"
                      >
                        <textarea
                          value={editingContent}
                          onChange={e => setEditingContent(e.target.value)}
                          className="mb-2 w-full resize-none rounded-lg border border-[#444] bg-[#3a3a3a] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#555]"
                          rows={3}
                          autoFocus
                        />
                        <div className="self-end">
                          <button
                            onClick={handleSaveEdit}
                            disabled={!editingContent.trim()}
                            className={`rounded-lg px-4 py-2 text-sm ${
                              !editingContent.trim()
                                ? "cursor-not-allowed text-[#666666]"
                                : "border border-[#444] bg-[#2d2d2d] text-[#cccccc] hover:border-[#555] hover:text-white"
                            }`}
                          >
                            Senden
                          </button>
                        </div>
                      </div>
                    ) : (
                      <div
                        className={`max-w-[60%] rounded-lg overflow-hidden ${message.role === "user" ? "user-message bg-blue-600 text-white" : "assistant-message bg-zinc-800 text-white"}`}
                      >
                        {message.role === "assistant" && message.isTypewriting ? (
                          <div className="p-1">
                          <RevealEffect
                            content={message.content}
                            onComplete={() => handleTypewriterComplete(message.id)}
                          />
                          </div>
                        ) : (
                          <div className="p-1">
                            {(() => {
                              let displayContent = message.content;
                              try {
                                // Check if content is JSON with a content field
                                if (message.content.trim().startsWith('{') && message.content.trim().endsWith('}')) {
                                  const jsonContent = JSON.parse(message.content);
                                  if (jsonContent && typeof jsonContent.content === 'string') {
                                    displayContent = jsonContent.content;
                                  }
                                }
                              } catch (e) {
                                // If parsing fails, use the original content
                              }
                              return <MessageMarkdown content={displayContent} />;
                            })()}
                          </div>
                        )}
                      </div>
                    )}

                    {/* Action buttons */}
                    {editingMessageId !== message.id && (
                      <div className="mt-1 flex items-center space-x-2 opacity-0 transition-opacity duration-200 group-hover:opacity-100">
                        {message.role === "user" && (
                          <>
                            <button
                              onClick={() => copyToClipboard(message.content)}
                              className="p-1 text-[#aaa] hover:text-white"
                              title="Nachricht kopieren"
                            >
                              <Copy size={14} />
                            </button>
                            <button
                              onClick={() => startEditMessage(message)}
                              className="p-1 text-[#aaa] hover:text-white"
                              title="Nachricht bearbeiten"
                            >
                              <Edit size={14} />
                            </button>
                          </>
                        )}
                        {message.role === "assistant" && (
                          <>
                            <button
                              onClick={() => copyToClipboard(message.content)}
                              className="p-1 text-[#aaa] hover:text-white"
                              title="Antwort kopieren"
                            >
                              <Copy size={14} />
                            </button>
                            <button
                              onClick={() => regenerateResponse(message.id)}
                              className="p-1 text-[#aaa] hover:text-white"
                              title="Antwort neu generieren"
                            >
                              <RotateCcw size={14} />
                            </button>
                          </>
                        )}
                      </div>
                    )}
                  </div>
                ))}

            {/* Tour Messages */}
            {showFakeMessagesForTour &&
              fakeTourMessages.map(message => (
                <div
                  key={message.id}
                  className={`group relative mb-8 flex flex-col ${
                    message.role === "user" ? "items-end" : "items-start"
                  }`}
                >
                  <div
                    className={`mb-0 text-xs ${message.role === "user" ? "text-right" : "text-left"} text-gray-400`}
                  >
                    {message.role === "user" ? "Beispiel User" : "Beispiel KI"}{" "}
                    {message.timestamp.toLocaleTimeString("de-DE", {
                      hour: "2-digit",
                      minute: "2-digit"
                    })}
                  </div>
                  <div
                    className={`max-w-[60%] ${message.role === "user" ? "user-message" : "assistant-message"}`}
                  >
                    <div className="p-1">
                      {(() => {
                        let displayContent = message.content;
                        try {
                          // Check if content is JSON with a content field
                          if (message.content.trim().startsWith('{') && message.content.trim().endsWith('}')) {
                            const jsonContent = JSON.parse(message.content);
                            if (jsonContent && typeof jsonContent.content === 'string') {
                              displayContent = jsonContent.content;
                            }
                          }
                        } catch (e) {
                          // If parsing fails, use the original content
                        }
                        return <MessageMarkdown content={displayContent} />;
                      })()}
                    </div>
                  </div>

                  {/* Action buttons - made more prominent for the tour */}
                  <div
                    className={`mt-2 flex animate-pulse items-center space-x-3 rounded-md border border-[#444444] bg-[#333333] px-3 py-2 shadow-lg ${
                      message.role === "user" ? "self-end" : "self-start"
                    }`}
                  >
                    {message.role === "user" && (
                      <>
                        <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                          <Copy size={14} className="mr-1.5" />
                          <span className="text-sm font-medium">Kopieren</span>
                        </div>
                        <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                          <Edit size={14} className="mr-1.5" />
                          <span className="text-sm font-medium">
                            Bearbeiten
                          </span>
                        </div>
                      </>
                    )}
                    {message.role === "assistant" && (
                      <>
                        <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                          <Copy size={14} className="mr-1.5" />
                          <span className="text-sm font-medium">Kopieren</span>
                        </div>
                        <div className="flex items-center rounded px-2 py-1 text-white hover:bg-[#444444]">
                          <RotateCcw size={14} className="mr-1.5" />
                          <span className="text-sm font-medium">
                            Neu generieren
                          </span>
                        </div>
                      </>
                    )}
                  </div>

                  {/* Show message actions explanation for AI message during tour */}
                  {showMessageActionsDialog &&
                    message.id === "fake-ai-message" && (
                      <div className="mt-3 max-w-[80%] self-start rounded-md border border-[#444444] bg-[#222222] p-4 shadow-lg">
                        <div className="mb-2 flex items-center justify-between">
                          <h3 className="font-medium text-white">
                            Nachrichtenaktionen
                          </h3>
                          <button
                            onClick={() => setShowMessageActionsDialog(false)}
                            className="text-gray-400 hover:text-white"
                          >
                            <X size={16} />
                          </button>
                        </div>
                        <p className="mb-2 text-sm text-gray-300">
                          Bewegen Sie den Mauszeiger über die Nachrichten, um
                          folgende Aktionen zu nutzen:
                        </p>
                        <ul className="mb-2 ml-2 list-inside list-disc space-y-1 text-xs text-gray-300">
                          <li>
                            <strong>Kopieren:</strong> Kopiert den Inhalt der
                            Nachricht in die Zwischenablage
                          </li>
                          <li>
                            <strong>Bearbeiten:</strong> Ändert Ihre bereits
                            gesendeten Nachrichten
                          </li>
                          <li>
                            <strong>Neu generieren:</strong> Erstellt eine neue
                            KI-Antwort zur letzten Benutzernachricht
                          </li>
                        </ul>
                        <p className="mt-3 text-xs italic text-gray-400">
                          Diese Optionen erscheinen unter jeder Nachricht, wenn
                          Sie mit der Maus darüber fahren.
                        </p>
                        <div className="mt-3 flex justify-end">
                          <button
                            onClick={() => {
                              setShowMessageActionsDialog(false)
                              setRunTour(true)
                              setStepIndex(3) // Skip to the next step (chat sidebar)
                            }}
                            className="rounded-md bg-[#555555] px-3 py-1 text-sm text-white hover:bg-[#666666]"
                          >
                            Weiter
                          </button>
                        </div>
                      </div>
                    )}
                </div>
              ))}

            {/* Typing Indicator - Use the new component */}
            {!showFakeMessagesForTour && isTyping && (
              <div className="mb-4 flex justify-start pl-4">
                {" "}
                {/* Added bottom margin mb-4 */}
                {/* Replace the old indicator with the new one */}
                <LoadingIndicator />
              </div>
            )}
          </div>
        </div>

        {/* Chat Input Footer */}
        <div className="mt-auto flex w-full flex-col items-center bg-[#1e1e1e] px-4 pb-4 pt-2">
          <div
            className="relative flex items-center space-x-2 rounded-lg border border-[#333333] bg-[#2d2d2d] p-2"
            style={{ maxWidth: "805px", width: "100%" }}
          >
            <div className="flex shrink-0 items-center space-x-1">
              <button
                onClick={handleDeepResearch}
                disabled={!inputValue.trim() || isTyping || isSearching}
                className="flex items-center space-x-1 rounded-lg px-2 py-1 text-xs text-[#cccccc] transition-colors hover:bg-[#444444] disabled:cursor-not-allowed disabled:opacity-50"
                title="Web-Suche starten"
              >
                {isSearching ? (
                  <Loader size={16} className="animate-spin" />
                ) : (
                  <Search size={16} />
                )}
                <span>Web-Suche</span>
              </button>
              <div className="relative">
                <button
                  ref={moreOptionsButtonRef}
                  onClick={() => setShowInputMenu(!showInputMenu)}
                  className="rounded-full p-1.5 text-[#cccccc] transition-colors hover:bg-[#444444]"
                  title="Weitere Optionen"
                >
                  <MoreHorizontal size={20} />
                </button>

                {showInputMenu && (
                  <div
                    ref={inputMenuRef}
                    className="absolute bottom-full left-0 z-20 mb-1 w-48 rounded-lg border border-[#333333] bg-[#1e1e1e] py-1 shadow-lg"
                  >
                    <button
                      onClick={() => {
                        handleGenerateSummary()
                        setShowInputMenu(false)
                      }}
                      className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                      disabled={messages.length < 2 || isTyping}
                    >
                      <BookOpen size={14} className="mr-2" />
                      Zusammenfassen
                    </button>
                    <button
                      onClick={() => {
                        setShowExportModal(true)
                        setShowInputMenu(false)
                      }}
                      className="flex w-full items-center px-4 py-2 text-sm text-[#cccccc] hover:bg-[#2d2d2d]"
                      disabled={messages.length === 0 || isTyping}
                    >
                      <FileDown size={14} className="mr-2" />
                      Exportieren
                    </button>
                    <div className="my-1 border-t border-[#333333]"></div>
                    <button
                      onClick={() => {
                        if (currentChatId && user) deleteChat(currentChatId)
                        setShowInputMenu(false)
                      }}
                      className="flex w-full items-center px-4 py-2 text-sm text-red-500 hover:bg-[#2d2d2d] disabled:cursor-not-allowed disabled:opacity-50"
                      disabled={!currentChatId || messages.length === 0}
                    >
                      <Trash size={14} className="mr-2" />
                      Chat löschen
                    </button>
                  </div>
                )}
              </div>
            </div>

            <div className="mx-4 flex grow items-center">
              {" "}
              {/* Ensure parent uses flex and items-center */}
              <textarea
                id="chat-input-textarea"
                ref={inputRef}
                value={inputValue}
                onChange={e => {
                  setInputValue(e.target.value)
                  if (!hasStartedTyping && e.target.value.trim() !== "") {
                    setHasStartedTyping(true)
                  }
                }}
                onKeyDown={e => {
                  if (e.key === "Enter" && !e.shiftKey) {
                    e.preventDefault()
                    handleSendMessage(inputValue, false)
                  }
                }}
                placeholder={
                  isTaskSwitching
                    ? "Task wird gewechselt..."
                    : "Stelle irgendeine Frage ..."
                }
                disabled={isTaskSwitching}
                // Fine-tune vertical padding: pt-2 pb-1
                className={`min-h-10 w-full resize-none bg-transparent px-2 pb-1 pt-2 text-sm text-white placeholder-[#666666] focus:outline-none${isTaskSwitching ? "cursor-not-allowed opacity-50" : ""}`}
                rows={1}
                style={{
                  // minHeight: '40px', // Still handled by Tailwind class
                  maxHeight: "400px"
                }}
              />
            </div>

            <div className="shrink-0">
              <button
                onClick={() => handleSendMessage(inputValue, false)}
                disabled={!inputValue.trim() || isTyping || isTaskSwitching}
                className="flex items-center space-x-1 rounded-lg bg-white px-3 py-1.5 text-sm text-black transition-colors hover:bg-gray-200 disabled:cursor-not-allowed disabled:opacity-50"
                title="Nachricht senden"
              >
                {isTaskSwitching ? (
                  <>
                    <div className="size-4 animate-spin rounded-full border-2 border-gray-800 border-t-transparent"></div>
                    <span>Wechseln...</span>
                  </>
                ) : (
                  <>
                    <Send size={16} />
                    <span>Senden</span>
                  </>
                )}
              </button>
            </div>
          </div>

          <div
            className="mt-2 text-center text-xs text-[#666666]"
            style={{ maxWidth: "805px", width: "100%" }}
          >
            ChatGPT kann Fehler machen. OpenAI verwendet keine Daten aus diesem
            Chat zum Trainieren seiner Modelle.
          </div>
        </div>
      </main>

      {/* Task Creation Modal */}
      {showTaskModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className="w-full max-w-md rounded-lg border border-[#333333] bg-[#1e1e1e] p-6">
            <h2 className="mb-4 text-xl font-semibold text-white">
              Neuen Task erstellen
            </h2>
            <div className="mb-4">
              <label
                htmlFor="taskName"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                Task-Name
              </label>
              <input
                id="taskName"
                type="text"
                value={newTaskName}
                onChange={e => setNewTaskName(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Task-Name eingeben"
              />
            </div>

            <div className="mb-4">
              <label
                htmlFor="taskDescription"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                Beschreibung
              </label>
              <textarea
                id="taskDescription"
                value={newTaskDescription}
                onChange={e => setNewTaskDescription(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Task beschreiben..."
                rows={3}
              />
            </div>

            <div className="mb-4">
              <label
                htmlFor="taskSystemPrompt"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                System-Prompt
              </label>
              <div className="relative">
                <textarea
                  id="taskSystemPrompt"
                  value={newTaskSystemPrompt}
                  onChange={e => setNewTaskSystemPrompt(e.target.value)}
                  className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 pr-10 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                  placeholder="Strukturiere deinen Prompt! Z.B.: ZIEL: [Dein Ziel...] FORMAT: [Gewünschtes Format...] WARNUNGEN: [Was vermeiden?...] KONTEXT: [Hintergrundinfos...]"
                  rows={4}
                />
                <button
                  type="button"
                  onClick={handleImprovePrompt}
                  disabled={isImprovingPrompt || !newTaskSystemPrompt.trim()}
                  className="absolute right-3 top-3 rounded-md bg-[#333333] p-1.5 text-white/80 transition-colors hover:bg-[#444444] hover:text-white disabled:cursor-not-allowed disabled:opacity-50"
                  title="AI-Unterstützung für Prompt"
                >
                  {isImprovingPrompt ? (
                    <Loader size={18} className="animate-spin" />
                  ) : (
                    <Sparkles size={18} />
                  )}
                </button>
              </div>
            </div>

            <div className="mb-4">
              <label
                htmlFor="taskModel"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                KI-Modell
              </label>
              <select
                id="taskModel"
                value={newTaskModel}
                onChange={e => setNewTaskModel(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white focus:outline-none focus:ring-1 focus:ring-[#444444]"
              >
                <option value="gpt-4o">Basic</option>
                <option value="gpt-4o-mini">Fast</option>
                <option value="o3-mini">Reason</option>
                <option value="gpt-4.5-preview">Reason+</option>
              </select>
            </div>

            <div className="flex justify-end space-x-3">
              <button
                onClick={() => {
                  setShowTaskModal(false)
                  setNewTaskName("")
                  setNewTaskDescription("")
                  setNewTaskSystemPrompt("")
                  setNewTaskModel("gpt-4o")
                }}
                className="rounded-lg border border-[#333333] px-4 py-2 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white"
              >
                Abbrechen
              </button>
              <button
                onClick={handleCreateTask}
                disabled={!newTaskName.trim()}
                className={`rounded-lg px-4 py-2 text-sm ${
                  newTaskName.trim()
                    ? "border border-[#444444] bg-[#333333] text-white hover:bg-[#444444]"
                    : "cursor-not-allowed border border-[#444444]/50 bg-[#333333]/50 text-white/70"
                }`}
              >
                Erstellen
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Export Modal */}
      <ExportModal
        isOpen={showExportModal}
        onClose={() => setShowExportModal(false)}
        messages={messages}
        onExport={handleExportPdf}
      />

      {/* Summary Modal */}
      <SummaryModal
        isOpen={showSummaryModal}
        onClose={() => setShowSummaryModal(false)}
        summary={chatSummary}
        loading={false}
      />

      {/* Projekt Modal (Erstellen/Bearbeiten) */}
      {showProjectModal && (
        <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50">
          <div className="w-full max-w-md rounded-lg border border-[#333333] bg-[#1e1e1e] p-6">
            <h2 className="mb-4 text-xl font-semibold text-white">
              {projectToRename
                ? "Projekt bearbeiten"
                : "Neues Projekt erstellen"}
            </h2>

            <div className="mb-4">
              <label
                htmlFor="projectName"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                Projektname
              </label>
              <input
                id="projectName"
                type="text"
                value={newProjectName}
                onChange={e => setNewProjectName(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Projektname eingeben"
              />
            </div>

            <div className="mb-4">
              <label
                htmlFor="projectDescription"
                className="mb-2 block text-sm font-medium text-[#cccccc]"
              >
                Beschreibung (optional)
              </label>
              <textarea
                id="projectDescription"
                value={newProjectDescription}
                onChange={e => setNewProjectDescription(e.target.value)}
                className="w-full rounded-lg border border-[#333333] bg-[#2d2d2d] px-3 py-2 text-white placeholder-[#666666] focus:outline-none focus:ring-1 focus:ring-[#444444]"
                placeholder="Projekt beschreiben..."
                rows={3}
              />
            </div>

            <div className="flex justify-end space-x-3">
              <button
                onClick={() => {
                  setShowProjectModal(false)
                  setProjectToRename(null)
                  setNewProjectName("")
                  setNewProjectDescription("")
                }}
                className="rounded-lg border border-[#333333] px-4 py-2 text-sm text-[#cccccc] transition-all hover:border-[#444444] hover:text-white"
              >
                Abbrechen
              </button>
              <button
                onClick={() => {
                  if (projectToRename) {
                    // Projekt aktualisieren
                    updateProject()
                  } else {
                    // Neues Projekt erstellen
                    handleCreateProject()
                  }
                }}
                disabled={!newProjectName.trim()}
                className={`rounded-lg px-4 py-2 text-sm ${
                  newProjectName.trim()
                    ? "border border-[#444444] bg-[#333333] text-white hover:bg-[#444444]"
                    : "cursor-not-allowed border border-[#444444]/50 bg-[#333333]/50 text-white/70"
                }`}
              >
                {projectToRename ? "Aktualisieren" : "Erstellen"}
              </button>
            </div>
          </div>
        </div>
      )}

      {/* Settings Modal */}
      <SettingsModal
        isOpen={showSettingsModal}
        onClose={() => setShowSettingsModal(false)}
        userId={user?.id || ""}
      />

      {/* Offline Indicator */}
      <OfflineIndicator />
    </div>
  )
}
