"use client"

import React from "react"
import { createClientComponentClient } from "@supabase/auth-helpers-nextjs"
import { useEffect, useRef, useState, useMemo, useCallback } from "react"
import { useSearchParams } from "next/navigation"
import Link from "next/link"
import {
  ChevronLeft,
  Menu,
  Plus,
  Send,
  ChevronDown,
  Copy,
  RotateCcw,
  Edit,
  Paperclip,
  Image,
  Search,
  MoreVertical,
  Trash,
  X,
  FlaskConical,
  MoreHorizontal,
  Mic,
  Loader,
  FileText,
  FileDown,
  BookOpen,
  User,
  Settings,
  Home,
  ChevronRight,
  MessageCircle,
  Sparkles,
  Check
} from "lucide-react" // Added Icons
import ReactMarkdown from "react-markdown"
import remarkGfm from "remark-gfm"
import { v4 as uuidv4 } from "uuid"
import { TypewriterEffect } from "@/components/typewriter-effect"
import { RevealEffect } from "@/components/reveal-effect"; // Import RevealEffect
import { useRouter } from "next/navigation"
import { cn } from "@/lib/utils"
import Joyride, { Step, CallBackProps, STATUS } from "react-joyride" // Import Joyride
import dynamic from "next/dynamic" // Import dynamic
import {
  performSerpApiSearch,
  formatSearchResults,
  formatSearchResultsForAI
} from "../utils/serpApi"
import { downloadChatAsPdf } from "../utils/pdfExport"
import { generateChatSummary } from "../utils/chatSummary"
import ExportModal from "../components/ExportModal"
import SummaryModal from "../components/SummaryModal"
// Drag-and-Drop-Bibliotheken
import {
  DndContext,
  useDraggable,
  useDroppable,
  useSensors,
  useSensor,
  PointerSensor
} from "@dnd-kit/core"
import LoadingIndicator from "@/components/LoadingIndicator" // Corrected import path
import SettingsModal from "@/app/components/SettingsModal" // Import the SettingsModal component
import { KnowledgeBaseSelector } from "@/components/knowledge/KnowledgeBaseSelector"
import { Prism as SyntaxHighlighter } from "react-syntax-highlighter"
import { oneDark } from "react-syntax-highlighter/dist/cjs/styles/prism"
import { MessageMarkdown } from "@/components/message-markdown"
import { MessageCodeBlock } from "@/components/message-code-block"
import { buildPrompt, DEFAULT_SYSTEM_PROMPT } from "@/lib/prompt-builder"

// Dynamically import Joyride with SSR disabled
const DynamicJoyride = dynamic(() => import("react-joyride"), { ssr: false })

// Define a simpler interface for CodeProps
interface CodeProps {
  node?: any
  inline?: boolean
  className?: string
  children?: React.ReactNode
}

interface Message {
  id: string
  role: "user" | "assistant" | "system"
  content: string
  timestamp: Date
  isTypewriting?: boolean
  user_id?: string // Add user_id to track message sender
  sentfrom?: string // Add sentfrom to store user name directly
}

interface ChatSession {
  id: string
  name: string
  created_at: string
  description?: string
  project_id?: string | null
  last_message_timestamp?: string
  user_id?: string
}

interface Task {
  id: string
  title: string
  description: string
  system_prompt: string
  ai_model: string
  created_at?: string
  updated_at?: string
  user_id?: string
  workspace_id?: string | null
  project_id?: string | null
}

interface Project {
  id: string
  name: string
  description?: string
  user_id: string
  workspace_id?: string | null
  chats?: ChatSession[] // Chats, die zu diesem Projekt geh√∂ren
}

// Define structure for info items (used for buttons, tour content can be different)
interface InfoItem {
  title: string
  // We'll define tour steps separately now
}

// Keep infoItems simple for the buttons
const infoItems: InfoItem[] = [
  { title: "Tasks nutzen" },
  { title: "KI-Modell wechseln" },
  { title: "Nachrichten bearbeiten & neu generieren" },
  { title: "Chats verwalten" }
]

const initialMessages: Message[] = []

// Define Tour Steps (Adjust step 3)
const tourSteps: Step[] = [
  {
    target: "#task-select-button",
    content: (
      <>
        <p className="mb-2">
          Mit Tasks k√∂nnen Sie der KI spezifische Anweisungen oder eine
          bestimmte Rolle f√ºr den gesamten Chat zuweisen.
        </p>
        <p>
          Klicken Sie hier, um einen vorhandenen Task zu w√§hlen oder einen neuen
          zu erstellen. Tasks √ºberschreiben die manuelle Modellauswahl.
        </p>
      </>
    ),
    placement: "bottom-end",
    title: "Tasks nutzen"
  },
  {
    target: "#model-select-button",
    content: (
      <>
        <p className="mb-2 text-sm">
          W√§hlen Sie hier das KI-Modell, wenn kein Task aktiv ist:
        </p>
        <ul className="mb-2 ml-4 list-inside list-disc space-y-1 text-sm">
          <li>
            <strong>Basic (GPT-4o):</strong> Ausgewogen.
          </li>
          <li>
            <strong>Fast (GPT-4o mini):</strong> Schnell & G√ºnstig.
          </li>
          <li>
            <strong>Reason (GPT-4 Vision):</strong> Leistungsstark.
          </li>
        </ul>
      </>
    ),
    placement: "bottom-end",
    title: "KI-Modell wechseln"
  },
  {
    target: "#chat-sidebar",
    content:
      "Hier verwalten Sie Ihre Chats: Neuen Chat erstellen (+), Chat ausw√§hlen, umbenennen oder l√∂schen (√ºber die drei Punkte).",
    placement: "right",
    title: "Chats verwalten"
  },
  {
    target: "#new-chat-button",
    content: "Klicken Sie hier, um einen neuen, leeren Chat zu beginnen.",
    placement: "left",
    title: "Neuer Chat",
    disableScrolling: true,
    disableOverlayClose: true,
    spotlightPadding: 5
  },
  {
    target: "#chat-input-textarea",
    content:
      "Geben Sie hier Ihre Nachricht ein und dr√ºcken Sie Enter oder klicken Sie auf den Senden-Button.",
    placement: "top",
    title: "Nachricht senden"
  }
]

// Helper function to fix the columns handling consistently
const getColumnNames = (columns: any[] | null): string[] => {
  return columns
    ? columns.map((col: { column_name: string }) => col.column_name)
    : []
}

// Detect and format HTML code
const formatCodeInMessage = (content: string): string => {
  // If content already has markdown code blocks, don't modify
  if (content.includes("```")) return content;
  
  // Check if the content appears to be HTML
  if (
    content.trim().startsWith("<") && 
    (content.includes("<!DOCTYPE") || 
     content.includes("<html") ||
     (content.includes("<body") && content.includes("</body>")) ||
     (content.includes("<head") && content.includes("</head>")))
  ) {
    return "```html\n" + content + "\n```";
  }
  
  return content;
};

// This is a standalone component for code blocks

// ---> HILFSFUNKTIONEN f√ºr V2 Prompt <--- 
function trimText(txt: string | null | undefined, maxWords = 60): string {
  if (!txt) return "";
  const words = txt.trim().split(/\s+/);
  if (words.length <= maxWords) return txt;
  return words.slice(0, maxWords).join(" ") + " ‚Ä¶";
}

// V2 System Prompt Definition - entfernt, da jetzt zentral in prompt-builder.ts definiert
// const systemPrompt = `...`.trim();
// ---> ENDE HILFSFUNKTIONEN f√ºr V2 Prompt <--- 

// Add debugging flag at the top of the file, after imports
const DEBUG_MODE = false; // Set to true to enable verbose logging

// Replace console.log with debug-aware logging function
const debugLog = (...args: any[]) => {
  if (DEBUG_MODE) {
    console.log(...args);
  }
};

// Add this custom hook for subscription management
// Place it outside the component, before export default function Chat()
const useSubscriptions = (supabase: any) => {
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const [subscriptionStatus, setSubscriptionStatus] = useState({
    chatsSubscribed: false,
    messagesSubscribed: false
  });

  // Setup chat subscription
  const setupChatSubscription = useCallback((userId: string) => {
    if (!supabase || !userId || chatsChannelRef.current) {
      return;
    }

    const channelId = `chats_updates_global`;
    debugLog(`Setting up realtime subscription for chats table: ${channelId}`);

    const chatsChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "UPDATE",
          schema: "public",
          table: "chats"
        },
        (payload: any) => {
          debugLog("Realtime chat update received:", payload);
          // Callback to update UI based on the payload would be passed
          // from the component when calling this function
        }
      )
      .subscribe((status: string) => {
        debugLog(`Subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, chatsSubscribed: status === "SUBSCRIBED"}));
      });
    
    chatsChannelRef.current = chatsChannel;
    return chatsChannel;
  }, [supabase]);

  // Setup message subscription
  const setupMessageSubscription = useCallback((chatId: string, userId: string, onMessageReceived: (msg: any) => void) => {
    if (!supabase || !chatId || !userId) {
      return;
    }

    // Cleanup previous subscription if exists
    if (messagesChannelRef.current) {
      debugLog("Cleaning up previous message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    const channelId = `chat_messages_${chatId}`;
    debugLog(`Setting up message subscription for chat: ${chatId}`);

    const messagesChannel = supabase
      .channel(channelId)
      .on(
        "postgres_changes",
        {
          event: "*",
          schema: "public",
          table: "chat_messages",
          filter: `chat_id=eq.${chatId}`
        },
        (payload: any) => {
          debugLog(`Realtime message update received for chat ${chatId}:`, payload.eventType);
          
          if (payload.eventType === "INSERT") {
            const newMsg = payload.new;
            // Check if message is from another user
            const msgSentByOtherUser = newMsg.user_id && newMsg.user_id !== userId;
            
            // Only notify if message is from another user or pass to the callback in any case
            onMessageReceived(payload);
          }
        }
      )
      .subscribe((status: string) => {
        debugLog(`Message subscription status for ${channelId}: ${status}`);
        setSubscriptionStatus(prev => ({...prev, messagesSubscribed: status === "SUBSCRIBED"}));
      });

    messagesChannelRef.current = messagesChannel;
    return messagesChannel;
  }, [supabase]);

  // Cleanup all subscriptions
  const cleanupSubscriptions = useCallback(() => {
    if (chatsChannelRef.current && supabase) {
      debugLog("Cleaning up chats table subscription");
      supabase.removeChannel(chatsChannelRef.current);
      chatsChannelRef.current = null;
    }

    if (messagesChannelRef.current && supabase) {
      debugLog("Cleaning up message subscription");
      supabase.removeChannel(messagesChannelRef.current);
      messagesChannelRef.current = null;
    }

    setSubscriptionStatus({
      chatsSubscribed: false,
      messagesSubscribed: false
    });
  }, [supabase]);

  return {
    setupChatSubscription,
    setupMessageSubscription,
    cleanupSubscriptions,
    subscriptionStatus
  };
};

export default function Chat() {
  const searchParams = useSearchParams()
  const rawWorkspaceId = searchParams.get("workspace")
  const taskId = searchParams.get("task")

  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [user, setUser] = useState<any>(null)
  const [workspace, setWorkspace] = useState<any>(null)
  const [userFullName, setUserFullName] = useState<string>("Du")
  const [messages, setMessages] = useState<Message[]>(initialMessages)
  const [inputValue, setInputValue] = useState("")
  const [isTyping, setIsTyping] = useState(false)
  const [showIceBreakers, setShowIceBreakers] = useState(false)
  const [showModelDropdown, setShowModelDropdown] = useState(false)
  const [selectedModel, setSelectedModel] = useState("gpt-4o")
  const [chatSessions, setChatSessions] = useState<ChatSession[]>([])
  const [currentChatId, setCurrentChatId] = useState<string | null>(null)
  const [tasks, setTasks] = useState<Task[]>([])
  const [selectedTask, setSelectedTask] = useState<Task | null>(null)
  const [showTaskDropdown, setShowTaskDropdown] = useState(false)
  const [showTaskModal, setShowTaskModal] = useState(false)
  const [newTask, setNewTask] = useState<Task>({
    id: "",
    title: "",
    description: "",
    system_prompt: "",
    ai_model: ""
  })
  const [newTaskName, setNewTaskName] = useState("")
  const [newTaskDescription, setNewTaskDescription] = useState("")
  const [newTaskSystemPrompt, setNewTaskSystemPrompt] = useState("")
  const [newTaskModel, setNewTaskModel] = useState("gpt-4o")
  const [showSidebar, setShowSidebar] = useState(true)
  const [typingMessageId, setTypingMessageId] = useState<string | null>(null)
  const [personalWorkspaceId, setPersonalWorkspaceId] = useState<string | null>(
    null
  )
  const [previousSelectedTask, setPreviousSelectedTask] = useState<Task | null>(
    null
  )
  const [previousSelectedModel, setPreviousSelectedModel] = useState<
    string | null
  >(null)
  const [messageUpdatePending, setMessageUpdatePending] = useState(false)
  const [isTaskSwitching, setIsTaskSwitching] = useState(false)
  const [lastMessageUpdate, setLastMessageUpdate] = useState(Date.now())

  // State f√ºr Projekte
  const [projects, setProjects] = useState<Project[]>([])
  const [selectedProject, setSelectedProject] = useState<Project | null>(null)
  const [showProjectDropdown, setShowProjectDropdown] = useState(false)
  const [showProjectModal, setShowProjectModal] = useState(false)
  const [newProjectName, setNewProjectName] = useState("")
  const [newProjectDescription, setNewProjectDescription] = useState("")
  const [projectMenuOpen, setProjectMenuOpen] = useState<string | null>(null)
  const [projectToRename, setProjectToRename] = useState<Project | null>(null)

  // State f√ºr Drag & Drop
  const [draggedChatId, setDraggedChatId] = useState<string | null>(null)
  const [activeDropTarget, setActiveDropTarget] = useState<string | null>(null)

  // State f√ºr aufgeklappte Projekte
  const [expandedProjects, setExpandedProjects] = useState<
    Record<string, boolean>
  >({})

  // State for editing messages
  const [editingMessageId, setEditingMessageId] = useState<string | null>(null)
  const [editingContent, setEditingContent] = useState("")
  
  // State to store original messages during editing
  const [originalMessages, setOriginalMessages] = useState<Message[]>([])

  // Add searchDebounceTimeout ref
  const searchDebounceTimeout = useRef<any>(null)

  const chatBodyRef = useRef<HTMLDivElement>(null)
  const inputRef = useRef<HTMLTextAreaElement>(null)
  const modelDropdownRef = useRef<HTMLDivElement>(null)
  const taskDropdownRef = useRef<HTMLDivElement>(null)
  const projectDropdownRef = useRef<HTMLDivElement>(null)

  const supabase = createClientComponentClient()

  // Add state for chat menu and rename functionality
  const [chatMenuOpen, setChatMenuOpen] = useState<string | null>(null)
  const [renameModalOpen, setRenameModalOpen] = useState(false)
  const [chatToRename, setChatToRename] = useState<ChatSession | null>(null)
  const [newChatName, setNewChatName] = useState("")
  // Neuer State f√ºr inline edit
  const [editingChatId, setEditingChatId] = useState<string | null>(null)

  const router = useRouter()

  // Add state and refs for the input action menu
  const [showInputMenu, setShowInputMenu] = useState(false)
  const inputMenuRef = useRef<HTMLDivElement>(null)
  const moreOptionsButtonRef = useRef<HTMLButtonElement>(null)

  // F√ºge einen Ref f√ºr die Edit-Box hinzu
  const editBoxRef = useRef<HTMLDivElement>(null)

  // Add state for the new info modal
  // const [showInfoModal, setShowInfoModal] = useState(false)
  // const [modalContent, setModalContent] = useState<InfoItem | null>(null)

  // Add state for React Joyride
  const [runTour, setRunTour] = useState(false)
  const [stepIndex, setStepIndex] = useState(0)

  // State to control showing fake messages during the tour
  const [showFakeMessagesForTour, setShowFakeMessagesForTour] = useState(false)

  // Define fake messages for the tour demonstration
  const fakeTourMessages: Message[] = [
    {
      id: "fake-user-1",
      role: "user",
      content: "Das ist eine Beispiel-Nachricht des Benutzers.",
      timestamp: new Date(Date.now() - 120000) // 2 minutes ago
    },
    {
      id: "fake-ai-message",
      role: "assistant",
      content:
        "Und hier ist eine Beispiel-Antwort der KI. Wenn Sie den Mauszeiger √ºber diese Nachricht bewegen, werden Aktionsbuttons angezeigt.",
      timestamp: new Date(Date.now() - 60000) // 1 minute ago
    }
  ]

  // Add loading state specifically for search
  const [isSearching, setIsSearching] = useState(false)
  // Add chat message search state
  const [searchOpen, setSearchOpen] = useState(false)
  const [messageSearchQuery, setMessageSearchQuery] = useState("")
  const [messageSearchResults, setMessageSearchResults] = useState<any[]>([])

  // New state variables for the export and summary modals
  const [showExportModal, setShowExportModal] = useState(false)
  const [showSummaryModal, setShowSummaryModal] = useState(false)
  const [chatSummary, setChatSummary] = useState("")
  const [isSummarizing, setIsSummarizing] = useState(false)

  // State for showing the message actions dialog
  const [showMessageActionsDialog, setShowMessageActionsDialog] =
    useState(false)
  const [isImprovingPrompt, setIsImprovingPrompt] = useState(false)

  // Add the state for showing settings modal
  const [showSettingsModal, setShowSettingsModal] = useState(false) // Add state for settings modal

  // Add state for storing user names
  const [userNamesMap, setUserNamesMap] = useState<{ [key: string]: string }>(
    {}
  )

  // Neue State-Variable f√ºr die ausgew√§hlte Wissensdatenbank
  const [selectedKnowledgeBaseId, setSelectedKnowledgeBaseId] = useState<
    string[] | null
  >(null)

  // Online-Status-State
  const [isOnline, setIsOnline] = useState<boolean>(true); // Standardm√§√üig annehmen, dass wir online sind

  // Korrekte Typisierung des Refs am Anfang der Komponente
  const initialChatsLoadedRef = useRef(false);
  const chatsChannelRef = useRef<any>(null);
  const messagesChannelRef = useRef<any>(null);
  const isInitializingRef = useRef(false);
  const isStartingNewChatRef = useRef(false);

  // Improved state management for initialization with proper debouncing
  // Add this near the beginning of the component, around line 200-300
  const initializationTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const messageUpdateTimeoutRef = useRef<NodeJS.Timeout | null>(null);

  // Event-Listener f√ºr Online/Offline-Status
  useEffect(() => {
    // Initialen Status setzen
    setIsOnline(navigator.onLine);
    
    // Handler f√ºr Online/Offline-Events
    const handleOnline = () => {
      console.log("üü¢ Internetverbindung wiederhergestellt");
      setIsOnline(true);
      
      // Optional: Beim Wiederherstellen der Verbindung Daten neu laden
      if (user) {
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        loadChatSessionsMemoized(user.id, workspaceContext);
        loadTasksMemoized(user.id, workspaceContext);
        loadProjectsMemoized(user.id, workspaceContext);
      }
    };
    
    const handleOffline = () => {
      console.log("üî¥ Internetverbindung verloren");
      setIsOnline(false);
    };
    
    // Event-Listener hinzuf√ºgen
    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);
    
    // Event-Listener beim Unmount entfernen
    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, [user, rawWorkspaceId, personalWorkspaceId]);
  
  useEffect(() => {
    if (selectedTask && selectedTask.ai_model) {
      setSelectedModel(selectedTask.ai_model)
    }
  }, [selectedTask])

  // UI-Komponente f√ºr Offline-Status 
  const OfflineIndicator = () => {
    if (isOnline) return null;
    
    return (
      <div className="fixed bottom-4 right-4 z-50 rounded-md bg-yellow-600 px-4 py-2 text-white shadow-lg">
        <div className="flex items-center space-x-2">
          <div className="h-2 w-2 rounded-full bg-red-500"></div>
          <span>Offline-Modus - Einige Funktionen sind nicht verf√ºgbar</span>
        </div>
      </div>
    );
  };

  useEffect(() => {
    const fetchPersonalWorkspace = async () => {
      if (user) {
        console.log("Fetching personal workspace for user:", user.id)
        const { data, error } = await supabase
          .from("workspaces")
          .select("id")
          .eq("user_id", user.id)
          .eq("is_home", true)
          .single() // Annahme: Es gibt nur EINEN pers√∂nlichen Workspace

        if (error && error.code !== "PGRST116") {
          // Ignore ' esattamente uma linha esperada'
          console.error("Error fetching personal workspace:", error)
        } else if (data) {
          console.log("Personal workspace found:", data.id)
          setPersonalWorkspaceId(data.id)
        } else {
          console.warn("Personal workspace not found for user:", user.id)
          // Hier k√∂nnte man optional den Workspace erstellen, falls er fehlt
          // oder eine Fehlermeldung anzeigen.
        }
      }
    }
    if (user && !rawWorkspaceId) {
      // Nur laden, wenn kein Workspace in URL und User bekannt
      fetchPersonalWorkspace()
    }
  }, [user, supabase, rawWorkspaceId]) // Abh√§ngigkeiten

  // Optimierte Kontextauswahl mit Caching, besserer Priorisierung und Ausschluss aktueller Nachrichten
  // Cache f√ºr Chat-Sessions um redundante Ladevorg√§nge zu vermeiden
  const chatSessionsCache: {
    sessions: any[] | null
    timestamp: number
    maxAge: number
  } = {
    sessions: null,
    timestamp: 0,
    maxAge: 5000 // Cache ist f√ºr 5 Sekunden g√ºltig
  }

  // Cache f√ºr Projektberechnungen
  const projectsCache: {
    projectChats: Map<string, any[]> | null
    timestamp: number
    maxAge: number
  } = {
    projectChats: null,
    timestamp: 0,
    maxAge: 10000 // Cache ist f√ºr 10 Sekunden g√ºltig
  }

  // Optimierte Funktion zum Laden von Chat-Sessions mit Caching
  const loadChatSessionsWithCache = async (
    userId: string,
    workspaceId: string | null
  ) => {
    const now = Date.now()

    // Pr√ºfen, ob der Cache g√ºltig ist
    if (
      chatSessionsCache.sessions &&
      now - chatSessionsCache.timestamp < chatSessionsCache.maxAge
    ) {
      console.log("üì¶ Verwende gecachte Chat-Sessions")
      return chatSessionsCache.sessions
    }

    console.log(
      `üîÑ Loading chat sessions - userId: ${userId} workspaceId: ${workspaceId}`
    )

    // Lade Daten wie zuvor
    const { data, error } = await supabase
      .from("chats")
      .select("*")
      .eq("user_id", userId)
      .eq("workspace_id", workspaceId)
      .order("updated_at", { ascending: false })

    if (error) {
      console.error("‚ùå Fehler beim Laden der Chat-Sessions:", error)
      return []
    }

    console.log(`‚úÖ Loaded ${data.length} chat sessions`)

    // Verarbeite Daten und speichere sie im Cache
    const formattedSessions = data.map((chat: any) => ({
      id: chat.id,
      name: chat.name || "Neuer Chat",
      timestamp: chat.updated_at,
      message_count: chat.message_count || 0,
      project: chat.project || null,
      temperature: chat.temperature,
      model: chat.model || null
    }))

    // Cache aktualisieren
    chatSessionsCache.sessions = formattedSessions
    chatSessionsCache.timestamp = now

    return formattedSessions
  }

  // Optimierte Funktion zur Projektberechnung mit Caching
  const recalculateProjectsWithCache = (chats: any[]) => {
    const now = Date.now()

    // Pr√ºfen, ob der Cache g√ºltig ist
    if (
      projectsCache.projectChats &&
      now - projectsCache.timestamp < projectsCache.maxAge
    ) {
      return projectsCache.projectChats
    }

    console.log(
      `üî¢ Berechne Projekte neu aus ${chats.length} verf√ºgbaren Chats`
    )

    const projectChats = new Map()

    // Projekte berechnen wie zuvor
    const availableProjects = [
      ...new Set(chats.filter(c => c.project).map(c => c.project))
    ]

    availableProjects.forEach(project => {
      const chatsInProject = chats.filter(c => c.project === project)
      projectChats.set(project, chatsInProject)
      console.log(`üóÇÔ∏è Projekt ${project} hat ${chatsInProject.length} Chats`)
    })

    // Cache aktualisieren
    projectsCache.projectChats = projectChats
    projectsCache.timestamp = now

    return projectChats
  }

  // Hauptfunktion f√ºr die Kontext-Suche, verbessert mit Ausschluss der aktuellen Nachricht
  const findSimilarMessagesOptimized = async (
    userId: string,
    query: string,
    currentMessageId: string | null = null
  ) => {
    debugLog(`üîç Suche nach √§hnlichen Nachrichten f√ºr User ${userId}`);
    debugLog(`üìù Suchanfrage: "${query}"`);

    // Skip search for very short queries to reduce database load
    if (query.trim().length < 3) {
      debugLog("‚è© √úberspringe Suche f√ºr zu kurze Anfrage (weniger als 3 Zeichen)");
      return [];
    }

    // Validiere userId
    if (!userId || typeof userId !== "string" || userId.trim() === "") {
      console.error("‚ùå Ung√ºltige userId f√ºr die Suche:", userId);
      return [];
    }

    try {
      // Erstelle ein tempor√§res Nachrichtenobjekt f√ºr das Embedding
      const tempQueryMessage = {
        content: query,
        id: "query", // Diese ID wird nicht in der DB gespeichert
        role: "user" as "user", // Explizit typisieren
        timestamp: new Date()
      };

      // Erstelle Embedding f√ºr die Anfrage
      debugLog(`üß† Generiere Embedding f√ºr Suchanfrage...`);

      try {
        // Direkter Aufruf der Embedding-API als tempor√§rer Ersatz f√ºr createEmbedding
        debugLog("üì® Original Nachrichteninhalt:", tempQueryMessage.content);
        const currentDate = new Date().toISOString().split("T")[0];
        const contentWithDate = `[Datum: ${currentDate}]\n${tempQueryMessage.content}`;
        
        const response = await fetch("/api/embeddings", {
          method: "POST",
          headers: {
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            input: contentWithDate
          })
        });
        
        if (!response.ok) {
          throw new Error(`Embedding API responded with ${response.status}`);
        }
        
        const embeddingData = await response.json();
        const embedding = embeddingData.embedding;

        if (!embedding) {
          console.error("‚ùå Fehler beim Generieren des Embeddings f√ºr die Suche");
          return [];
        }

        debugLog(`‚úÖ Embedding f√ºr Abfrage erfolgreich generiert`);
        debugLog(`üìä Query-Embedding-Dimensionen: ${embedding.length}`);
        
        // Adjust similarity threshold based on query length
        const dynamicThreshold = query.length < 10 ? 0.75 : 0.65;
        const maxResults = query.length < 10 ? 10 : 20;
        
        debugLog(
          `üìû Rufe search_similar_messages RPC f√ºr User ${userId} auf (Schwellwert: ${dynamicThreshold}, Max Ergebnisse: ${maxResults})`
        );

        // RPC f√ºr die √Ñhnlichkeitssuche aufrufen
        const { data: results, error } = await supabase.rpc(
          "search_similar_messages",
          {
            p_user_id: userId,
            query_embedding: embedding,
            similarity_threshold: dynamicThreshold, // Use dynamic threshold
            max_results: maxResults
          }
        );

        if (error) {
          console.error("‚ùå Fehler bei der RPC-Suche nach √§hnlichen Nachrichten:", error);
          return [];
        }

        debugLog(`üîé RPC Ergebnis: ${results?.length || 0} Nachrichten gefunden`);
        
        if (!results || results.length === 0) {
          return [];
        }
        
        if (DEBUG_MODE) {
          debugLog(`üìã Erste Ergebnisse (Rohdaten): ${JSON.stringify(results?.slice(0, 2) || [])}`);
        }

        // Filtere die aktuelle Nachricht, falls vorhanden
        let filteredResults = results || [];
        if (currentMessageId) {
          const originalLength = filteredResults.length;
          filteredResults = filteredResults.filter(
            (msg: any) => msg.message_id !== currentMessageId
          );
          if (originalLength !== filteredResults.length) {
            debugLog(`üßπ Aktuelle Nachricht mit ID ${currentMessageId} aus Ergebnissen ausgeschlossen`);
          }
        }

        // Schnellere Verarbeitung der Datumsangaben ohne √ºberm√§√üiges Logging
        for (const msg of filteredResults) {
          // Generiere eine anzeigbare Version des Inhalts ohne Datum
          msg.displayContent = msg.content;
          if (msg.content && typeof msg.content === 'string' && msg.content.startsWith('[Datum:') && msg.content.includes(']\n')) {
            msg.displayContent = msg.content.replace(/^\[Datum:[^\]]+\]\n/, '');
          }
          
          // Extrahiere Datum aus dem Nachrichteninhalt, aber logge nicht jede Nachricht
          const dateMatch = msg.content?.match(/\[Datum: ([^\]]+)\]/);
          msg.dateInfo = dateMatch ? dateMatch[1] : null;
        }

        debugLog(`‚úÖ ${filteredResults.length} √§hnliche Nachrichten nach Filterung gefunden`);

        return filteredResults;
      } catch (error) {
        console.error("‚ùå Fehler beim Erstellen des Embeddings:", error);
        return [];
      }
    } catch (error) {
      console.error("‚ùå Fehler bei der Suche nach √§hnlichen Nachrichten:", error);
      return [];
    }
  };

  // Verbesserte Kontext-Auswahlfunktion mit optimierter Bewertung f√ºr neueste/√§lteste Nachrichten
  const prepareContextMessage = (contextContent: string) => {
    return {
      role: "system",
      content: `Relevanter Kontext aus fr√ºheren Gespr√§chen:\n\n${contextContent}\n\nDies sind Ausschnitte aus vorherigen Konversationen, die f√ºr die aktuelle Frage relevant sein k√∂nnten. Die mit "neueste Information" markierten Abschnitte enthalten den aktuellsten Stand zu diesem Thema, w√§hrend "erste Erw√§hnung" historischen Kontext bietet. Nutze diese Informationen, um eine informierte Antwort zu geben, besonders wenn der Benutzer sich auf bereits besprochene Themen bezieht.`
    }
  }

  const loadChatSessions = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      console.log(
        "üîÑ Loading chat sessions - userId:",
        userId,
        "workspaceId:",
        workspaceId
      )

      // Verwende personalWorkspaceId als Fallback, wenn keine workspaceId √ºbergeben wird
      const targetWorkspaceId = workspaceId || personalWorkspaceId

      // Build the query
      let query = supabase
        .from("chats")
        .select(
          "id, name, created_at, description, workspace_id, last_message_timestamp, project_id, user_id"
        )

      // Properly handle null workspace IDs
      if (targetWorkspaceId) {
        // Wenn ein Workspace angegeben ist, zeige ALLE Chats in diesem Workspace
        // ohne nach user_id zu filtern
        query = query.eq("workspace_id", targetWorkspaceId)
      } else {
        // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
        query = query.is("workspace_id", null).eq("user_id", userId)
      }

      const { data, error } = await query.order("last_message_timestamp", {
        ascending: false
      })

      if (error) {
        console.error("‚ùå Error loading chat sessions:", error)
        setError(`Fehler beim Laden der Chats: ${error.message}`)
        throw error
      }

      if (data) {
        console.log("‚úÖ Loaded", data.length, "chat sessions")
        console.log("Chat data:", data) // Debug: Zeige die Chat-Daten

        const formattedSessions = data.map((chat: any) => ({
          id: chat.id || "",
          name: chat.name || "Unnamed Chat",
          created_at: chat.created_at || new Date().toISOString(),
          last_message_timestamp: chat.last_message_timestamp,
          user_id: chat.user_id, // Behalte user_id um den Ersteller anzuzeigen
          ...(chat.description && { description: chat.description }),
          project_id: chat.project_id
        }))

        console.log("Formatted sessions:", formattedSessions) // Debug: Zeige die formatierten Sessions
        setChatSessions(formattedSessions)
      } else {
        console.log("‚ÑπÔ∏è No chat sessions found")
        setChatSessions([])
      }
    } catch (err) {
      console.error("‚ùå Error in loadChatSessions:", err)
      setChatSessions([])
    }
  }

  const createNewChat = async () => {
    try {
      if (!user) {
        setError("Sie m√ºssen angemeldet sein, um einen Chat zu erstellen.")
        return null
      }

      // Determine the workspace ID to use - simplify this logic
      const workspaceId = rawWorkspaceId || personalWorkspaceId

      if (!workspaceId) {
        setError(
          "Konnte keinen g√ºltigen Arbeitsbereich zum Erstellen des Chats finden."
        )
        return null
      }

      console.log(`Creating new chat in workspace: ${workspaceId}`)

      // Create a new chat with a temporary name - we'll update it later
      const newChatId = uuidv4()
      const initialTitle = "Neuer Chat"

      // Create with retry to ensure it succeeds
      const { data: newChat, error } = await supabase
        .from("chats")
        .insert({
          id: newChatId,
          user_id: user.id,
          name: initialTitle,
          workspace_id: workspaceId,
          created_at: new Date().toISOString(),
          last_message_timestamp: new Date().toISOString()
        })
        .select()
        .single()

      if (error) {
        console.error(`‚ùå Error creating new chat: ${error.message}`)
        setError(`Fehler beim Erstellen des Chats: ${error.message}`)
        return null
      }

      if (!newChat) {
        console.error("‚ùå No chat data returned after creation")
        setError("Fehler beim Erstellen des Chats: Keine Daten zur√ºckgegeben")
        return null
      }

      console.log(`‚úÖ Successfully created new chat with ID: ${newChatId}`)

      // Set the current chat ID immediately
      setCurrentChatId(newChatId)

      // Wait for the database to properly register the new chat
      await new Promise(resolve => setTimeout(resolve, 300))

      // Reload chat sessions to update UI
      if (user) {
        await loadChatSessions(user.id, workspaceId)
      }

      return newChatId
    } catch (err) {
      console.error("Error in createNewChat:", err)
      setError(
        `Fehler beim Erstellen des Chats: ${err instanceof Error ? err.message : "Unbekannter Fehler"}`
      )
      return null
    }
  }

  const loadChat = async (chatId: string) => {
    try {
      setCurrentChatId(chatId)

      // Try to get chat details first to confirm it exists
      const { data: chatData, error: chatError } = await supabase
        .from("chats")
        .select("id, name")
        .eq("id", chatId)
        .single()

      if (chatError) {
        console.error("Error fetching chat details:", chatError)
        return
      }

      // Get chat messages - now only using chat_id
      const { data: messagesData, error: messagesError } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (messagesError) {
        console.error("Error fetching chat messages:", messagesError)
        setMessages([])
        return
      }

      if (messagesData && messagesData.length > 0) {
        // Transform to our Message format
        const transformedMessages = messagesData.map((msg: any) => ({
          id: uuidv4(),
          role: msg.role as "user" | "assistant" | "system",
          content: msg.content,
          timestamp: new Date(msg.created_at),
          user_id: msg.user_id, // Store user_id from database
          sentfrom: msg.sentfrom // Store sentfrom from database
        }))

        setMessages(transformedMessages)
        console.log(
          `Loaded ${transformedMessages.length} messages for chat ${chatId}`
        )

        // Fetch usernames for all unique user_ids in messages
        const userIds = [
          ...new Set(
            transformedMessages
              .filter(msg => msg.role === "user" && msg.user_id)
              .map(msg => msg.user_id)
          )
        ]

        if (userIds.length > 0) {
          const { data: profilesData, error: profilesError } = await supabase
            .from("profiles")
            .select("id, full_name")
            .in("id", userIds)

          if (profilesError) {
            console.error("Error fetching user profiles:", profilesError)
          } else if (profilesData) {
            // Create a map of user_id to full_name
            const userNames: { [key: string]: string } = {}
            profilesData.forEach(profile => {
              userNames[profile.id] = profile.full_name
            })
            setUserNamesMap(userNames)
          }
        }
      } else {
        console.log(`No messages found for chat ${chatId}`)
        setMessages([])
      }
    } catch (err) {
      console.error("Error loading chat:", err)
      setMessages([])
    }
  }

  const loadTasks = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status pr√ºfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - √úberspringe Laden der Tasks");
        return; // Fr√ºher Abbruch bei fehlender Internetverbindung
      }

      // Timeout f√ºr die Anfrage setzen, um lange h√§ngende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("tasks").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Tasks in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufr√§umen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedTasks = data.map(task => ({
            ...task,
            title: task.title || task.name,
            ai_model: task.ai_model || task.preferred_model || "gpt-4o"
          }));
          setTasks(formattedTasks);
        }
      } catch (fetchError: any) {
        // Timeout aufr√§umen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Pr√ºfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Task-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Tasks - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading tasks:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu √ºberfluten
      // Wenn die Seite neu geladen wird, wird ein neuer Versuch unternommen
    }
  };

  const loadProjects = async (
    userId: string,
    workspaceId: string | null = null
  ) => {
    try {
      // Offline-Status pr√ºfen
      if (!navigator.onLine) {
        console.log("Offline erkannt - √úberspringe Laden der Projekte");
        return; // Fr√ºher Abbruch bei fehlender Internetverbindung
      }

      // Timeout f√ºr die Anfrage setzen, um lange h√§ngende Requests zu vermeiden
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 Sekunden Timeout

      try {
        let query = supabase.from("projects").select("*");

        // Workspace-Filter
        if (workspaceId) {
          // Wenn ein Workspace angegeben ist, zeige ALLE Projekte in diesem Workspace
          // ohne nach user_id zu filtern
          query = query.eq("workspace_id", workspaceId);
        } else {
          // Nur im pers√∂nlichen Bereich (ohne Workspace) nach user_id filtern
          query = query.is("workspace_id", null).eq("user_id", userId);
        }

        const { data, error } = await query;

        // Timeout aufr√§umen
        clearTimeout(timeoutId);

        if (error) throw error;

        if (data) {
          const formattedProjects = data.map(project => ({
            ...project,
            name: project.name || project.title,
            workspace_id:
              project.workspace_id || project.preferred_workspace_id || "gpt-4o"
          }));
          setProjects(formattedProjects);
        }
      } catch (fetchError: any) {
        // Timeout aufr√§umen, falls der Fehler vor dem Timeout auftrat
        clearTimeout(timeoutId);
        
        // Pr√ºfe, ob es sich um einen Abbruch-Fehler oder Netzwerkfehler handelt
        if (fetchError.name === 'AbortError') {
          console.log("Project-Loading-Anfrage abgebrochen (Timeout)");
        } else if (fetchError.message?.includes('fetch') || fetchError.code === 'ERR_NETWORK') {
          console.log("Netzwerkfehler beim Laden der Projekte - vermutlich offline");
        } else {
          // Andere Supabase-Fehler weiterwerfen
          throw fetchError;
        }
      }
    } catch (err) {
      console.error("Error loading projects:", err);
      // Setze nur einen lokalen Fehler, ohne die Konsole mit weiteren Meldungen zu √ºberfluten
    }
  };

  // Wenn ein user (per Link Sharing) einen spezifischen Chat betritt, dann direkt laden
  useEffect(() => {
    // Lade alle verf√ºgbaren Tasks als Optionen
    if (user) {
      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null
      loadTasks(user.id, workspaceContext)
    }

    // Wenn eine Task-ID in der URL ist, lade diese Task
    if (taskId) {
      console.log("Task ID in URL gefunden:", taskId)
      const fetchTask = async () => {
        if (!supabase) return

        const { data, error } = await supabase
          .from("tasks")
          .select("*")
          .eq("id", taskId)
          .single()

        if (error) {
          console.error("Fehler beim Laden der Task:", error)
          return
        }

        if (data) {
          console.log("Task geladen:", data)
          setSelectedTask(data)
          setSelectedModel(data.ai_model || "gpt-4o")
        }
      }

      fetchTask()
    }
  }, [user, taskId, supabase, rawWorkspaceId, personalWorkspaceId, loadTasks])

  // Effect f√ºr die Textareabehandlung
  useEffect(() => {
    const textarea = inputRef.current
    if (textarea) {
      // Reset height - wichtig, um zu verhindern, dass es nur nach oben w√§chst
      textarea.style.height = "auto"
      // Setze die neue H√∂he basierend auf dem Scroll-H√∂hen-Wert
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`
    }
  }, [inputValue])

  // Reduziere unn√∂tige Re-Renders durch Memoization der Lade-Funktionen
  const loadChatSessionsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadChatSessions(userId, workspaceId);
    },
    [supabase, setChatSessions]
  );
  
  const loadChatMemoized = useCallback(
    async (chatId: string) => {
      return await loadChat(chatId);
    },
    [supabase, user, setMessages, setUserNamesMap]
  );
  
  const loadTasksMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadTasks(userId, workspaceId);
    },
    [supabase, setTasks]
  );
  
  const loadProjectsMemoized = useCallback(
    async (userId: string, workspaceId: string | null = null) => {
      return await loadProjects(userId, workspaceId);
    },
    [supabase, setProjects]
  );

  // Haupt-Initialisierungscode f√ºr den Chat
  useEffect(() => {
    // Zeitsperre, um zu h√§ufige Aufrufe zu verhindern
    const checkSession = async () => {
      // Vermeide mehrfache gleichzeitige Initialisierungen
      if (isInitializingRef.current) {
        debugLog("Initialization already in progress, skipping");
        return;
      }
      
      isInitializingRef.current = true;
      try {
        setLoading(true);

        // Pr√ºfe, ob der Benutzer angemeldet ist
        const {
          data: { session }
        } = await supabase.auth.getSession();

        if (!session) {
          console.log("No session found, redirecting to login");
          router.push("/login");
          return;
        }

        // Benutzer ist angemeldet
        setUser(session.user);

        // Profilnamen laden (nicht kritisch f√ºr Initialisierung)
        if (!userFullName || userFullName === "Du") {
          try {
            const { data: profileData } = await supabase
              .from("profiles")
              .select("full_name")
              .eq("id", session.user.id)
              .single();

            if (profileData?.full_name) {
              setUserFullName(profileData.full_name);
            }
          } catch (profileError) {
            console.error("Error loading user profile:", profileError);
          }
        }

        debugLog(`*** Session exists, user: ${session.user.id}`);

        // Workspace-Kontext bestimmen
        const workspaceContext = rawWorkspaceId || personalWorkspaceId || null;
        debugLog("Current workspace context:", workspaceContext);

        // Chats nur laden, wenn n√∂tig
        if (workspaceContext && !initialChatsLoadedRef.current && chatSessions.length === 0) {
          debugLog("Loading chat sessions for the first time");
          // Use Promise.all to load data in parallel
          await Promise.all([
            loadChatSessionsMemoized(session.user.id, workspaceContext),
            loadProjectsMemoized(session.user.id, workspaceContext)
          ]);
          initialChatsLoadedRef.current = true;
        }

        // Wenn ein Chat bereits in state ist, lade ihn
        if (currentChatId) {
          debugLog("Chat ID in state bereits vorhanden:", currentChatId);
          await loadChatMemoized(currentChatId);
        } else if (chatSessions.length > 0 && !messages.length && !isStartingNewChatRef.current) {
          // Sonst lade den ersten Chat, aber nur wenn:
          // - keine Nachrichten bereits geladen sind 
          // - UND kein expliziter Neustart eines Chats angefordert wurde
          debugLog("Lade den ersten Chat aus vorhandenen Sessions:", chatSessions[0].id);
          setCurrentChatId(chatSessions[0].id);
          await loadChatMemoized(chatSessions[0].id);
        } else if (isStartingNewChatRef.current) {
          debugLog("Neuer Chat wurde explizit angefordert - lade keinen vorhandenen Chat");
          // Flag zur√ºcksetzen nach Verwendung
          isStartingNewChatRef.current = false;
        }

        // Tasks laden (wenn noch nicht geladen)
        if (tasks.length === 0 && workspaceContext) {
          await loadTasksMemoized(session.user.id, workspaceContext);
        }

        // Icebreakers zeigen, wenn keine Nachrichten vorhanden
        if (messages.length === 0) {
          setShowIceBreakers(true);
        }

        // Task laden, wenn eine ID √ºbergeben wurde
        if (taskId && (!selectedTask || selectedTask.id !== taskId)) {
          const { data: taskData, error } = await supabase
            .from("tasks")
            .select("*")
            .eq("id", taskId)
            .single();

          if (!error && taskData) {
            debugLog("Task geladen:", taskData);
            setSelectedTask(taskData);
            setSelectedModel(taskData.ai_model || selectedModel);
          }
        }
      } catch (err: any) {
        console.error("Chat init error:", err);
        setError(err.message);
      } finally {
        setLoading(false);
        
        // Use setTimeout to avoid race conditions when setting isInitializingRef
        if (initializationTimeoutRef.current) {
          clearTimeout(initializationTimeoutRef.current);
        }
        
        initializationTimeoutRef.current = setTimeout(() => {
          isInitializingRef.current = false;
          debugLog("Initialization flag reset to false");
          initializationTimeoutRef.current = null;
        }, 100);
      }
    };

    checkSession();
    
    // Cleanup function
    return () => {
      if (initializationTimeoutRef.current) {
        clearTimeout(initializationTimeoutRef.current);
      }
      if (messageUpdateTimeoutRef.current) {
        clearTimeout(messageUpdateTimeoutRef.current);
      }
    };
  }, [
    supabase,
    currentChatId,
    personalWorkspaceId,
    rawWorkspaceId,
    router,
    taskId
  ]);

  /* eslint-disable react-hooks/rules-of-hooks */
  useEffect(() => {
    if (chatBodyRef.current) {
      chatBodyRef.current.scrollTop = chatBodyRef.current.scrollHeight
    }
  }, [messages])

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        modelDropdownRef.current &&
        !modelDropdownRef.current.contains(event.target as Node)
      ) {
        setShowModelDropdown(false)
      }

      if (
        taskDropdownRef.current &&
        !taskDropdownRef.current.contains(event.target as Node)
      ) {
        setShowTaskDropdown(false)
      }

      // Schlie√üe Chat-Men√º bei Klick au√üerhalb
      const chatMenuTarget = (event.target as Element)?.closest(
        "[data-chat-menu]"
      )
      if (chatMenuOpen && !chatMenuTarget) {
        setChatMenuOpen(null)
      }

      // Schlie√üe Projekt-Men√º bei Klick au√üerhalb
      const projectMenuTarget = (event.target as Element)?.closest(
        "[data-project-menu]"
      )
      if (projectMenuOpen && !projectMenuTarget) {
        setProjectMenuOpen(null)
      }
    }

    document.addEventListener("mousedown", handleClickOutside)
    return () => {
      document.removeEventListener("mousedown", handleClickOutside)
    }
  }, [chatMenuOpen, projectMenuOpen])

  // Haupt-Funktion zum Senden einer Nachricht an die API
  const sendMessageToAPI = async (
    messages: Message[],
    model: string,
    chatId: string
  ) => {
    console.log(`üîÑ sendMessageToAPI v2 aufgerufen mit Chat-ID: ${chatId}`);

    const userId = user?.id;
    if (!userId) {
      console.error("‚ùå User ID fehlt beim Senden an API.");
      throw new Error("User ID ist erforderlich");
    }

    // 1. DATEN SAMMELN (wie bisher)
    // --------------------------------
    console.log(`üë§ Hole Benutzerprofil f√ºr User ID: ${userId}`);
    const { data: fetchedUserProfile, error: profileError } = await supabase
        .from("profiles")
        .select("*")
      .eq("id", userId)
      .single();
      
    // Use fetchedUserProfile instead of the state variable userProfile directly here
    // to ensure we have the latest data for this specific call.
    if (profileError) console.error("Fehler beim Abrufen des Profils:", profileError);
    else console.log("‚úÖ Benutzerprofil erfolgreich abgerufen");

    const lastUserMessage = [...messages].reverse().find(m => m.role === "user");
    let knowledgeResults: any[] = [];
    let similarMessages: any[] = []; // Assuming this holds structured QA or relevant snippets
    // (SelectedTask comes from component state)
    const currentSelectedTask = selectedTask; // Capture state at the time of call

    if (lastUserMessage) {
        const userQuery = lastUserMessage.content;
        
        // Wissensdatenbank-Suche (falls KB ausgew√§hlt)
        if (selectedKnowledgeBaseId && selectedKnowledgeBaseId.length > 0) { 
            try {
                console.log(`üß† Performing knowledge base search for KBs: ${selectedKnowledgeBaseId.join(', ')}...`);
                const { data: authData } = await supabase.auth.getSession();
                const authToken = authData?.session?.access_token;

                // Alle Ergebnisse aus allen ausgew√§hlten Wissensdatenbanken sammeln
                let allKnowledgeResults: any[] = [];
                
                // Sequentiell durch alle ausgew√§hlten Wissensdatenbanken gehen
                for (const kbId of selectedKnowledgeBaseId) {
                    const knowledgeResponse = await fetch("/api/knowledge/search", {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({
                            query: userQuery,
                            knowledge_base_id: kbId,
                            auth_token: authToken
                        })
                    });
                    
                    if (knowledgeResponse.ok) {
                        const knowledgeData = await knowledgeResponse.json();
                        const results = knowledgeData.results || [];
                        console.log(`üß† Found ${results.length} raw knowledge items from KB ${kbId}.`);
                        allKnowledgeResults.push(...results);
                    } else {
                        console.error(`‚ö†Ô∏è Knowledge base search failed for KB ${kbId}:`, knowledgeResponse.statusText);
                    }
                }
                
                // Sortiere alle Ergebnisse nach Relevanz (falls ein similarity-Feld existiert)
                knowledgeResults = allKnowledgeResults.sort((a, b) => (b.similarity || 0) - (a.similarity || 0));
                console.log(`üß† Combined ${knowledgeResults.length} total knowledge items from all KBs.`);
          
            } catch (knowledgeError) {
                console.error("‚ùå Error during knowledge base search fetch:", knowledgeError);
            }
        } else {
            console.log("‚ÑπÔ∏è Keine Wissensdatenbank ausgew√§hlt, √ºberspringe Suche.");
        }
        
        // Suche nach √§hnlichen Nachrichten (wie bisher)
        try {
            console.log(`üîç Suche nach User-weiten Kontext f√ºr User ${userId}, basierend auf: ${userQuery.substring(0, 30)}...`);
            // Assuming findSimilarMessagesOptimized returns the structured data needed
            similarMessages = await findSimilarMessagesOptimized(userId, userQuery, lastUserMessage.id) || [];
            console.log(`‚úÖ ${similarMessages.length} √§hnliche Nachrichten gefunden`);
             // Log details of similar messages structure if needed for debugging
             // console.log("Similar messages structure:", JSON.stringify(similarMessages.slice(0,2), null, 2));
        } catch (error) {
            console.error("‚ùå Fehler bei der Suche nach √§hnlichen Nachrichten:", error);
        }

    } else {
      console.warn("Keine letzte Benutzernachricht gefunden, kann keinen Kontext generieren.");
      // Handle case where there's somehow no user message? Maybe return early or send without context.
    }
    
    // KONSOLIDIERTE PROMPT-ERSTELLUNG MIT DEM NEUEN PROMPT-BUILDER
    // -------------------------------------------
    const userInput = lastUserMessage ? lastUserMessage.content : "";
    
    // Verwende den neuen buildPrompt statt manueller Zusammensetzung
    const finalPrompt = buildPrompt({
      userInput,
      chatId,
      taskPrompt: currentSelectedTask?.system_prompt || null,
      // Verwende den aus prompt-builder.ts importierten DEFAULT_SYSTEM_PROMPT 
      // Das systemPrompt muss hier nicht explizit √ºbergeben werden, da es den DEFAULT_SYSTEM_PROMPT nutzt
      userProfile: fetchedUserProfile,
      knowledgeResults,
      pastMessages: similarMessages,
      allMessages: messages,
      modelType: "default", // Standard-Chat
      maxPastMessages: 4,
      maxKnowledgeResults: 3
    });
    
    console.log(`üì© Sende an API: ${messages.filter(m => m.role !== 'system').length} User/Assistant Nachrichten, ${finalPrompt.length - messages.filter(m => m.role !== 'system').length} System/Assistant Kontextobjekt(e)`);
    console.log("Final apiMessages array (V2) before API call:", JSON.stringify(finalPrompt, null, 2));
    
    // API CALL MIT STREAMING
    // --------------------------------------------------
    try {
        const apiUrl = `/api/chat?model=${encodeURIComponent(model)}&chatId=${encodeURIComponent(chatId)}`;
        
        // Streaming aktivieren
        const streaming = true;
        
        if (streaming) {
          // Streaming Anfrage mit benutzerdefinierten Parametern
          const response = await fetch(apiUrl, {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              messages: finalPrompt,
              streaming: true
            })
          });
          
          if (!response.ok) {
            const errorBody = await response.text();
            console.error("API Error Response Body:", errorBody);
            throw new Error(`API responded with ${response.status}`);
          }

          // Stream verarbeiten
          const reader = response.body?.getReader();
          if (!reader) throw new Error("Stream reader not available");
          
          const decoder = new TextDecoder();
          let fullContent = "";
          let metaInfo = null;
          
          // Event-basierter Streaming-Modus (gibt Text-Chunks zur√ºck w√§hrend sie ankommen)
          return {
            content: "", // Wird unten schrittweise gef√ºllt
            streamContent: async function* () {
              let buffer = ""; // Puffer f√ºr eingehende Chunks
              const decoder = new TextDecoder();
              let accumulatedJsonRemainder = ""; // Buffer for incomplete JSON chunks

              try {
                while (true) {
                  const { done, value } = await reader.read();
                  if (done) {
                    // Yield any remaining buffer content when the stream ends
                    if (buffer.length > 0) {
                      yield buffer;
                      // fullContent is already updated progressively
                    }
                     // Yield any remaining JSON remainder if it's valid text
                    if (accumulatedJsonRemainder.length > 0 && !accumulatedJsonRemainder.startsWith('{')) {
                       yield accumulatedJsonRemainder;
                    }
                    break;
                  }

                  const rawChunk = decoder.decode(value, { stream: true });
                  accumulatedJsonRemainder += rawChunk;

                  let textToProcess = "";
                  let processFromIndex = 0;

                  // Attempt to parse JSON if it looks like it might be JSON
                  if (accumulatedJsonRemainder.includes('{') && accumulatedJsonRemainder.includes('}')) {
                      try {
                          // Find potential JSON boundary more robustly
                          let potentialJsonEnd = accumulatedJsonRemainder.lastIndexOf('}') + 1;
                          let potentialJson = accumulatedJsonRemainder.substring(0, potentialJsonEnd);
                          
                          // Basic check if it looks like a valid JSON object
                          if (potentialJson.startsWith('{')) {
                              const parsed = JSON.parse(potentialJson);
                              if (parsed && typeof parsed.content === 'string') {
                                  textToProcess = parsed.content;
                                  // Update fullContent only with the actual text part
                                  fullContent += textToProcess;
                                  // Remove the processed JSON part from the remainder
                                  accumulatedJsonRemainder = accumulatedJsonRemainder.substring(potentialJsonEnd);
                                  processFromIndex = 0; // Start processing the new text from beginning
                              } else {
                                 // Valid JSON but not the expected format, treat accumulated as text
                                 textToProcess = accumulatedJsonRemainder;
                                 fullContent += textToProcess; // Add raw chunk to fullContent
                                 accumulatedJsonRemainder = ""; // Clear remainder
                      }
    } else {
                             // Doesn't start with '{', treat as raw text
                             textToProcess = accumulatedJsonRemainder;
                             fullContent += textToProcess; // Add raw chunk to fullContent
                             accumulatedJsonRemainder = ""; // Clear remainder
                        }
                      } catch (e) {
                          // Invalid JSON or incomplete chunk, wait for more data or treat as text if stream ends
                          // Continue accumulating, do not process buffer yet unless it's very long
                          if (accumulatedJsonRemainder.length > 1000) { // Process as text if buffer gets too long
                               textToProcess = accumulatedJsonRemainder;
                               fullContent += textToProcess; // Add raw chunk to fullContent
                               accumulatedJsonRemainder = ""; // Clear remainder
                      }
                    }
    } else {
                     // Does not contain braces, likely raw text
                     textToProcess = accumulatedJsonRemainder;
                     fullContent += textToProcess; // Add raw chunk to fullContent
                     accumulatedJsonRemainder = ""; // Clear remainder
                  }
                  
                  // If we extracted text (either from JSON or raw chunk), add to buffer and yield words
                  if (textToProcess) {
                    buffer += textToProcess;

                    // Process the buffer to yield whole words/segments
                    let lastDelimiterPos = -1;
                    const lastSpacePos = buffer.lastIndexOf(' ');
                    const lastNewlinePos = buffer.lastIndexOf('\\n');
                    lastDelimiterPos = Math.max(lastSpacePos, lastNewlinePos);

                    if (lastDelimiterPos !== -1) {
                      const partToYield = buffer.substring(0, lastDelimiterPos + 1);
                      if (partToYield.length > 0) {
                           yield partToYield;
                      }
                      buffer = buffer.substring(lastDelimiterPos + 1);
                    }
                  }
                }
              } catch (error) {
                console.error("Error reading stream:", error);
                if (buffer.length > 0) yield buffer;
                if (accumulatedJsonRemainder.length > 0) yield accumulatedJsonRemainder;
                throw error;
              } finally {
                this.content = fullContent;
              }
            },
            getContent: () => fullContent,
            model: model
          };
        } else {
          // Nicht-Streaming-Modus (f√ºr Fallback)
      const apiResponse = await fetch(apiUrl, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
              messages: finalPrompt
        })
        });

      if (!apiResponse.ok) {
            // Log response body if available
            const errorBody = await apiResponse.text();
            console.error("API Error Response Body:", errorBody);
            throw new Error(`API responded with ${apiResponse.status}`);
        }

        const data = await apiResponse.json();
        return data; // R√ºckgabe an den Aufrufer (handleSendMessage)
        }
    } catch (error) {
        console.error("‚ùå Fehler beim API-Aufruf in sendMessageToAPI:", error);
        throw error; // Fehler weitergeben, damit handleSendMessage ihn fangen kann
    }
  }  // Ende von sendMessageToAPI

  const handleTypewriterComplete = (messageId: string) => {
    const updatedMessages = messages.map(m =>
      m.id === messageId ? { ...m, isTypewriting: false } : m
    )
    setMessages(updatedMessages)
    setTypingMessageId(null)
  }

  const handleCreateTask = async () => {
    if (!newTaskName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || null

      const { data, error } = await supabase
        .from("tasks")
        .insert({
          title: newTaskName,
          description: newTaskDescription,
          system_prompt: newTaskSystemPrompt,
          ai_model: newTaskModel,
          status: "todo",
          priority: "medium",
          user_id: user.id,
          workspace_id: workspaceContext
        })
        .select()

      if (error) throw error

      await loadTasks(user.id, workspaceContext)

      setShowTaskModal(false)
      setNewTaskName("")
      setNewTaskDescription("")
      setNewTaskSystemPrompt("")
      setNewTaskModel("gpt-4o")
    } catch (err) {
      console.error("Error creating task:", err)
    } finally {
      setLoading(false)
    }
  }

  const handleCreateProject = async () => {
    if (!newProjectName.trim()) return

    try {
      setLoading(true)

      const workspaceContext = rawWorkspaceId || personalWorkspaceId || null

      // ---> START DEBUG LOG <---
      console.log("--- Creating Project --- ")
      console.log("User ID to send:", user?.id)
      console.log("Raw Workspace ID from URL:", rawWorkspaceId)
      console.log("Personal Workspace ID state:", personalWorkspaceId)
      console.log("Workspace Context to send:", workspaceContext)
      // ---> END DEBUG LOG <---

      // ---> ADDED AUTH CHECK <---
      const { data: authData, error: authError } =
        await supabase.auth.getSession()
      console.log("--- Auth Check Before Insert ---")
      console.log("Current Session:", authData?.session)
      console.log("Session User ID:", authData?.session?.user?.id)
      console.log("Auth Error:", authError)
      if (authError || !authData?.session) {
        console.error("CRITICAL: No valid session before insert!")
        // Optionally: Prevent the insert or show an error to the user
        // return;
      }
      // ---> END AUTH CHECK <---

      // ---> ADDED DIAGNOSTIC FUNCTION <---
      // This immediately runs when you click "Create Project" in the UI
      // It helps diagnose why the workspace membership check fails
      console.log("--- Running Diagnostic Function ---")
      const diagResult = await supabase.rpc("diagnose_workspace_membership", {
        p_user_id: user.id,
        p_workspace_id: workspaceContext
      })
      console.log("Diagnosis Result:", diagResult)
      // Explicit logging of the important diagnostic data
      console.log("MEMBERSHIP DATA:", JSON.stringify(diagResult.data, null, 2))
      if (diagResult.data) {
        console.log("User ID Input:", diagResult.data.user_id_input)
        console.log("Workspace ID Input:", diagResult.data.workspace_id_input)
        console.log("Membership Exists:", diagResult.data.membership_exists)
        console.log("Membership Count:", diagResult.data.membership_count)
        console.log("All User Workspaces:", diagResult.data.all_user_workspaces)
        console.log(
          "All Workspace Members:",
          diagResult.data.all_workspace_members
        )
      }
      // ---> END DIAGNOSTIC FUNCTION <---

      // Use the database function instead of direct table access
      // This bypasses RLS issues while maintaining security checks in the function
      const { data, error } = await supabase.rpc("create_project", {
        p_name: newProjectName,
        p_description: newProjectDescription,
        p_user_id: user.id,
        p_workspace_id: workspaceContext,
        p_color: "#4c4cff",
        p_status: "active"
      })

      if (error) throw error

      await loadProjects(user.id, workspaceContext)
      setShowProjectModal(false)
      setNewProjectName("")
      setNewProjectDescription("")
    } catch (err) {
      console.error("Error creating project:", err)
    } finally {
      setLoading(false)
    }
  }

  // Generate a chat name from the first user message
  const generateChatName = (message: string): string => {
    // Split the message into words
    const words = message.trim().split(/\s+/)

    // Get up to the first 3 words
    const firstThreeWords = words.slice(0, 3).join(" ")

    // If the result is too short, use "Neuer Chat"
    return firstThreeWords.length >= 3 ? firstThreeWords : "Neuer Chat"
  }

  // Modifiziere den useEffect f√ºr Task-Wechsel
  useEffect(() => {
    // Only perform task change operations if no message update is pending
    // And ensure at least 500ms has passed since the last message update
    const timeSinceLastUpdate = Date.now() - lastMessageUpdate
    if (messageUpdatePending || timeSinceLastUpdate < 500) {
      console.log(
        "Message update in progress or too recent, deferring task change handling"
      )
      return
    }

    const handleTaskOrModelChange = async () => {
      // Pr√ºfen, ob es sich um einen Task- oder Modellwechsel handelt
      const isTaskChange = selectedTask?.id !== previousSelectedTask?.id
      // const isModelChange = selectedModel !== previousSelectedModel && !selectedTask;

      // Run this logic ONLY on task change, not on simple model selection
      if (isTaskChange && messages.length > 0) {
        // Wenn eine Task oder ein Modell gewechselt wurde und es Nachrichten gibt

        console.log("Task wurde gewechselt, erstelle Zusammenfassung...")

        try {
          // Pr√ºfe, ob bereits eine Zusammenfassung im Chat existiert
          const lastSummaryMessage = [...messages]
            .reverse()
            .find(
              msg =>
                msg.role === "assistant" &&
                (msg.content.includes("Chat-Zusammenfassung") ||
                  msg.content.includes("Hauptpunkte:") ||
                  msg.content.includes("Zusammenfassung des Chats"))
            )

          let summary: string

          if (lastSummaryMessage) {
            // Verwende die vorhandene Zusammenfassung
            console.log("Verwende vorhandene Zusammenfassung")
            summary = lastSummaryMessage.content
          } else {
            // Erstelle eine neue Zusammenfassung, da keine vorhanden ist
            console.log("√úberspringe Zusammenfassung f√ºr Task-Wechsel (DEBUG)")
            summary = "" // Tempor√§r deaktiviert
          }

          if (summary) {
            // Erstelle eine neue System-Nachricht mit der Zusammenfassung
            const summarySystemMessage: Message = {
              id: uuidv4(),
              role: "system",
              content: `Zusammenfassung des bisherigen Gespr√§chs: ${summary}

${selectedTask ? selectedTask.system_prompt : "Fahre mit dem Gespr√§ch fort, basierend auf dieser Zusammenfassung."}`,
              timestamp: new Date()
            }

            // Entferne alle bisherigen System-Nachrichten
            const filteredMessages = messages.filter(m => m.role !== "system")

            // F√ºge die neue System-Nachricht am Anfang hinzu
            setMessages([summarySystemMessage, ...filteredMessages])

            console.log(
              "Zusammenfassung wurde als System-Nachricht hinzugef√ºgt."
            )

            // Task-switching notification message is REMOVED
          }
        } catch (error) {
          console.error("Error in task change handling:", error)
        } finally {
          // Always set isTaskSwitching to false when complete
          setIsTaskSwitching(false)
        }
      } else {
        // If there's no task change or no messages, just reset the switching state
        setIsTaskSwitching(false)
      }

      // Aktuelle Task und Modell f√ºr den n√§chsten Vergleich speichern
      setPreviousSelectedTask(selectedTask)
      setPreviousSelectedModel(selectedModel)
    }

    handleTaskOrModelChange()
  }, [
    selectedTask,
    selectedModel,
    messages,
    messageUpdatePending,
    previousSelectedTask,
    previousSelectedModel,
    lastMessageUpdate
  ])

  // Add this function to sync messages with the database when needed
  const syncMessagesWithDatabase = async (chatId: string) => {
    if (!chatId) return

    try {
      console.log("Syncing messages with database for chat:", chatId)
      const { data, error } = await supabase
        .from("chat_messages")
        .select("*")
        .eq("chat_id", chatId)
        .order("created_at", { ascending: true })

      if (error) {
        console.error("Error syncing messages:", error)
        return
      }

      if (data) {
        // Convert database messages to app message format
        const formattedMessages: Message[] = data.map(dbMsg => ({
          id: dbMsg.id || uuidv4(),
          role: dbMsg.role as "user" | "assistant" | "system",
          content: dbMsg.content,
          timestamp: new Date(dbMsg.created_at)
        }))

        console.log(`Synced ${formattedMessages.length} messages from database`)
        setMessages(formattedMessages)
      }
    } catch (error) {
      console.error("Error in syncMessagesWithDatabase:", error)
    }
  }

  // Modify handleSendMessage to optionally include web search results
  const handleSendMessage = async (
    message: string,
    includeWebSearch: boolean = false
  ) => {
    if (message.trim().length === 0) return
    if (isTyping || messageUpdatePending || isTaskSwitching) return

    // Markieren, dass der Benutzer mit dem Tippen begonnen hat
    setHasStartedTyping(true)

    const userMessageId = uuidv4()
    const newMessage: Message = {
      id: userMessageId,
      role: "user",
      content: message,
      timestamp: new Date(),
      user_id: user?.id,
      sentfrom: userFullName
    }

    console.log("Creating new message with user_id:", user?.id)

    try {
      // Prevent task switching effects during message sending
      setMessageUpdatePending(true)
      setLastMessageUpdate(Date.now())

      // Create the new array *before* setting state
      const newMessagesArray = [...messages, newMessage]

      // Add user message to state immediately for better UX
      setMessages(newMessagesArray) // Use the new array
      setInputValue("") // Eingabefeld leeren

      // Show typing indicator
      setIsTyping(true)

      // If web search is requested, perform it before sending to API
      let webSearchResults = null
      if (includeWebSearch) {
        setIsSearching(true)
        try {
          webSearchResults = await performSerpApiSearch(message)
          console.log("Web search results:", webSearchResults.length)
        } catch (searchError) {
          console.error("Error during web search:", searchError)
        } finally {
          setIsSearching(false)
        }
      }

      let chatIdToUse = currentChatId

      // If no current chat exists, create a new one before proceeding
      if (!chatIdToUse) {
        console.log(
          "No current chat, creating new one before sending message..."
        )
        chatIdToUse = await createNewChat()
        if (!chatIdToUse) {
          throw new Error("Failed to create a new chat")
        }
        console.log(`Successfully created new chat with ID: ${chatIdToUse}`)
        // Set current chat ID immediately to ensure context is maintained
        setCurrentChatId(chatIdToUse)
      }

      // Speichern der Benutzernachricht in der Datenbank
      console.log(`Saving message to chat ID: ${chatIdToUse}`)

      // Wichtig: Wir ben√∂tigen diese Nachrichts-ID f√ºr Embedding
      let dbMessageId = null;

      try {
      const { data: messageData, error: messageError } = await retryOperation(
        async () => {
          return await supabase
            .from("chat_messages")
            .insert({
              chat_id: chatIdToUse,
              role: "user",
                content: message,
              user_id: user?.id,
              sentfrom: userFullName,
              created_at: newMessage.timestamp.toISOString()
            })
            .select()
        },
        3,
        1000
        );

      if (messageError) {
        console.error("‚ùå Error saving message:", messageError)
      } else {
        console.log("‚úÖ Message saved successfully to database", messageData)
          // Speichere die ID f√ºr sp√§tere Verwendung
        if (messageData && messageData.length > 0) {
            dbMessageId = messageData[0].id;
          }
        }
      } catch (saveError) {
        console.error("Error saving user message:", saveError);
        // Wir setzen den Prozess fort, auch wenn die Nachricht nicht gespeichert werden konnte
      }

      // Vorbereiten und Senden der Anfrage an die API
      try {
        const modelToUse = selectedTask?.ai_model || selectedModel
        console.log("üì£ Sende Nachricht an API mit Chat-ID:", chatIdToUse)
        console.log("üîÑ Ausgew√§hltes Modell f√ºr diese Anfrage:", modelToUse);

        // Streaming-Response
        const response = await sendMessageToAPI(
          newMessagesArray,
          modelToUse,
          chatIdToUse
        )

        // Assistentennachricht erstellen und anzeigen (vorerst leer)
        const assistantMessageId = uuidv4()
        const assistantMessage: Message = {
          id: assistantMessageId,
          role: "assistant",
          content: "", // Startinhalt ist leer, wird nach und nach gef√ºllt
          timestamp: new Date(),
          isTypewriting: true // Ensure this is set to true
        }

        // Calculate whether to show the effect
        const showEffect = assistantMessage.role === "assistant" && (assistantMessage.isTypewriting || typingMessageId === assistantMessage.id);

        // Modifiziere die AssistentMessage-Creation f√ºr mehr Konsistenz
        const assistantMessage: Message = {
          id: assistantMessageId,
          role: "assistant",
          content: "", // Startinhalt ist leer, wird nach und nach gef√ºllt
          timestamp: new Date(),
          isTypewriting: true // Stelle sicher, dass dies immer auf true gesetzt ist
        };

        // Add to messages immediately to show the placeholder
        setMessages(prevMessages => [...prevMessages, assistantMessage])
        setTypingMessageId(assistantMessageId) // Track the message ID that's being typed

        // Wenn Streaming-Antwort verf√ºgbar ist, nutze diese
        if (response.streamContent) {
